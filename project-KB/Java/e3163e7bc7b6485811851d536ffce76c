diff --git a/kura/org.eclipse.kura.ble.provider/src/main/java/org/eclipse/kura/internal/ble/util/BluetoothLeUtil.java b/kura/org.eclipse.kura.ble.provider/src/main/java/org/eclipse/kura/internal/ble/util/BluetoothLeUtil.java
index f898b8bde0..c0aac3cb51 100644
--- a/kura/org.eclipse.kura.ble.provider/src/main/java/org/eclipse/kura/internal/ble/util/BluetoothLeUtil.java
+++ b/kura/org.eclipse.kura.ble.provider/src/main/java/org/eclipse/kura/internal/ble/util/BluetoothLeUtil.java
@@ -20,9 +20,9 @@
 import java.util.concurrent.Future;
 
 import org.apache.commons.io.FileUtils;
-import org.eclipse.kura.bluetooth.le.beacon.AdvertisingReportRecord;
-import org.apache.logging.log4j.Logger;
 import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.eclipse.kura.bluetooth.le.beacon.AdvertisingReportRecord;
 
 public class BluetoothLeUtil {
 
@@ -42,24 +42,38 @@ public class BluetoothLeUtil {
             FileUtils.writeStringToFile(f, "#!/bin/bash\n" + "set -e\n" + "ADAPTER=$1\n"
                     + "{ exec hcidump -i $ADAPTER -R -w /dev/fd/3 >/dev/null; } 3>&1", false);
 
-            f.setExecutable(true);
+            if (!f.setExecutable(true)) {
+                logger.warn("Unable to set as executable");
+            }
         } catch (IOException e) {
             logger.info("Unable to update", e);
         }
 
     }
 
+    private BluetoothLeUtil() {
+
+    }
+
     /*
      * Utility method to send specific kill commands to processes.
      */
     public static void killCmd(String cmd, String signal) {
         String[] commandPidOf = { "pidof", cmd };
         BluetoothSafeProcess proc = null;
-        BufferedReader br = null;
         try {
             proc = BluetoothProcessUtil.exec(commandPidOf);
             proc.waitFor();
-            br = new BufferedReader(new InputStreamReader(proc.getInputStream()));
+        } catch (IOException e) {
+            logger.error(COMMAND_ERROR, commandPidOf, e);
+            return;
+        } catch (InterruptedException e) {
+            logger.error(COMMAND_ERROR, commandPidOf, e);
+            Thread.currentThread().interrupt();
+        }
+        
+        try (InputStreamReader is = new InputStreamReader(proc.getInputStream());
+                BufferedReader br = new BufferedReader(is);) {
             String pid = br.readLine();
 
             // Check if the pid is not empty
@@ -70,20 +84,8 @@ public static void killCmd(String cmd, String signal) {
 
         } catch (IOException e) {
             logger.error(COMMAND_ERROR, commandPidOf, e);
-        } catch (InterruptedException e) {
-            Thread.currentThread().interrupt();
-            logger.error(COMMAND_ERROR, commandPidOf, e);
         } finally {
-            if (proc != null) {
-                proc.destroy();
-            }
-            try {
-                if (br != null) {
-                    br.close();
-                }
-            } catch (IOException e) {
-                logger.warn("Error closing process for command: {}", commandPidOf, e);
-            }
+            proc.destroy();
         }
     }
 
diff --git a/kura/org.eclipse.kura.core.deployment/src/main/java/org/eclipse/kura/core/deployment/download/impl/GenericDownloadCountingOutputStream.java b/kura/org.eclipse.kura.core.deployment/src/main/java/org/eclipse/kura/core/deployment/download/impl/GenericDownloadCountingOutputStream.java
index 29fc46741a..8ab31dc7c9 100644
--- a/kura/org.eclipse.kura.core.deployment/src/main/java/org/eclipse/kura/core/deployment/download/impl/GenericDownloadCountingOutputStream.java
+++ b/kura/org.eclipse.kura.core.deployment/src/main/java/org/eclipse/kura/core/deployment/download/impl/GenericDownloadCountingOutputStream.java
@@ -9,7 +9,6 @@
  * Contributors:
  *     Eurotech
  *******************************************************************************/
-
 package org.eclipse.kura.core.deployment.download.impl;
 
 import java.io.IOException;
@@ -34,28 +33,27 @@ public class GenericDownloadCountingOutputStream extends CountingOutputStream {
     long totalBytes;
 
     final DeploymentPackageDownloadOptions options;
-    final SslManagerService m_sslManagerService;
+    final SslManagerService sslManagerService;
     final ProgressListener pl;
-    final int m_alreadyDownloaded;
-    final String m_downloadURL;
+    final int alreadyDownloaded;
+    final String downloadURL;
 
     InputStream is = null;
 
-    private long m_currentStep = 1;
-    // private long previous;
-    private DownloadStatus m_downloadStatus = DownloadStatus.FAILED;
+    private long currentStep = 1;
+    private DownloadStatus downloadStatus = DownloadStatus.FAILED;
 
     public GenericDownloadCountingOutputStream(DownloadOptions downloadOptions) {
         super(downloadOptions.getOut());
         this.options = downloadOptions.getRequestOptions();
-        this.m_sslManagerService = downloadOptions.getSslManagerService();
+        this.sslManagerService = downloadOptions.getSslManagerService();
         this.pl = downloadOptions.getCallback();
-        this.m_downloadURL = downloadOptions.getDownloadURL();
-        this.m_alreadyDownloaded = downloadOptions.getAlreadyDownloaded();
+        this.downloadURL = downloadOptions.getDownloadURL();
+        this.alreadyDownloaded = downloadOptions.getAlreadyDownloaded();
     }
 
     public DownloadStatus getDownloadTransferStatus() {
-        return this.m_downloadStatus;
+        return this.downloadStatus;
     }
 
     public Long getDownloadTransferProgressPercentage() {
@@ -83,10 +81,8 @@ protected void afterWrite(int n) throws IOException {
         } else if (this.propResolution == 0) {
             this.propResolution = 1024 * 256;
         }
-        if (getByteCount() >= this.m_currentStep * this.propResolution) {
-            // System.out.println("Bytes read: "+ (getByteCount() - previous));
-            // previous = getByteCount();
-            this.m_currentStep++;
+        if (getByteCount() >= this.currentStep * this.propResolution) {
+            this.currentStep++;
             postProgressEvent(this.options.getClientId(), getByteCount(), this.totalBytes, DownloadStatus.IN_PROGRESS,
                     null);
         }
@@ -94,16 +90,15 @@ protected void afterWrite(int n) throws IOException {
             Thread.sleep(this.propBlockDelay);
         } catch (InterruptedException e) {
             Thread.currentThread().interrupt();
-            e.printStackTrace();
         }
     }
 
     protected void postProgressEvent(String clientId, long progress, long total, DownloadStatus status,
             String errorMessage) {
         Long perc = getDownloadTransferProgressPercentage();
-        this.m_downloadStatus = status;
+        this.downloadStatus = status;
         ProgressEvent pe = new ProgressEvent(this, this.options, ((Long) total).intValue(), perc.intValue(),
-                getDownloadTransferStatus().getStatusString(), this.m_alreadyDownloaded);
+                getDownloadTransferStatus().getStatusString(), this.alreadyDownloaded);
         if (errorMessage != null) {
             pe.setExceptionMessage(errorMessage);
         }
diff --git a/kura/org.eclipse.kura.core.deployment/src/main/java/org/eclipse/kura/core/deployment/download/impl/HttpDownloadCountingOutputStream.java b/kura/org.eclipse.kura.core.deployment/src/main/java/org/eclipse/kura/core/deployment/download/impl/HttpDownloadCountingOutputStream.java
index b81bbe0636..0e8567920c 100644
--- a/kura/org.eclipse.kura.core.deployment/src/main/java/org/eclipse/kura/core/deployment/download/impl/HttpDownloadCountingOutputStream.java
+++ b/kura/org.eclipse.kura.core.deployment/src/main/java/org/eclipse/kura/core/deployment/download/impl/HttpDownloadCountingOutputStream.java
@@ -92,7 +92,7 @@ protected PasswordAuthentication getPasswordAuthentication() {
                         });
                     }
 
-                    localUrl = new URL(HttpDownloadCountingOutputStream.this.m_downloadURL);
+                    localUrl = new URL(HttpDownloadCountingOutputStream.this.downloadURL);
                     URLConnection urlConnection = localUrl.openConnection();
                     int connectTimeout = getConnectTimeout();
                     int readTimeout = getPropReadTimeout();
@@ -167,7 +167,7 @@ private void testConnectionProtocol(URLConnection urlConnection) throws IOExcept
         try {
             if (urlConnection instanceof HttpsURLConnection) {
                 ((HttpsURLConnection) urlConnection)
-                        .setSSLSocketFactory(this.m_sslManagerService.getSSLSocketFactory());
+                        .setSSLSocketFactory(this.sslManagerService.getSSLSocketFactory());
             } else if (!(urlConnection instanceof HttpURLConnection)) {
                 postProgressEvent(this.options.getClientId(), getByteCount(), this.totalBytes, DownloadStatus.FAILED,
                         "The request URL is not supported");
diff --git a/kura/org.eclipse.kura.core/src/main/java/org/eclipse/kura/core/data/DataServiceImpl.java b/kura/org.eclipse.kura.core/src/main/java/org/eclipse/kura/core/data/DataServiceImpl.java
index 42a6e6438e..20091b1f33 100644
--- a/kura/org.eclipse.kura.core/src/main/java/org/eclipse/kura/core/data/DataServiceImpl.java
+++ b/kura/org.eclipse.kura.core/src/main/java/org/eclipse/kura/core/data/DataServiceImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2011, 2017 Eurotech and/or its affiliates
+ * Copyright (c) 2011, 2018 Eurotech and/or its affiliates
  *
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
@@ -33,7 +33,6 @@
 import org.eclipse.kura.KuraException;
 import org.eclipse.kura.KuraNotConnectedException;
 import org.eclipse.kura.KuraStoreException;
-import org.eclipse.kura.KuraTimeoutException;
 import org.eclipse.kura.KuraTooManyInflightMessagesException;
 import org.eclipse.kura.configuration.ConfigurableComponent;
 import org.eclipse.kura.configuration.ConfigurationService;
@@ -97,7 +96,7 @@ public class DataServiceImpl implements DataService, DataTransportListener, Conf
     private boolean notifyPending;
     private final Condition lockCondition = this.lock.newCondition();
 
-    private volatile AtomicBoolean publisherEnabled = new AtomicBoolean();
+    private final AtomicBoolean publisherEnabled = new AtomicBoolean();
 
     private ServiceTracker<H2DbService, H2DbService> dbServiceTracker;
     private ComponentContext componentContext;
@@ -513,12 +512,12 @@ public void disconnect(long quiesceTimeout) {
     }
 
     @Override
-    public void subscribe(String topic, int qos) throws KuraTimeoutException, KuraException, KuraNotConnectedException {
+    public void subscribe(String topic, int qos) throws KuraException {
         this.dataTransportService.subscribe(topic, qos);
     }
 
     @Override
-    public void unsubscribe(String topic) throws KuraTimeoutException, KuraException, KuraNotConnectedException {
+    public void unsubscribe(String topic) throws KuraException {
         this.dataTransportService.unsubscribe(topic);
     }
 
@@ -703,24 +702,23 @@ private synchronized void publishInternal(DataMessage message) throws KuraExcept
         boolean retain = message.isRetain();
         int msgId = message.getId();
 
-        logger.debug("Publishing message with ID: {} on topic: {}, priority: {}",
-                new Object[] { msgId, topic, message.getPriority() });
+        logger.debug("Publishing message with ID: {} on topic: {}, priority: {}", msgId, topic, message.getPriority());
 
-        DataTransportToken token = this.dataTransportService.publish(topic, payload, qos, retain);
+        DataTransportToken token = DataServiceImpl.this.dataTransportService.publish(topic, payload, qos, retain);
 
         if (token == null) {
-            this.store.published(msgId);
+            DataServiceImpl.this.store.published(msgId);
             logger.debug("Published message with ID: {}", msgId);
         } else {
 
             // Check if the token is already tracked in the map (in which case we are in trouble)
-            Integer trackedMsgId = this.inFlightMsgIds.get(token);
+            Integer trackedMsgId = DataServiceImpl.this.inFlightMsgIds.get(token);
             if (trackedMsgId != null) {
-                logger.error("Token already tracked: {} -", token.getSessionId(), token.getMessageId());
+                logger.error("Token already tracked: {} - {}", token.getSessionId(), token.getMessageId());
             }
 
-            this.inFlightMsgIds.put(token, msgId);
-            this.store.published(msgId, token.getMessageId(), token.getSessionId());
+            DataServiceImpl.this.inFlightMsgIds.put(token, msgId);
+            DataServiceImpl.this.store.published(msgId, token.getMessageId(), token.getSessionId());
             logger.debug("Published message with ID: {} and MQTT message ID: {}", msgId, token.getMessageId());
         }
     }
@@ -741,25 +739,6 @@ private List<Integer> buildMessageIds(List<DataMessage> messages, String topicRe
         return ids;
     }
 
-    private void handleInFlightCongestion() {
-        int timeout = this.dataServiceOptions.getInFlightMessagesCongestionTimeout();
-
-        // Do not schedule more that one task at a time
-        if (timeout != 0 && (this.congestionFuture == null || this.congestionFuture.isDone())) {
-            logger.warn("In-flight message congestion timeout started");
-            this.congestionFuture = this.congestionExecutor.schedule(new Runnable() {
-
-                @Override
-                public void run() {
-                    Thread.currentThread().setName("DataServiceImpl:InFlightCongestion");
-                    logger.warn("In-flight message congestion timeout elapsed. Disconnecting and reconnecting again");
-                    disconnect();
-                    startConnectionMonitorTask();
-                }
-            }, timeout, TimeUnit.SECONDS);
-        }
-    }
-
     private void handleInFlightDecongestion() {
         if (this.congestionFuture != null && !this.congestionFuture.isDone()) {
             this.congestionFuture.cancel(true);
@@ -862,7 +841,7 @@ private void publishMessageUnbound(DataMessage message) throws KuraException {
             DataServiceImpl.this.dataServiceListeners.onMessagePublished(message.getId(), message.getTopic());
         }
 
-        private boolean publishMessageTokenBucket(DataMessage message) throws KuraException, InterruptedException {
+        private boolean publishMessageTokenBucket(DataMessage message) throws KuraException {
             boolean tokenAvailable = DataServiceImpl.this.throttle.getToken();
 
             if (tokenAvailable) {
@@ -871,6 +850,22 @@ private boolean publishMessageTokenBucket(DataMessage message) throws KuraExcept
             }
             return false;
         }
+
+        private void handleInFlightCongestion() {
+            int timeout = DataServiceImpl.this.dataServiceOptions.getInFlightMessagesCongestionTimeout();
+
+            // Do not schedule more that one task at a time
+            if (timeout != 0 && (DataServiceImpl.this.congestionFuture == null
+                    || DataServiceImpl.this.congestionFuture.isDone())) {
+                logger.warn("In-flight message congestion timeout started");
+                DataServiceImpl.this.congestionFuture = DataServiceImpl.this.congestionExecutor.schedule(() -> {
+                    Thread.currentThread().setName("DataServiceImpl:InFlightCongestion");
+                    logger.warn("In-flight message congestion timeout elapsed. Disconnecting and reconnecting again");
+                    disconnect();
+                    startConnectionMonitorTask();
+                }, timeout, TimeUnit.SECONDS);
+            }
+        }
     }
 
     @Override
diff --git a/kura/org.eclipse.kura.deployment.agent/src/main/java/org/eclipse/kura/deployment/agent/impl/DeploymentAgent.java b/kura/org.eclipse.kura.deployment.agent/src/main/java/org/eclipse/kura/deployment/agent/impl/DeploymentAgent.java
index 81968503a6..f79de13197 100644
--- a/kura/org.eclipse.kura.deployment.agent/src/main/java/org/eclipse/kura/deployment/agent/impl/DeploymentAgent.java
+++ b/kura/org.eclipse.kura.deployment.agent/src/main/java/org/eclipse/kura/deployment/agent/impl/DeploymentAgent.java
@@ -20,6 +20,7 @@
 import java.io.InputStream;
 import java.net.URL;
 import java.net.URLConnection;
+import java.nio.file.Files;
 import java.security.GeneralSecurityException;
 import java.util.HashMap;
 import java.util.Map;
@@ -146,19 +147,17 @@ protected void activate(ComponentContext componentContext) {
         if (dpaConfFile.getParentFile() != null && !dpaConfFile.getParentFile().exists()) {
             dpaConfFile.getParentFile().mkdirs();
         }
-        if (!dpaConfFile.exists()) {
-            try {
-                dpaConfFile.createNewFile();
-            } catch (IOException e) {
-                throw new ComponentException("Cannot create empty DPA configuration file", e);
+        try {
+            if (!dpaConfFile.createNewFile()) {
+                logger.debug("DPA configuration file already available");
             }
+        } catch (IOException e) {
+            throw new ComponentException("Cannot create empty DPA configuration file", e);
         }
 
         File packagesDir = new File(this.packagesPath);
-        if (!packagesDir.exists()) {
-            if (!packagesDir.mkdirs()) {
-                throw new ComponentException("Cannot create packages directory");
-            }
+        if (!packagesDir.exists() && !packagesDir.mkdirs()) {
+            throw new ComponentException("Cannot create packages directory");
         }
 
         this.instPackageUrls = new ConcurrentLinkedQueue<>();
@@ -277,18 +276,20 @@ public void uninstallDeploymentPackageAsync(String name) throws Exception {
 
     @Override
     public boolean isInstallingDeploymentPackage(String url) {
+        boolean result = false;
         if (this.instPackageUrls.contains(url)) {
-            return true;
+            result = true;
         }
-        return false;
+        return result;
     }
 
     @Override
     public boolean isUninstallingDeploymentPackage(String name) {
+        boolean result = false;
         if (this.uninstPackageNames.contains(name)) {
-            return true;
+            result = true;
         }
-        return false;
+        return result;
     }
 
     private void installer() {
@@ -303,31 +304,35 @@ private void installer() {
                 String url = this.instPackageUrls.peek();
                 if (url != null) {
                     logger.info("About to install package at URL {}", url);
-                    DeploymentPackage dp = null;
-                    Exception ex = null;
-                    try {
-                        dp = installDeploymentPackageInternal(url);
-                    } catch (Exception e) {
-                        ex = e;
-                        logger.error("Exception installing package at URL {}", url, e);
-                    } finally {
-                        boolean successful = dp != null ? true : false;
-                        logger.info("Posting INSTALLED event for package at URL {}: {}", url,
-                                successful ? "successful" : "unsuccessful");
-                        this.instPackageUrls.poll();
-                        postInstalledEvent(dp, url, successful, ex);
-                    }
+                    execInstall(url);
                 }
             } catch (InterruptedException e) {
                 logger.info("Exiting...");
                 Thread.currentThread().interrupt();
                 return;
-            } catch (Throwable t) {
-                logger.error("Unexpected throwable", t);
+            } catch (Exception e) {
+                logger.error("Unexpected exception", e);
             }
         } while (true);
     }
 
+    private void execInstall(String url) {
+        DeploymentPackage dp = null;
+        Exception ex = null;
+        try {
+            dp = installDeploymentPackageInternal(url);
+        } catch (Exception e) {
+            ex = e;
+            logger.error("Exception installing package at URL {}", url, e);
+        } finally {
+            boolean successful = dp != null;
+            logger.info("Posting INSTALLED event for package at URL {}: {}", url,
+                    successful ? "successful" : "unsuccessful");
+            this.instPackageUrls.poll();
+            postInstalledEvent(dp, url, successful, ex);
+        }
+    }
+
     private void uninstaller() {
         do {
             try {
@@ -339,33 +344,8 @@ private void uninstaller() {
 
                 String name = this.uninstPackageNames.peek();
                 if (name != null) {
-                    logger.info("About to uninstall package ", name);
-                    DeploymentPackage dp = null;
-                    boolean successful = false;
-                    Exception ex = null;
-                    try {
-                        dp = this.deploymentAdmin.getDeploymentPackage(name);
-                        if (dp != null) {
-                            dp.uninstall();
-
-                            Properties deployedPackages = readDeployedPackages();
-                            String sUrl = deployedPackages.getProperty(name);
-                            File dpFile = new File(new URL(sUrl).getPath());
-                            if (!dpFile.delete()) {
-                                logger.warn("Cannot delete file at URL: {}", sUrl);
-                            }
-                            successful = true;
-                            removePackageFromConfFile(name);
-                        }
-                    } catch (Exception e) {
-                        ex = e;
-                        logger.error("Exception uninstalling package {}", name, e);
-                    } finally {
-                        logger.info("Posting UNINSTALLED event for package {}: {}", name,
-                                successful ? "successful" : "unsuccessful");
-                        this.uninstPackageNames.poll();
-                        postUninstalledEvent(name, successful, ex);
-                    }
+                    logger.info("About to uninstall package {}", name);
+                    execUninstall(name);
                 }
             } catch (InterruptedException e) {
                 logger.info("Exiting...");
@@ -377,6 +357,35 @@ private void uninstaller() {
         } while (true);
     }
 
+    private void execUninstall(String name) {
+        DeploymentPackage dp = null;
+        boolean successful = false;
+        Exception ex = null;
+        try {
+            dp = this.deploymentAdmin.getDeploymentPackage(name);
+            if (dp != null) {
+                dp.uninstall();
+
+                Properties deployedPackages = readDeployedPackages();
+                String sUrl = deployedPackages.getProperty(name);
+                File dpFile = new File(new URL(sUrl).getPath());
+                if (!Files.deleteIfExists(dpFile.toPath())) {
+                    logger.warn("Cannot delete file at URL: {}", sUrl);
+                }
+                successful = true;
+                removePackageFromConfFile(name);
+            }
+        } catch (Exception e) {
+            ex = e;
+            logger.error("Exception uninstalling package {}", name, e);
+        } finally {
+            logger.info("Posting UNINSTALLED event for package {}: {}", name,
+                    successful ? "successful" : "unsuccessful");
+            this.uninstPackageNames.poll();
+            postUninstalledEvent(name, successful, ex);
+        }
+    }
+
     private void postInstalledEvent(DeploymentPackage dp, String url, boolean successful, Exception e) {
         Map<String, Object> props = new HashMap<>();
 
@@ -462,15 +471,12 @@ private DeploymentPackage installDeploymentPackageInternal(String urlSpec)
                 FileUtils.copyFile(dpFile, dpPersistentFile);
                 addPackageToConfFile(dp.getName(), "file:" + dpPersistentFilePath);
             }
-        } catch (DeploymentException e) {
-            throw e;
-        } catch (IOException e) {
-            throw e;
         } finally {
             // The file from which we have installed the deployment package will be deleted
             // unless it's a persistent deployment package file.
             if (!dpFile.getCanonicalPath().equals(dpPersistentFile.getCanonicalPath())) {
-                dpFile.delete();
+                Files.delete(dpFile.toPath());
+                logger.debug("Deleted file: {}", dpFile.getName());
             }
         }
 
diff --git a/kura/org.eclipse.kura.net.admin/src/main/java/org/eclipse/kura/net/admin/modem/sierra/Hip.java b/kura/org.eclipse.kura.net.admin/src/main/java/org/eclipse/kura/net/admin/modem/sierra/Hip.java
index e70faee7fa..31c6da2491 100644
--- a/kura/org.eclipse.kura.net.admin/src/main/java/org/eclipse/kura/net/admin/modem/sierra/Hip.java
+++ b/kura/org.eclipse.kura.net.admin/src/main/java/org/eclipse/kura/net/admin/modem/sierra/Hip.java
@@ -99,7 +99,7 @@ public class Hip {
     private static final int PAYLOAD_OFFSET = 4;
 
     private int payloadlength = 0;
-    private byte message_id = 0;
+    private byte messageId = 0;
     private byte parameter = 0;
 
     private byte[] hipmsg = null;
@@ -115,7 +115,7 @@ public class Hip {
      */
     public Hip(byte[] payload) {
 
-        this.message_id = MSGID_CNS_HOST2MODEM;
+        this.messageId = MSGID_CNS_HOST2MODEM;
         this.payloadlength = payload.length;
 
         List<Byte> alMsg = new ArrayList<>();
@@ -123,7 +123,7 @@ public Hip(byte[] payload) {
         // form HIP message
         alMsg.add(Byte.valueOf((byte) (this.payloadlength >> 8 & 0xff)));
         alMsg.add(Byte.valueOf((byte) (this.payloadlength & 0xff)));
-        alMsg.add(Byte.valueOf(this.message_id));
+        alMsg.add(Byte.valueOf(this.messageId));
         alMsg.add(Byte.valueOf(this.parameter));
         for (int i = 0; i < this.payloadlength; i++) {
             alMsg.add(Byte.valueOf(payload[i]));
@@ -188,7 +188,7 @@ public Hip(List<Byte> alMsg) {
 
             this.payloadlength = alMsg.get(0).byteValue() << 8 & 0x0ffff | alMsg.get(1).byteValue() & 0x0ff;
 
-            this.message_id = alMsg.get(MESSAGE_ID_OFFSET).byteValue();
+            this.messageId = alMsg.get(MESSAGE_ID_OFFSET).byteValue();
             this.parameter = alMsg.get(PARAMETER_OFFSET).byteValue();
 
             // get HIP payload
@@ -199,7 +199,6 @@ public Hip(List<Byte> alMsg) {
             }
         } catch (Exception e) {
             this.is_error = true;
-            e.printStackTrace();
         }
     }
 
@@ -227,7 +226,7 @@ public byte[] getPayload() {
      * @return Message ID
      */
     public byte getMessageID() {
-        return this.message_id;
+        return this.messageId;
     }
 
     /**
diff --git a/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/server/GwtSecurityTokenServiceImpl.java b/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/server/GwtSecurityTokenServiceImpl.java
index b2458c503d..317f3265d1 100644
--- a/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/server/GwtSecurityTokenServiceImpl.java
+++ b/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/server/GwtSecurityTokenServiceImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2011, 2016 Eurotech and/or its affiliates
+ * Copyright (c) 2011, 2018 Eurotech and/or its affiliates
  *
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
@@ -33,23 +33,24 @@ public class GwtSecurityTokenServiceImpl extends OsgiRemoteServiceServlet implem
      */
     private static final long serialVersionUID = 5333012054583792499L;
 
-    private static ThreadLocal<HttpServletRequest> perThreadRequest = new ThreadLocal<HttpServletRequest>();
+    private static ThreadLocal<HttpServletRequest> threadRequest = new ThreadLocal<>();
 
-    public static Logger s_logger = LoggerFactory.getLogger(GwtSecurityTokenServiceImpl.class);
-    public static final String XSRF_TOKEN_KEY = "XSRF_TOKEN";
+    private static Logger logger = LoggerFactory.getLogger(GwtSecurityTokenServiceImpl.class);
+
+    static final String XSRF_TOKEN_KEY = "XSRF_TOKEN";
 
     @Override
     public String processCall(String payload) throws SerializationException {
         try {
-            perThreadRequest.set(getThreadLocalRequest());
+            threadRequest.set(getThreadLocalRequest());
             return super.processCall(payload);
         } finally {
-            perThreadRequest.set(null);
+            threadRequest.set(null);
         }
     }
 
     public static HttpServletRequest getRequest() {
-        return perThreadRequest.get();
+        return threadRequest.get();
     }
 
     public HttpSession getHttpSession() {
@@ -67,7 +68,7 @@ public GwtXSRFToken generateSecurityToken() {
             token = new GwtXSRFToken(UUID.randomUUID().toString());
             session.setAttribute(XSRF_TOKEN_KEY, token);
 
-            s_logger.debug("Generated XSRF token: {} for HTTP session: {}", token.getToken(), session.getId());
+            logger.debug("Generated XSRF token: {} for HTTP session: {}", token.getToken(), session.getId());
         }
         return token;
     }
diff --git a/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/shared/model/GwtNetIfStatusModel.java b/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/shared/model/GwtNetIfStatusModel.java
index 45671edacd..c99cb0c367 100644
--- a/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/shared/model/GwtNetIfStatusModel.java
+++ b/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/shared/model/GwtNetIfStatusModel.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2011, 2016 Eurotech and/or its affiliates
+ * Copyright (c) 2011, 2018 Eurotech and/or its affiliates
  *
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
@@ -12,10 +12,14 @@
 package org.eclipse.kura.web.shared.model;
 
 import org.eclipse.kura.web.client.util.KuraBaseModel;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 public class GwtNetIfStatusModel extends KuraBaseModel {
 
     private static final long serialVersionUID = 2779596516813518500L;
+    
+    private static final Logger logger = Logger.getLogger(GwtNetIfStatusModel.class.getSimpleName());
 
     public static final String NAME = "name";
     public static final String STATUS = "status";
@@ -42,7 +46,7 @@ public GwtNetIfStatus getStatus() {
         try {
             status = GwtNetIfStatus.valueOf(statusStr);
         } catch (Exception e) {
-            e.printStackTrace();
+            logger.log(Level.WARNING, "Error getting status.", e);
         }
 
         return status;
diff --git a/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/shared/model/GwtNetInterfaceConfig.java b/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/shared/model/GwtNetInterfaceConfig.java
index 287dc40207..484d2827a2 100644
--- a/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/shared/model/GwtNetInterfaceConfig.java
+++ b/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/shared/model/GwtNetInterfaceConfig.java
@@ -13,13 +13,15 @@
 
 import java.io.Serializable;
 import java.util.Map;
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import java.util.Map.Entry;
 
 import org.eclipse.kura.web.client.util.KuraBaseModel;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 public class GwtNetInterfaceConfig extends KuraBaseModel implements Serializable {
 
+    private static final String ROUTER_DNS_PASS = "routerDnsPass";
     private static final Logger logger = Logger.getLogger(GwtNetInterfaceConfig.class.getSimpleName());
     private static final long serialVersionUID = 7079533925979145804L;
 
@@ -123,7 +125,7 @@ public GwtNetIfType getHwTypeEnum() {
         try {
             typeEnum = GwtNetIfType.valueOf(getHwType());
         } catch (Exception e) {
-            e.printStackTrace();
+            logger.log(Level.WARNING, "Error getting HwType.", e);
         }
 
         return typeEnum;
@@ -264,14 +266,14 @@ public void setRouterDhcpSubnetMask(String routerDhcpSubnetMask) {
     }
 
     public boolean getRouterDnsPass() {
-        if (get("routerDnsPass") != null) {
-            return (Boolean) get("routerDnsPass");
+        if (get(ROUTER_DNS_PASS) != null) {
+            return (Boolean) get(ROUTER_DNS_PASS);
         }
         return false;
     }
 
     public void setRouterDnsPass(boolean routerDnsPass) {
-        set("routerDnsPass", routerDnsPass);
+        set(ROUTER_DNS_PASS, routerDnsPass);
     }
 
     @Override
@@ -291,16 +293,13 @@ public boolean equals(Object o) {
                 logger.log(Level.FINER, "Sizes differ");
                 return false;
             }
-            ;
-
-            Object oldVal, newVal;
-            for (String key : properties.keySet()) {
-                oldVal = properties.get(key);
-                newVal = otherProps.get(key);
+            
+            for (Entry<String, Object> entry : properties.entrySet()) {
+                final Object oldVal = entry.getValue();
+                final Object newVal = otherProps.get(entry.getKey());
                 if (oldVal != null) {
                     if (!oldVal.equals(newVal)) {
-                        logger.log(Level.FINER,
-                                "Values differ - Key: " + key + " oldVal: " + oldVal + ", newVal: " + newVal);
+                        logger.log(Level.FINER, () -> "Values differ - Key: " + entry.getKey() + " oldVal: " + oldVal + ", newVal: " + newVal);
                         return false;
                     }
                 } else if (newVal != null) {
diff --git a/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/shared/model/GwtWifiHotspotEntry.java b/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/shared/model/GwtWifiHotspotEntry.java
index 9581dea4bd..753bebc8f8 100644
--- a/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/shared/model/GwtWifiHotspotEntry.java
+++ b/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/shared/model/GwtWifiHotspotEntry.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2011, 2016 Eurotech and/or its affiliates
+ * Copyright (c) 2011, 2018 Eurotech and/or its affiliates
  *
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
@@ -14,9 +14,16 @@
 import java.io.Serializable;
 
 import org.eclipse.kura.web.client.util.KuraBaseModel;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 public class GwtWifiHotspotEntry extends KuraBaseModel implements Serializable {
 
+    private static final Logger logger = Logger.getLogger(GwtWifiHotspotEntry.class.getSimpleName());
+    
+    private static final String FREQUENCY = "frequency";
+    private static final String CHANNEL = "channel";
+    private static final String SIGNAL_STRENGTH = "signalStrength";
     private static final long serialVersionUID = -7818472380334612955L;
 
     public String getSSID() {
@@ -36,39 +43,39 @@ public void setMacAddress(String macAddress) {
     }
 
     public Integer getSignalStrength() {
-        if (get("signalStrength") != null) {
-            return (Integer) get("signalStrength");
+        if (get(SIGNAL_STRENGTH) != null) {
+            return get(SIGNAL_STRENGTH);
         } else {
             return 0;
         }
     }
 
     public void setsignalStrength(int signalStrength) {
-        set("signalStrength", signalStrength);
+        set(SIGNAL_STRENGTH, signalStrength);
     }
 
     public Integer getChannel() {
-        if (get("channel") != null) {
-            return (Integer) get("channel");
+        if (get(CHANNEL) != null) {
+            return get(CHANNEL);
         } else {
             return 0;
         }
     }
 
     public void setChannel(int channel) {
-        set("channel", channel);
+        set(CHANNEL, channel);
     }
 
     public Integer getFrequency() {
-        if (get("frequency") != null) {
-            return (Integer) get("frequency");
+        if (get(FREQUENCY) != null) {
+            return get(FREQUENCY);
         } else {
             return 0;
         }
     }
 
     public void setFrequency(int frequency) {
-        set("frequency", frequency);
+        set(FREQUENCY, frequency);
     }
 
     public String getSecurity() {
@@ -84,7 +91,7 @@ public GwtWifiCiphers getPairwiseCiphersEnum() {
         try {
             ciphers = GwtWifiCiphers.valueOf(getPairwiseCiphers());
         } catch (Exception e) {
-            e.printStackTrace();
+            logger.log(Level.WARNING, "Error getting pairwise ciphers.", e);
         }
         return ciphers;
     }
@@ -102,7 +109,7 @@ public GwtWifiCiphers getGroupCiphersEnum() {
         try {
             ciphers = GwtWifiCiphers.valueOf(getGroupCiphers());
         } catch (Exception e) {
-            e.printStackTrace();
+            logger.log(Level.WARNING, "Error getting group ciphers.", e);
         }
         return ciphers;
     }
diff --git a/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/shared/model/GwtWifiWirelessModeModel.java b/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/shared/model/GwtWifiWirelessModeModel.java
index cc39801a6b..1cea987116 100644
--- a/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/shared/model/GwtWifiWirelessModeModel.java
+++ b/kura/org.eclipse.kura.web2/src/main/java/org/eclipse/kura/web/shared/model/GwtWifiWirelessModeModel.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2011, 2016 Eurotech and/or its affiliates
+ * Copyright (c) 2011, 2018 Eurotech and/or its affiliates
  *
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
@@ -12,8 +12,12 @@
 package org.eclipse.kura.web.shared.model;
 
 import org.eclipse.kura.web.client.util.KuraBaseModel;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 public class GwtWifiWirelessModeModel extends KuraBaseModel {
+    
+    private static final Logger logger = Logger.getLogger(GwtWifiWirelessModeModel.class.getSimpleName());
 
     private static final long serialVersionUID = -6095963356000494663L;
 
@@ -42,7 +46,7 @@ public GwtWifiWirelessMode getMode() {
         try {
             mode = GwtWifiWirelessMode.valueOf(modeStr);
         } catch (Exception e) {
-            e.printStackTrace();
+            logger.log(Level.WARNING, "Error getting Wifi Wireless Mode.", e);
         }
 
         return mode;
diff --git a/kura/test/org.eclipse.kura.core.test/src/main/java/org/eclipse/kura/core/test/DataServiceTest.java b/kura/test/org.eclipse.kura.core.test/src/main/java/org/eclipse/kura/core/test/DataServiceTest.java
index 657d1fd0ea..1b07428d8d 100644
--- a/kura/test/org.eclipse.kura.core.test/src/main/java/org/eclipse/kura/core/test/DataServiceTest.java
+++ b/kura/test/org.eclipse.kura.core.test/src/main/java/org/eclipse/kura/core/test/DataServiceTest.java
@@ -33,10 +33,14 @@
 import org.eclipse.kura.test.annotation.TestTarget;
 import org.junit.BeforeClass;
 import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 @SuppressWarnings("deprecation")
 public class DataServiceTest implements DataServiceListener {
 
+    private static final Logger s_logger = LoggerFactory.getLogger(DataServiceTest.class);
+    
     private static CountDownLatch s_dependencyLatch = new CountDownLatch(1);	// initialize with number of
     // dependencies
     private static DataService s_dataService;
@@ -173,6 +177,7 @@ public void testPublish() throws KuraConnectException, InterruptedException {
                 synchronized (s_qos12MsgIds) {
                     Integer id = s_dataService.publish(MSG_TOPIC1, MSG_PAYLOAD.getBytes(), 1, false, DFLT_MSG_PRIORITY);
                     s_qos12MsgIds.add(id);
+                    s_logger.info("Added id: {}", id);
                 }
             } catch (KuraStoreException e) {
                 break;
@@ -182,6 +187,8 @@ public void testPublish() throws KuraConnectException, InterruptedException {
         boolean allConfirmed = false;
         for (int i = 0; i < ALL_CONFIRMED_QOS1_TIMEOUT; i++) {
             synchronized (s_qos12MsgIds) {
+                s_logger.info("confirm check round {}", i);
+                s_qos12MsgIds.forEach(element -> s_logger.info("To confirm: {}", element));
                 if (s_qos12MsgIds.isEmpty()) {
                     allConfirmed = true;
                     break;
@@ -190,6 +197,7 @@ public void testPublish() throws KuraConnectException, InterruptedException {
             Thread.sleep(1000);
         }
 
+        s_logger.info("All confirmed value: {}", allConfirmed);
         assertTrue(allConfirmed);
 
         // publish at QoS = 2
@@ -234,6 +242,7 @@ public void testPublish() throws KuraConnectException, InterruptedException {
                 synchronized (s_qos12MsgIds) {
                     Integer id = s_dataService.publish(MSG_TOPIC1, MSG_PAYLOAD.getBytes(), 1, false, DFLT_MSG_PRIORITY);
                     s_qos12MsgIds.add(id);
+                    s_logger.info("Added id: {}", id);
                 }
             } catch (KuraStoreException e) {
                 break;
@@ -262,6 +271,9 @@ public void testPublish() throws KuraConnectException, InterruptedException {
         for (int i = 0; i < ALL_CONFIRMED_QOS1_TIMEOUT; i++) {
             synchronized (s_qos12MsgIds) {
                 synchronized (s_qos12HighPriorityMsgIds) {
+                    s_logger.info("confirm check round {}", i);
+                    s_qos12HighPriorityMsgIds.forEach(element -> s_logger.info("To confirm s_qos12HighPriorityMsgIds: {}", element));
+                    s_qos12MsgIds.forEach(element -> s_logger.info("To confirm s_qos12MsgIds: {}", element));
                     if (!s_qos12HighPriorityMsgIds.isEmpty() && s_qos12MsgIds.isEmpty()) {
                         fail("High priority messages should be confirmed before default priority messages");
                     } else if (s_qos12HighPriorityMsgIds.isEmpty() && s_qos12MsgIds.isEmpty()) {
@@ -273,6 +285,7 @@ public void testPublish() throws KuraConnectException, InterruptedException {
             Thread.sleep(1000);
         }
 
+        s_logger.info("All confirmed value: {}", allConfirmed);
         assertTrue(allConfirmed);
     }
 
diff --git a/kura/test/org.eclipse.kura.core.test/src/test/java/org/eclipse/kura/core/data/DataServiceImplTest.java b/kura/test/org.eclipse.kura.core.test/src/test/java/org/eclipse/kura/core/data/DataServiceImplTest.java
index 4fd4108568..a783909eb8 100644
--- a/kura/test/org.eclipse.kura.core.test/src/test/java/org/eclipse/kura/core/data/DataServiceImplTest.java
+++ b/kura/test/org.eclipse.kura.core.test/src/test/java/org/eclipse/kura/core/data/DataServiceImplTest.java
@@ -648,25 +648,4 @@ private DataStore expectAllMessages(DataServiceImpl svc, List<DataMessage> unpub
 
         return storeMock;
     }
-
-    @Test
-    public void testCongestion() throws Throwable {
-        // run handleInFlightCongestion
-
-        DataServiceImpl svc = new DataServiceImpl();
-
-        Map<String, Object> properties = new HashMap<>();
-        properties.put("in-flight-messages.congestion-timeout", 100);
-        DataServiceOptions dataServiceOptions = new DataServiceOptions(properties);
-
-        TestUtil.setFieldValue(svc, "dataServiceOptions", dataServiceOptions);
-
-        ScheduledExecutorService congestionMock = mock(ScheduledExecutorService.class);
-        TestUtil.setFieldValue(svc, "congestionExecutor", congestionMock);
-
-        TestUtil.invokePrivate(svc, "handleInFlightCongestion");
-
-        verify(congestionMock, times(1)).schedule((Runnable) anyObject(), eq(100L), eq(TimeUnit.SECONDS));
-    }
-
 }
