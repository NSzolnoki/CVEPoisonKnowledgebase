diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/DataFormat.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/DataFormat.java
new file mode 100644
index 000000000000..a2299192b0fc
--- /dev/null
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/DataFormat.java
@@ -0,0 +1,157 @@
+package org.infinispan.client.hotrod;
+
+import static org.infinispan.client.hotrod.marshall.MarshallerUtil.bytes2obj;
+import static org.infinispan.client.hotrod.marshall.MarshallerUtil.obj2bytes;
+
+import java.util.List;
+
+import org.infinispan.client.hotrod.impl.MarshallerRegistry;
+import org.infinispan.client.hotrod.logging.Log;
+import org.infinispan.client.hotrod.logging.LogFactory;
+import org.infinispan.commons.dataconversion.MediaType;
+import org.infinispan.commons.marshall.IdentityMarshaller;
+import org.infinispan.commons.marshall.Marshaller;
+
+/**
+ * Defines data format for keys and values during Hot Rod client requests.
+ *
+ * @since 9.3
+ */
+public final class DataFormat {
+
+   private static final Log log = LogFactory.getLog(DataFormat.class, Log.class);
+
+   private final MediaType keyType;
+   private final MediaType valueType;
+   private final Marshaller keyMarshaller;
+   private final Marshaller valueMarshaller;
+
+   private MarshallerRegistry marshallerRegistry;
+   private Marshaller defaultMarshaller;
+
+   private DataFormat(MediaType keyType, MediaType valueType, Marshaller keyMarshaller, Marshaller valueMarshaller) {
+      this.keyType = keyType;
+      this.valueType = valueType;
+      this.keyMarshaller = keyMarshaller;
+      this.valueMarshaller = valueMarshaller;
+   }
+
+   public DataFormat withoutValueType() {
+      return new DataFormat(keyType, null, keyMarshaller, null);
+   }
+
+   public MediaType getKeyType() {
+      return keyType;
+   }
+
+   public MediaType getValueType() {
+      return valueType;
+   }
+
+   public void initialize(RemoteCacheManager remoteCacheManager) {
+      this.marshallerRegistry = remoteCacheManager.getMarshallerRegistry();
+      this.defaultMarshaller = remoteCacheManager.getMarshaller();
+   }
+
+   private Marshaller resolveValueMarshaller() {
+      if (valueMarshaller != null) return valueMarshaller;
+      if (valueType == null) return defaultMarshaller;
+
+      Marshaller forValueType = marshallerRegistry.getMarshaller(valueType);
+      if (forValueType != null) return forValueType;
+      log.debugf("No marshaller registered for %s, using no-op marshaller", valueType);
+
+      return IdentityMarshaller.INSTANCE;
+   }
+
+   private Marshaller resolveKeyMarshaller() {
+      if (keyMarshaller != null) return keyMarshaller;
+      if (keyType == null) return defaultMarshaller;
+
+      Marshaller forKeyType = marshallerRegistry.getMarshaller(keyType);
+      if (forKeyType != null) return forKeyType;
+      log.debugf("No marshaller registered for %s, using no-op marshaller", keyType);
+
+      return IdentityMarshaller.INSTANCE;
+   }
+
+   public boolean hasCustomFormat() {
+      return keyType != null || valueType != null;
+   }
+
+   public byte[] keyToBytes(Object key, int estimateKeySize, int estimateValueSize) {
+      Marshaller keyMarshaller = resolveKeyMarshaller();
+      return obj2bytes(keyMarshaller, key, true, estimateKeySize, estimateValueSize);
+   }
+
+   public byte[] valueToBytes(Object value, int estimateKeySize, int estimateValueSize) {
+      Marshaller valueMarshaller = resolveValueMarshaller();
+      return obj2bytes(valueMarshaller, value, false, estimateKeySize, estimateValueSize);
+   }
+
+   public <T> T keyToObj(byte[] bytes, short status, List<String> whitelist) {
+      Marshaller keyMarshaller = resolveKeyMarshaller();
+      return bytes2obj(keyMarshaller, bytes, status, whitelist);
+   }
+
+   public <T> T valueToObj(byte[] bytes, short status, List<String> whitelist) {
+      Marshaller valueMarshaller = resolveValueMarshaller();
+      return bytes2obj(valueMarshaller, bytes, status, whitelist);
+   }
+
+   @Override
+   public String toString() {
+      return "DataFormat{" +
+            "keyType=" + keyType +
+            ", valueType=" + valueType +
+            ", keyMarshaller=" + keyMarshaller +
+            ", valueMarshaller=" + valueMarshaller +
+            ", marshallerRegistry=" + marshallerRegistry +
+            ", defaultMarshaller=" + defaultMarshaller +
+            '}';
+   }
+
+   public static Builder builder() {
+      return new Builder();
+   }
+
+   public static class Builder {
+      private MediaType keyType;
+      private MediaType valueType;
+      private Marshaller valueMarshaller;
+      private Marshaller keyMarshaller;
+
+      public Builder from(DataFormat dataFormat) {
+         this.keyType = dataFormat.keyType;
+         this.valueType = dataFormat.valueType;
+         this.keyMarshaller = dataFormat.keyMarshaller;
+         this.valueMarshaller = dataFormat.valueMarshaller;
+         return this;
+      }
+
+      public Builder valueMarshaller(Marshaller valueMarshaller) {
+         this.valueMarshaller = valueMarshaller;
+         return this;
+      }
+
+      public Builder keyMarshaller(Marshaller keyMarshaller) {
+         this.keyMarshaller = keyMarshaller;
+         return this;
+      }
+
+      public Builder keyType(MediaType keyType) {
+         this.keyType = keyType;
+         return this;
+      }
+
+      public Builder valueType(MediaType valueType) {
+         this.valueType = valueType;
+         return this;
+      }
+
+      public DataFormat build() {
+         return new DataFormat(keyType, valueType, keyMarshaller, valueMarshaller);
+      }
+
+   }
+}
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCache.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCache.java
index 89623c1c2766..71097f1a59a9 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCache.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCache.java
@@ -458,4 +458,14 @@ public interface RemoteCache<K, V> extends BasicCache<K, V> {
     * Returns a cache where values are manipulated using {@link java.io.InputStream} and {@link java.io.OutputStream}
     */
    StreamingRemoteCache<K> streaming();
+
+   /**
+    * Return a new instance of {@link RemoteCache} using the supplied {@link DataFormat}.
+    */
+   <T, U> RemoteCache<T, U> withDataFormat(DataFormat dataFormat);
+
+   /**
+    * Return the currently {@link DataFormat} being used.
+    */
+   DataFormat getDataFormat();
 }
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCacheManager.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCacheManager.java
index fbaab513e3be..3d7559392483 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCacheManager.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCacheManager.java
@@ -25,6 +25,7 @@
 import org.infinispan.client.hotrod.event.impl.ClientListenerNotifier;
 import org.infinispan.client.hotrod.exceptions.HotRodClientException;
 import org.infinispan.client.hotrod.impl.InvalidatedNearRemoteCache;
+import org.infinispan.client.hotrod.impl.MarshallerRegistry;
 import org.infinispan.client.hotrod.impl.RemoteCacheImpl;
 import org.infinispan.client.hotrod.impl.RemoteCacheManagerAdminImpl;
 import org.infinispan.client.hotrod.impl.operations.OperationsFactory;
@@ -39,6 +40,7 @@
 import org.infinispan.commons.api.CacheContainerAdmin;
 import org.infinispan.commons.executors.ExecutorFactory;
 import org.infinispan.commons.marshall.Marshaller;
+import org.infinispan.commons.marshall.UTF8StringMarshaller;
 import org.infinispan.commons.marshall.jboss.GenericJBossMarshaller;
 import org.infinispan.commons.util.FileLookupFactory;
 import org.infinispan.commons.util.Util;
@@ -72,6 +74,7 @@ public class RemoteCacheManager implements RemoteCacheContainer, Closeable {
 
    private volatile boolean started = false;
    private final Map<RemoteCacheKey, RemoteCacheHolder> cacheName2RemoteCache = new HashMap<>();
+   private final MarshallerRegistry marshallerRegistry = new MarshallerRegistry();
    private final AtomicInteger defaultCacheTopologyId = new AtomicInteger(HotRodConstants.DEFAULT_CACHE_TOPOLOGY);
    private Configuration configuration;
    private Codec codec;
@@ -225,6 +228,8 @@ public void start() {
                marshaller = Util.getInstance(clazz);
          }
       }
+      marshallerRegistry.registerMarshaller(marshaller);
+      marshallerRegistry.registerMarshaller(new UTF8StringMarshaller());
 
       codec = CodecFactory.getCodec(configuration.version());
 
@@ -235,7 +240,7 @@ public void start() {
       }
       ExecutorService asyncExecutorService = executorFactory.getExecutor(configuration.asyncExecutorFactory().properties());
       channelFactory.start(codec, configuration, defaultCacheTopologyId, marshaller, asyncExecutorService,
-            listenerNotifier, Collections.singletonList(listenerNotifier::failoverListeners));
+            listenerNotifier, Collections.singletonList(listenerNotifier::failoverListeners), marshallerRegistry);
       counterManager.start(channelFactory, codec, configuration, listenerNotifier);
 
       synchronized (cacheName2RemoteCache) {
@@ -261,6 +266,10 @@ private final void warnAboutUberJarDuplicates() {
             });
    }
 
+   public MarshallerRegistry getMarshallerRegistry() {
+      return marshallerRegistry;
+   }
+
    /**
     * Stop the remote cache manager, disconnecting all existing connections.
     * As part of the disconnection, all registered client cache listeners will
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/counter/operation/BaseCounterOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/counter/operation/BaseCounterOperation.java
index 8341c802068d..85a357b7f1a9 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/counter/operation/BaseCounterOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/counter/operation/BaseCounterOperation.java
@@ -35,7 +35,7 @@ abstract class BaseCounterOperation<T> extends RetryOnFailureOperation<T> {
 
    BaseCounterOperation(short requestCode, short responseCode, Codec codec, ChannelFactory channelFactory, AtomicInteger topologyId, Configuration cfg,
                         String counterName) {
-      super(requestCode, responseCode, codec, channelFactory, EMPTY_CACHE_NAME, topologyId, 0, cfg);
+      super(requestCode, responseCode, codec, channelFactory, EMPTY_CACHE_NAME, topologyId, 0, cfg, null);
       this.counterName = counterName;
    }
 
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/event/impl/ClientEventDispatcher.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/event/impl/ClientEventDispatcher.java
index 468922b9b094..692245c2c85c 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/event/impl/ClientEventDispatcher.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/event/impl/ClientEventDispatcher.java
@@ -10,6 +10,7 @@
 import java.util.Map;
 import java.util.concurrent.CompletableFuture;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.annotation.ClientCacheEntryCreated;
 import org.infinispan.client.hotrod.annotation.ClientCacheEntryExpired;
 import org.infinispan.client.hotrod.annotation.ClientCacheEntryModified;
@@ -131,6 +132,10 @@ protected void invokeFailoverEvent() {
       }
    }
 
+   protected DataFormat getDataFormat() {
+      return op.getDataFormat();
+   }
+
    static final class ClientListenerInvocation {
       private static final Log log = LogFactory.getLog(ClientListenerInvocation.class, Log.class);
 
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/event/impl/ClientListenerNotifier.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/event/impl/ClientListenerNotifier.java
index 94aa9265e15d..cfa815c22540 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/event/impl/ClientListenerNotifier.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/event/impl/ClientListenerNotifier.java
@@ -13,6 +13,7 @@
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
 import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;
 import org.infinispan.client.hotrod.logging.Log;
@@ -176,6 +177,14 @@ public <T> void invokeEvent(byte[] listenerId, T event) {
       eventDispatcher.invokeEvent(event);
    }
 
+   public DataFormat getCacheDataFormat(byte[] listenerId) {
+      ClientEventDispatcher clientEventDispatcher = (ClientEventDispatcher) dispatchers.get(new WrappedByteArray(listenerId));
+      if (clientEventDispatcher == null) {
+         throw log.unexpectedListenerId(Util.printArray(listenerId));
+      }
+      return clientEventDispatcher.getDataFormat();
+   }
+
    public Codec codec() {
       return codec;
    }
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/MarshallerRegistry.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/MarshallerRegistry.java
new file mode 100644
index 000000000000..b12a45cffbbf
--- /dev/null
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/MarshallerRegistry.java
@@ -0,0 +1,30 @@
+package org.infinispan.client.hotrod.impl;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.infinispan.client.hotrod.logging.Log;
+import org.infinispan.client.hotrod.logging.LogFactory;
+import org.infinispan.commons.dataconversion.MediaType;
+import org.infinispan.commons.marshall.Marshaller;
+
+/**
+ * A registry of {@link Marshaller} along with its {@link MediaType}.
+ *
+ * @since 9.3
+ */
+public final class MarshallerRegistry {
+
+   public static final Log log = LogFactory.getLog(MarshallerRegistry.class, Log.class);
+
+   private final Map<MediaType, Marshaller> marshallerByMediaType = new ConcurrentHashMap<>();
+
+   public void registerMarshaller(Marshaller marshaller) {
+      marshallerByMediaType.put(marshaller.mediaType().withoutParameters(), marshaller);
+   }
+
+   public Marshaller getMarshaller(MediaType mediaType) {
+      return marshallerByMediaType.get(mediaType);
+   }
+
+}
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/RemoteCacheImpl.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/RemoteCacheImpl.java
index 9740c57eec9c..03904442e22d 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/RemoteCacheImpl.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/RemoteCacheImpl.java
@@ -13,12 +13,12 @@
 import java.util.Objects;
 import java.util.Set;
 import java.util.Spliterator;
-import java.util.concurrent.Callable;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.TimeUnit;
 import java.util.stream.Stream;
 
 import org.infinispan.client.hotrod.CacheTopologyInfo;
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.Flag;
 import org.infinispan.client.hotrod.MetadataValue;
 import org.infinispan.client.hotrod.ProtocolVersion;
@@ -54,7 +54,6 @@
 import org.infinispan.client.hotrod.impl.operations.StatsOperation;
 import org.infinispan.client.hotrod.logging.Log;
 import org.infinispan.client.hotrod.logging.LogFactory;
-import org.infinispan.client.hotrod.marshall.MarshallerUtil;
 import org.infinispan.commons.marshall.Marshaller;
 import org.infinispan.commons.util.CloseableIterator;
 import org.infinispan.commons.util.CloseableIteratorCollection;
@@ -74,7 +73,7 @@ public class RemoteCacheImpl<K, V> extends RemoteCacheSupport<K, V> {
    private static final Log log = LogFactory.getLog(RemoteCacheImpl.class, Log.class);
    private static final boolean trace = log.isTraceEnabled();
 
-   private Marshaller marshaller;
+   private Marshaller defaultMarshaller;
    private final String name;
    private final RemoteCacheManager remoteCacheManager;
    protected OperationsFactory operationsFactory;
@@ -82,6 +81,8 @@ public class RemoteCacheImpl<K, V> extends RemoteCacheSupport<K, V> {
    private int estimateValueSize;
    private int batchSize;
    private volatile boolean hasCompatibility;
+   private final DataFormat defaultDataFormat;
+   private DataFormat dataFormat;
 
    public RemoteCacheImpl(RemoteCacheManager rcm, String name) {
       if (trace) {
@@ -89,15 +90,18 @@ public RemoteCacheImpl(RemoteCacheManager rcm, String name) {
       }
       this.name = name;
       this.remoteCacheManager = rcm;
+      this.defaultDataFormat = DataFormat.builder().build();
+      this.defaultDataFormat.initialize(remoteCacheManager);
    }
 
    public void init(Marshaller marshaller, OperationsFactory operationsFactory,
                     int estimateKeySize, int estimateValueSize, int batchSize) {
-      this.marshaller = marshaller;
+      this.defaultMarshaller = marshaller;
       this.operationsFactory = operationsFactory;
       this.estimateKeySize = estimateKeySize;
       this.estimateValueSize = estimateValueSize;
       this.batchSize = batchSize;
+      this.dataFormat = defaultDataFormat;
    }
 
    public OperationsFactory getOperationsFactory() {
@@ -118,7 +122,7 @@ public boolean removeWithVersion(K key, long version) {
    public CompletableFuture<Boolean> removeWithVersionAsync(final K key, final long version) {
       assertRemoteCacheManagerIsStarted();
       RemoveIfUnmodifiedOperation<V> op = operationsFactory.newRemoveIfUnmodifiedOperation(
-            compatKeyIfNeeded(key), obj2bytes(key, true), version);
+            compatKeyIfNeeded(key), keyToBytes(key), version, dataFormat);
       return op.execute().thenApply(response -> response.getCode().isUpdated());
    }
 
@@ -140,7 +144,7 @@ public CompletableFuture<Boolean> replaceWithVersionAsync(K key, V newValue, lon
    public CompletableFuture<Boolean> replaceWithVersionAsync(K key, V newValue, long version, long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit) {
       assertRemoteCacheManagerIsStarted();
       ReplaceIfUnmodifiedOperation op = operationsFactory.newReplaceIfUnmodifiedOperation(
-            compatKeyIfNeeded(key), obj2bytes(key, true), obj2bytes(newValue, false), lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit, version);
+            compatKeyIfNeeded(key), keyToBytes(key), valueToBytes(newValue), lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit, version, dataFormat);
       return op.execute().thenApply(response -> response.getCode().isUpdated());
    }
 
@@ -152,7 +156,7 @@ public CloseableIterator<Entry<Object, Object>> retrieveEntries(String filterCon
       }
       byte[][] params = marshallParams(filterConverterParams);
       RemoteCloseableIterator remoteCloseableIterator = new RemoteCloseableIterator(operationsFactory,
-            marshaller, filterConverterFactory, params, segments, batchSize, false);
+            defaultMarshaller, filterConverterFactory, params, segments, batchSize, false, dataFormat);
       remoteCloseableIterator.start();
       return remoteCloseableIterator;
    }
@@ -175,7 +179,7 @@ public CloseableIterator<Entry<Object, Object>> retrieveEntriesByQuery(Query fil
 
    @Override
    public CloseableIterator<Entry<Object, MetadataValue<Object>>> retrieveEntriesWithMetadata(Set<Integer> segments, int batchSize) {
-      RemoteCloseableIterator remoteCloseableIterator = new RemoteCloseableIterator(operationsFactory, marshaller, batchSize, segments, true);
+      RemoteCloseableIterator remoteCloseableIterator = new RemoteCloseableIterator(operationsFactory, defaultMarshaller, batchSize, segments, true, dataFormat);
       remoteCloseableIterator.start();
       return remoteCloseableIterator;
    }
@@ -185,7 +189,7 @@ public VersionedValue<V> getVersioned(K key) {
       assertRemoteCacheManagerIsStarted();
       if (ConfigurationProperties.isVersionPre12(remoteCacheManager.getConfiguration())) {
          GetWithVersionOperation<V> op = operationsFactory.newGetWithVersionOperation(
-               compatKeyIfNeeded(key), obj2bytes(key, true));
+               compatKeyIfNeeded(key), keyToBytes(key), dataFormat);
          return await(op.execute());
       } else {
          MetadataValue<V> result = getWithMetadata(key);
@@ -197,9 +201,13 @@ public VersionedValue<V> getVersioned(K key) {
 
    @Override
    public MetadataValue<V> getWithMetadata(K key) {
+      return getWithMetadata(key, dataFormat);
+   }
+
+   private MetadataValue<V> getWithMetadata(K key, DataFormat dataFormat) {
       assertRemoteCacheManagerIsStarted();
       GetWithMetadataOperation<V> op = operationsFactory.newGetWithMetadataOperation(
-         compatKeyIfNeeded(key), obj2bytes(key, true));
+            compatKeyIfNeeded(key), keyToBytes(key), dataFormat);
       return await(op.execute());
    }
 
@@ -216,9 +224,9 @@ public CompletableFuture<Void> putAllAsync(Map<? extends K, ? extends V> map, lo
       }
       Map<byte[], byte[]> byteMap = new HashMap<>();
       for (Entry<? extends K, ? extends V> entry : map.entrySet()) {
-         byteMap.put(obj2bytes(entry.getKey(),  true), obj2bytes(entry.getValue(), false));
+         byteMap.put(keyToBytes(entry.getKey()), valueToBytes(entry.getValue()));
       }
-      PutAllParallelOperation op = operationsFactory.newPutAllOperation(byteMap, lifespan, lifespanUnit, maxIdleTime, maxIdleTimeUnit);
+      PutAllParallelOperation op = operationsFactory.newPutAllOperation(byteMap, lifespan, lifespanUnit, maxIdleTime, maxIdleTimeUnit, dataFormat);
       return op.execute();
    }
 
@@ -279,14 +287,14 @@ public CompletableFuture<V> putAsync(K key, V value, long lifespan, TimeUnit lif
          log.tracef("About to add (K,V): (%s, %s) lifespan:%d, maxIdle:%d", key, value, lifespan, maxIdleTime);
       }
       PutOperation<V> op = operationsFactory.newPutKeyValueOperation(compatKeyIfNeeded(key),
-            obj2bytes(key, true), obj2bytes(value, false), lifespan, lifespanUnit, maxIdleTime, maxIdleTimeUnit);
+            keyToBytes(key), valueToBytes(value), lifespan, lifespanUnit, maxIdleTime, maxIdleTimeUnit, dataFormat);
       return op.execute();
    }
 
    @Override
    public CompletableFuture<Void> clearAsync() {
       assertRemoteCacheManagerIsStarted();
-      ClearOperation op = operationsFactory.newClearOperation() ;
+      ClearOperation op = operationsFactory.newClearOperation();
       return op.execute();
    }
 
@@ -294,14 +302,14 @@ public CompletableFuture<Void> clearAsync() {
    public CompletableFuture<V> putIfAbsentAsync(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdleTime, TimeUnit maxIdleTimeUnit) {
       assertRemoteCacheManagerIsStarted();
       PutIfAbsentOperation<V> op = operationsFactory.newPutIfAbsentOperation(compatKeyIfNeeded(key),
-            obj2bytes(key, true), obj2bytes(value, false), lifespan, lifespanUnit, maxIdleTime, maxIdleTimeUnit);
+            keyToBytes(key), valueToBytes(value), lifespan, lifespanUnit, maxIdleTime, maxIdleTimeUnit, dataFormat);
       return op.execute();
    }
 
    @Override
    public CompletableFuture<V> removeAsync(Object key) {
       assertRemoteCacheManagerIsStarted();
-      RemoveOperation<V> removeOperation = operationsFactory.newRemoveOperation(compatKeyIfNeeded(key), obj2bytes(key, true));
+      RemoveOperation<V> removeOperation = operationsFactory.newRemoveOperation(compatKeyIfNeeded(key), keyToBytes(key), dataFormat);
       // TODO: It sucks that you need the prev value to see if it works...
       // We need to find a better API for RemoteCache...
       return removeOperation.execute();
@@ -311,7 +319,7 @@ public CompletableFuture<V> removeAsync(Object key) {
    public CompletableFuture<V> replaceAsync(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdleTime, TimeUnit maxIdleTimeUnit) {
       assertRemoteCacheManagerIsStarted();
       ReplaceOperation<V> op = operationsFactory.newReplaceOperation(compatKeyIfNeeded(key),
-            obj2bytes(key, true), obj2bytes(value, false), lifespan, lifespanUnit, maxIdleTime, maxIdleTimeUnit);
+            keyToBytes(key), valueToBytes(value), lifespan, lifespanUnit, maxIdleTime, maxIdleTimeUnit, dataFormat);
       return op.execute();
    }
 
@@ -319,7 +327,7 @@ public CompletableFuture<V> replaceAsync(K key, V value, long lifespan, TimeUnit
    public boolean containsKey(Object key) {
       assertRemoteCacheManagerIsStarted();
       ContainsKeyOperation op = operationsFactory.newContainsKeyOperation(
-         compatKeyIfNeeded(key), obj2bytes(key, true));
+            compatKeyIfNeeded(key), keyToBytes(key), dataFormat);
       return await(op.execute());
    }
 
@@ -342,9 +350,9 @@ public Map<K, V> getAll(Set<? extends K> keys) {
       }
       Set<byte[]> byteKeys = new HashSet<>(keys.size());
       for (K key : keys) {
-         byteKeys.add(obj2bytes(key, true));
+         byteKeys.add(keyToBytes(key));
       }
-      GetAllParallelOperation<K, V> op = operationsFactory.newGetAllOperation(byteKeys);
+      GetAllParallelOperation<K, V> op = operationsFactory.newGetAllOperation(byteKeys, dataFormat);
       return await(op.execute().thenApply(Collections::unmodifiableMap));
    }
 
@@ -407,7 +415,7 @@ public String getProtocolVersion() {
    @Override
    public void addClientListener(Object listener) {
       assertRemoteCacheManagerIsStarted();
-      AddClientListenerOperation op = operationsFactory.newAddClientListenerOperation(listener);
+      AddClientListenerOperation op = operationsFactory.newAddClientListenerOperation(listener, dataFormat);
       // no timeout, see below
       await(op.execute());
    }
@@ -418,7 +426,7 @@ public void addClientListener(Object listener, Object[] filterFactoryParams, Obj
       byte[][] marshalledFilterParams = marshallParams(filterFactoryParams);
       byte[][] marshalledConverterParams = marshallParams(converterFactoryParams);
       AddClientListenerOperation op = operationsFactory.newAddClientListenerOperation(
-            listener, marshalledFilterParams, marshalledConverterParams);
+            listener, marshalledFilterParams, marshalledConverterParams, dataFormat);
       // No timeout: transferring initial state can take a while, socket timeout setting is not applicable here
       await(op.execute());
    }
@@ -429,7 +437,7 @@ private byte[][] marshallParams(Object[] params) {
 
       byte[][] marshalledParams = new byte[params.length][];
       for (int i = 0; i < marshalledParams.length; i++) {
-         byte[] bytes = obj2bytes(params[i], true);// should be small
+         byte[] bytes = keyToBytes(params[i]);// should be small
          marshalledParams[i] = bytes;
       }
 
@@ -458,8 +466,8 @@ public RemoteCache<K, V> withFlags(Flag... flags) {
    @Override
    public CompletableFuture<V> getAsync(Object key) {
       assertRemoteCacheManagerIsStarted();
-      byte[] keyBytes = obj2bytes(key, true);
-      GetOperation<V> gco = operationsFactory.newGetKeyOperation(compatKeyIfNeeded(key), keyBytes);
+      byte[] keyBytes = keyToBytes(key);
+      GetOperation<V> gco = operationsFactory.newGetKeyOperation(compatKeyIfNeeded(key), keyBytes, dataFormat);
       CompletableFuture<V> result = gco.execute();
       if (trace) {
          result.thenAccept(value -> log.tracef("For key(%s) returning %s", key, value));
@@ -471,8 +479,12 @@ public PingOperation.PingResult ping() {
       return await(operationsFactory.newFaultTolerantPingOperation().execute());
    }
 
-   byte[] obj2bytes(Object o, boolean isKey) {
-      return MarshallerUtil.obj2bytes(marshaller, o, isKey, estimateKeySize, estimateValueSize);
+   byte[] keyToBytes(Object o) {
+      return dataFormat.keyToBytes(o, estimateKeySize, estimateValueSize);
+   }
+
+   byte[] valueToBytes(Object o) {
+      return dataFormat.valueToBytes(o, estimateKeySize, estimateValueSize);
    }
 
    private void assertRemoteCacheManagerIsStarted() {
@@ -567,7 +579,7 @@ private boolean removeEntry(Map.Entry<K, V> entry) {
    }
 
    private boolean removeEntry(K key, V value) {
-      VersionedValue<V> versionedValue = getWithMetadata(key);
+      VersionedValue<V> versionedValue = getWithMetadata(key, dataFormat);
       return versionedValue != null && value.equals(versionedValue.getValue()) &&
             RemoteCacheImpl.this.removeWithVersion(key, versionedValue.getVersion());
    }
@@ -696,8 +708,8 @@ public <T> T execute(String taskName, Map<String, ?> params) {
       assertRemoteCacheManagerIsStarted();
       Map<String, byte[]> marshalledParams = new HashMap<>();
       if (params != null) {
-         for(java.util.Map.Entry<String, ?> entry : params.entrySet()) {
-            marshalledParams.put(entry.getKey(), obj2bytes(entry.getValue(), false));
+         for (java.util.Map.Entry<String, ?> entry : params.entrySet()) {
+            marshalledParams.put(entry.getKey(), keyToBytes(entry.getValue()));
          }
       }
       ExecuteOperation<T> op = operationsFactory.newExecuteOperation(taskName, marshalledParams);
@@ -715,6 +727,21 @@ public StreamingRemoteCache<K> streaming() {
       return new StreamingRemoteCacheImpl<>(this);
    }
 
+   @Override
+   public <T, U> RemoteCache<T, U> withDataFormat(DataFormat newDataFormat) {
+      newDataFormat = Objects.requireNonNull(newDataFormat, "Data Format must not be null");
+      newDataFormat.initialize(remoteCacheManager);
+      RemoteCacheImpl<T, U> instance = newInstance();
+      instance.dataFormat = newDataFormat;
+      return instance;
+   }
+
+   private <T, U> RemoteCacheImpl<T, U> newInstance() {
+      RemoteCacheImpl<T, U> copy = new RemoteCacheImpl<>(this.remoteCacheManager, name);
+      copy.init(this.defaultMarshaller, this.operationsFactory, this.estimateKeySize, this.estimateValueSize, this.batchSize);
+      return copy;
+   }
+
    public PingOperation.PingResult resolveCompatibility() {
       if (remoteCacheManager.isStarted()) {
          PingOperation.PingResult result = ping();
@@ -725,17 +752,9 @@ public PingOperation.PingResult resolveCompatibility() {
       return PingOperation.PingResult.FAIL;
    }
 
-   private abstract class WithFlagsCallable implements Callable<V> {
-      final int intFlags;
-
-      protected WithFlagsCallable(int intFlags) {
-         this.intFlags = intFlags;
-      }
-
-      void setFlagsIfPresent() {
-         if (intFlags != 0)
-            operationsFactory.setFlags(intFlags);
-      }
+   @Override
+   public DataFormat getDataFormat() {
+      return dataFormat;
    }
 
    public boolean hasCompatibility() {
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/StreamingRemoteCacheImpl.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/StreamingRemoteCacheImpl.java
index cb9c762f84c8..e53954227ecb 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/StreamingRemoteCacheImpl.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/StreamingRemoteCacheImpl.java
@@ -27,7 +27,7 @@ public StreamingRemoteCacheImpl(RemoteCacheImpl<K, ?> cache) {
 
    @Override
    public <T extends InputStream & VersionedMetadata> T get(K key) {
-      GetStreamOperation op = cache.operationsFactory.newGetStreamOperation(cache.compatKeyIfNeeded(key), cache.obj2bytes(key, true), 0);
+      GetStreamOperation op = cache.operationsFactory.newGetStreamOperation(cache.compatKeyIfNeeded(key), cache.keyToBytes(key), 0);
       return (T) await(op.execute());
    }
 
@@ -43,7 +43,7 @@ public OutputStream put(K key, long lifespan, TimeUnit unit) {
 
    @Override
    public OutputStream put(K key, long lifespan, TimeUnit lifespanUnit, long maxIdle, TimeUnit maxIdleUnit) {
-      PutStreamOperation op = cache.operationsFactory.newPutStreamOperation(cache.compatKeyIfNeeded(key), cache.obj2bytes(key, true), lifespan, lifespanUnit, maxIdle, maxIdleUnit);
+      PutStreamOperation op = cache.operationsFactory.newPutStreamOperation(cache.compatKeyIfNeeded(key), cache.keyToBytes(key), lifespan, lifespanUnit, maxIdle, maxIdleUnit);
       return await(op.execute());
    }
 
@@ -59,7 +59,7 @@ public OutputStream putIfAbsent(K key, long lifespan, TimeUnit unit) {
 
    @Override
    public OutputStream putIfAbsent(K key, long lifespan, TimeUnit lifespanUnit, long maxIdle, TimeUnit maxIdleUnit) {
-      PutStreamOperation op = cache.operationsFactory.newPutIfAbsentStreamOperation(cache.compatKeyIfNeeded(key), cache.obj2bytes(key, true), lifespan, lifespanUnit, maxIdle, maxIdleUnit);
+      PutStreamOperation op = cache.operationsFactory.newPutIfAbsentStreamOperation(cache.compatKeyIfNeeded(key), cache.keyToBytes(key), lifespan, lifespanUnit, maxIdle, maxIdleUnit);
       return await(op.execute());
    }
 
@@ -75,7 +75,7 @@ public OutputStream replaceWithVersion(K key, long version, long lifespan, TimeU
 
    @Override
    public OutputStream replaceWithVersion(K key, long version, long lifespan, TimeUnit lifespanUnit, long maxIdle, TimeUnit maxIdleUnit) {
-      PutStreamOperation op = cache.operationsFactory.newPutStreamOperation(cache.compatKeyIfNeeded(key), cache.obj2bytes(key, true), version, lifespan, lifespanUnit, maxIdle, maxIdleUnit);
+      PutStreamOperation op = cache.operationsFactory.newPutStreamOperation(cache.compatKeyIfNeeded(key), cache.keyToBytes(key), version, lifespan, lifespanUnit, maxIdle, maxIdleUnit);
       return await(op.execute());
    }
 }
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/KeyTrackerFactory.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/KeyTrackerFactory.java
index 7043a525ad19..769b4806f9f2 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/KeyTrackerFactory.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/KeyTrackerFactory.java
@@ -2,9 +2,9 @@
 
 import java.util.Set;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.impl.consistenthash.ConsistentHash;
 import org.infinispan.client.hotrod.impl.consistenthash.SegmentConsistentHash;
-import org.infinispan.commons.marshall.Marshaller;
 
 /**
  * @author gustavonalle
@@ -15,10 +15,10 @@ final class KeyTrackerFactory {
    private KeyTrackerFactory() {
    }
 
-   public static KeyTracker create(Marshaller marshaller, ConsistentHash hash, int topologyId, Set<Integer> segments) {
+   public static KeyTracker create(DataFormat dataFormat, ConsistentHash hash, int topologyId, Set<Integer> segments) {
       if (topologyId == -1) return new NoOpSegmentKeyTracker();
       if (hash == null) return new ReplKeyTracker();
-      return new SegmentKeyTracker(marshaller, (SegmentConsistentHash) hash, segments);
+      return new SegmentKeyTracker(dataFormat, (SegmentConsistentHash) hash, segments);
    }
 
 }
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/RemoteCloseableIterator.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/RemoteCloseableIterator.java
index ffcdb42a4c4e..08fd4d789581 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/RemoteCloseableIterator.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/RemoteCloseableIterator.java
@@ -8,6 +8,7 @@
 import java.util.Queue;
 import java.util.Set;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.exceptions.HotRodClientException;
 import org.infinispan.client.hotrod.exceptions.RemoteIllegalLifecycleStateException;
 import org.infinispan.client.hotrod.exceptions.TransportException;
@@ -42,6 +43,7 @@ public class RemoteCloseableIterator<E> implements CloseableIterator<Entry<Objec
    private final Set<Integer> segments;
    private final int batchSize;
    private final boolean metadata;
+   private final DataFormat dataFormat;
 
    private KeyTracker segmentKeyTracker;
    private Channel channel;
@@ -51,7 +53,7 @@ public class RemoteCloseableIterator<E> implements CloseableIterator<Entry<Objec
    private Queue<Entry<Object, E>> nextElements = new LinkedList<>();
 
    public RemoteCloseableIterator(OperationsFactory operationsFactory, Marshaller marshaller, String filterConverterFactory,
-                                  byte[][] filterParams, Set<Integer> segments, int batchSize, boolean metadata) {
+                                  byte[][] filterParams, Set<Integer> segments, int batchSize, boolean metadata, DataFormat dataFormat) {
       this.marshaller = marshaller;
       this.filterConverterFactory = filterConverterFactory;
       this.filterParams = filterParams;
@@ -59,10 +61,11 @@ public RemoteCloseableIterator(OperationsFactory operationsFactory, Marshaller m
       this.batchSize = batchSize;
       this.operationsFactory = operationsFactory;
       this.metadata = metadata;
+      this.dataFormat = dataFormat;
    }
 
-   public RemoteCloseableIterator(OperationsFactory operationsFactory, Marshaller marshaller, int batchSize, Set<Integer> segments, boolean metadata) {
-      this(operationsFactory, marshaller, null, null, segments, batchSize, metadata);
+   public RemoteCloseableIterator(OperationsFactory operationsFactory, Marshaller marshaller, int batchSize, Set<Integer> segments, boolean metadata, DataFormat dataFormat) {
+      this(operationsFactory, marshaller, null, null, segments, batchSize, metadata, dataFormat);
    }
 
    @Override
@@ -110,7 +113,7 @@ private void fetch() {
 
       try {
          while (nextElements.isEmpty() && !endOfIteration) {
-            IterationNextOperation<E> iterationNextOperation = operationsFactory.newIterationNextOperation(iterationId, channel, segmentKeyTracker);
+            IterationNextOperation<E> iterationNextOperation = operationsFactory.newIterationNextOperation(iterationId, channel, segmentKeyTracker, dataFormat);
             IterationNextResponse<E> iterationNextResponse = await(iterationNextOperation.execute());
             if (!iterationNextResponse.hasMore()) {
                endOfIteration = true;
@@ -133,7 +136,7 @@ private IterationStartResponse startInternal(Set<Integer> segments) {
       if (log.isDebugEnabled()) {
          log.debugf("Starting iteration with segments %s", segments);
       }
-      IterationStartOperation iterationStartOperation = operationsFactory.newIterationStartOperation(filterConverterFactory, filterParams, segments, batchSize, metadata);
+      IterationStartOperation iterationStartOperation = operationsFactory.newIterationStartOperation(filterConverterFactory, filterParams, segments, batchSize, metadata, dataFormat);
       IterationStartResponse startResponse = await(iterationStartOperation.execute());
       this.channel = startResponse.getChannel();
       this.iterationId = startResponse.getIterationId();
@@ -146,7 +149,6 @@ private IterationStartResponse startInternal(Set<Integer> segments) {
 
    public void start() {
       IterationStartResponse startResponse = startInternal(segments);
-      this.segmentKeyTracker = KeyTrackerFactory.create(
-              marshaller, startResponse.getSegmentConsistentHash(), startResponse.getTopologyId(), segments);
+      this.segmentKeyTracker = KeyTrackerFactory.create(dataFormat, startResponse.getSegmentConsistentHash(), startResponse.getTopologyId(), segments);
    }
 }
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java
index 0833cc4129c9..71a4a9dbcd6d 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java
@@ -7,12 +7,11 @@
 import java.util.concurrent.atomic.AtomicReferenceArray;
 import java.util.stream.IntStream;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.impl.consistenthash.SegmentConsistentHash;
 import org.infinispan.client.hotrod.impl.protocol.HotRodConstants;
 import org.infinispan.client.hotrod.logging.Log;
 import org.infinispan.client.hotrod.logging.LogFactory;
-import org.infinispan.client.hotrod.marshall.MarshallerUtil;
-import org.infinispan.commons.marshall.Marshaller;
 import org.infinispan.commons.marshall.WrappedByteArray;
 import org.infinispan.commons.util.Util;
 
@@ -27,24 +26,24 @@ class SegmentKeyTracker implements KeyTracker {
 
    private final AtomicReferenceArray<Set<WrappedByteArray>> keysPerSegment;
    private final SegmentConsistentHash segmentConsistentHash;
-   private final Marshaller marshaller;
+   private final DataFormat dataFormat;
 
-   public SegmentKeyTracker(Marshaller marshaller, SegmentConsistentHash segmentConsistentHash, Set<Integer> segments) {
-      this.marshaller = marshaller;
+   public SegmentKeyTracker(DataFormat dataFormat, SegmentConsistentHash segmentConsistentHash, Set<Integer> segments) {
+      this.dataFormat = dataFormat;
       int numSegments = segmentConsistentHash.getNumSegments();
       keysPerSegment = new AtomicReferenceArray<>(numSegments);
       if (trace)
          log.tracef("Created SegmentKeyTracker with %d segments, filter %s", numSegments, segments);
       this.segmentConsistentHash = segmentConsistentHash;
       IntStream segmentStream = segments == null ?
-              IntStream.range(0, segmentConsistentHash.getNumSegments()) : segments.stream().mapToInt(i -> i);
+            IntStream.range(0, segmentConsistentHash.getNumSegments()) : segments.stream().mapToInt(i -> i);
       segmentStream.forEach(i -> keysPerSegment.set(i, new HashSet<>()));
    }
 
    public boolean track(byte[] key, short status, List<String> whitelist) {
       int segment = HotRodConstants.hasCompatibility(status) ?
-              segmentConsistentHash.getSegment(MarshallerUtil.bytes2obj(marshaller, key, status, whitelist)) :
-              segmentConsistentHash.getSegment(key);
+            segmentConsistentHash.getSegment(dataFormat.keyToObj(key, status, whitelist)) :
+            segmentConsistentHash.getSegment(key);
       Set<WrappedByteArray> keys = keysPerSegment.get(segment);
       // TODO: this assertion may fail due to ISPN
       assert keys != null : "Segment " + segment + " not initialized, tracking key " + Util.toStr(key);
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/ContainsEntryMultimapOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/ContainsEntryMultimapOperation.java
index e0e3e079ea93..0454606d4705 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/ContainsEntryMultimapOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/ContainsEntryMultimapOperation.java
@@ -28,7 +28,7 @@
 public class ContainsEntryMultimapOperation extends AbstractKeyValueOperation<Boolean> {
 
    public ContainsEntryMultimapOperation(Codec codec, ChannelFactory channelFactory, Object key, byte[] keyBytes, byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg, byte[] value) {
-      super(CONTAINS_ENTRY_REQUEST, CONTAINS_ENTRY_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, value,  -1, TimeUnit.MILLISECONDS, -1, TimeUnit.MILLISECONDS);
+      super(CONTAINS_ENTRY_REQUEST, CONTAINS_ENTRY_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, value, -1, TimeUnit.MILLISECONDS, -1, TimeUnit.MILLISECONDS, null);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/ContainsKeyMultimapOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/ContainsKeyMultimapOperation.java
index 61e8afea3d84..aa84ae9ee9f1 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/ContainsKeyMultimapOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/ContainsKeyMultimapOperation.java
@@ -24,7 +24,7 @@
  */
 public class ContainsKeyMultimapOperation extends AbstractKeyOperation<Boolean> {
    public ContainsKeyMultimapOperation(Codec codec, ChannelFactory transportFactory, Object key, byte[] keyBytes, byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg) {
-      super(CONTAINS_KEY_MULTIMAP_REQUEST, CONTAINS_KEY_MULTIMAP_RESPONSE, codec, transportFactory, key, keyBytes, cacheName, topologyId, flags, cfg);
+      super(CONTAINS_KEY_MULTIMAP_REQUEST, CONTAINS_KEY_MULTIMAP_RESPONSE, codec, transportFactory, key, keyBytes, cacheName, topologyId, flags, cfg, null);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/ContainsValueMultimapOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/ContainsValueMultimapOperation.java
index 55df97d545a3..7e5479937346 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/ContainsValueMultimapOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/ContainsValueMultimapOperation.java
@@ -35,7 +35,7 @@ public class ContainsValueMultimapOperation extends RetryOnFailureOperation<Bool
    protected ContainsValueMultimapOperation(Codec codec, ChannelFactory channelFactory, byte[] cacheName,
                                             AtomicInteger topologyId, int flags, Configuration cfg, byte[] value,
                                             long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit) {
-      super(CONTAINS_VALUE_MULTIMAP_REQUEST, CONTAINS_VALUE_MULTIMAP_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg);
+      super(CONTAINS_VALUE_MULTIMAP_REQUEST, CONTAINS_VALUE_MULTIMAP_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg, null);
       this.value = value;
       this.lifespan = lifespan;
       this.maxIdle = maxIdle;
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/GetKeyMultimapOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/GetKeyMultimapOperation.java
index a38cdfa7fbe5..f808564bed23 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/GetKeyMultimapOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/GetKeyMultimapOperation.java
@@ -35,7 +35,7 @@ public class GetKeyMultimapOperation<V> extends AbstractKeyOperation<Collection<
    public GetKeyMultimapOperation(Codec codec, ChannelFactory channelFactory,
                                   Object key, byte[] keyBytes, byte[] cacheName, AtomicInteger topologyId, int flags,
                                   Configuration cfg) {
-      super(GET_MULTIMAP_REQUEST, GET_MULTIMAP_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg);
+      super(GET_MULTIMAP_REQUEST, GET_MULTIMAP_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, null);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/GetKeyWithMetadataMultimapOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/GetKeyWithMetadataMultimapOperation.java
index 6f46a22cad3a..2e9fef57d645 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/GetKeyWithMetadataMultimapOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/GetKeyWithMetadataMultimapOperation.java
@@ -39,7 +39,7 @@ public class GetKeyWithMetadataMultimapOperation<V> extends AbstractKeyOperation
    public GetKeyWithMetadataMultimapOperation(Codec codec, ChannelFactory channelFactory,
                                               Object key, byte[] keyBytes, byte[] cacheName, AtomicInteger topologyId, int flags,
                                               Configuration cfg) {
-      super(GET_MULTIMAP_WITH_METADATA_REQUEST, GET_MULTIMAP_WITH_METADATA_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg);
+      super(GET_MULTIMAP_WITH_METADATA_REQUEST, GET_MULTIMAP_WITH_METADATA_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, null);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/MultimapOperationsFactory.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/MultimapOperationsFactory.java
index 61215479f1af..8392fb358238 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/MultimapOperationsFactory.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/MultimapOperationsFactory.java
@@ -57,10 +57,10 @@ public <K, V> GetKeyWithMetadataMultimapOperation<V> newGetKeyWithMetadataMultim
    }
 
    public <K> PutKeyValueMultimapOperation newPutKeyValueOperation(K key, byte[] keyBytes, byte[] value,
-                                                                         long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit) {
+                                                                   long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit) {
       return new PutKeyValueMultimapOperation(
             codec, transportFactory, key, keyBytes, cacheNameBytes, topologyId, flags(lifespan, maxIdle),
-            cfg, value, lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit);
+            cfg, value, lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit, null);
    }
 
    public <K> RemoveKeyMultimapOperation newRemoveKeyOperation(K key, byte[] keyBytes) {
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/PutKeyValueMultimapOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/PutKeyValueMultimapOperation.java
index 66c89ef845a5..61993e9dc37d 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/PutKeyValueMultimapOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/PutKeyValueMultimapOperation.java
@@ -6,6 +6,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.exceptions.InvalidResponseException;
 import org.infinispan.client.hotrod.impl.operations.AbstractKeyValueOperation;
@@ -30,8 +31,10 @@ public class PutKeyValueMultimapOperation extends AbstractKeyValueOperation<Void
 
    public PutKeyValueMultimapOperation(Codec codec,
                                        ChannelFactory channelFactory,
-                                       Object key, byte[] keyBytes, byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg, byte[] value, long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit) {
-      super(PUT_MULTIMAP_REQUEST, PUT_MULTIMAP_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, value, lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit);
+                                       Object key, byte[] keyBytes, byte[] cacheName, AtomicInteger topologyId,
+                                       int flags, Configuration cfg, byte[] value, long lifespan,
+                                       TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit, DataFormat dataFormat) {
+      super(PUT_MULTIMAP_REQUEST, PUT_MULTIMAP_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, value, lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit, dataFormat);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/RemoveEntryMultimapOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/RemoveEntryMultimapOperation.java
index eb4c4afbe317..eb03294cec75 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/RemoveEntryMultimapOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/RemoveEntryMultimapOperation.java
@@ -28,7 +28,7 @@
 public class RemoveEntryMultimapOperation extends AbstractKeyValueOperation<Boolean> {
 
    public RemoveEntryMultimapOperation(Codec codec, ChannelFactory channelFactory, Object key, byte[] keyBytes, byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg, byte[] value) {
-      super(REMOVE_ENTRY_MULTIMAP_REQUEST, REMOVE_ENTRY_MULTIMAP_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, value,  -1, TimeUnit.MILLISECONDS, -1, TimeUnit.MILLISECONDS);
+      super(REMOVE_ENTRY_MULTIMAP_REQUEST, REMOVE_ENTRY_MULTIMAP_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, value, -1, TimeUnit.MILLISECONDS, -1, TimeUnit.MILLISECONDS, null);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/RemoveKeyMultimapOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/RemoveKeyMultimapOperation.java
index 1705b5605b09..b267333693b6 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/RemoveKeyMultimapOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/RemoveKeyMultimapOperation.java
@@ -24,7 +24,7 @@
  */
 public class RemoveKeyMultimapOperation extends AbstractKeyOperation<Boolean> {
    public RemoveKeyMultimapOperation(Codec codec, ChannelFactory channelFactory, Object key, byte[] keyBytes, byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg) {
-      super(REMOVE_KEY_MULTIMAP_REQUEST, REMOVE_KEY_MULTIMAP_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg);
+      super(REMOVE_KEY_MULTIMAP_REQUEST, REMOVE_KEY_MULTIMAP_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, null);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/SizeMultimapOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/SizeMultimapOperation.java
index f4b043ad3835..da9d1aa7953b 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/SizeMultimapOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/multimap/operations/SizeMultimapOperation.java
@@ -25,7 +25,7 @@
 public class SizeMultimapOperation extends RetryOnFailureOperation<Long> {
 
    protected SizeMultimapOperation(Codec codec, ChannelFactory channelFactory, byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg) {
-      super(SIZE_MULTIMAP_REQUEST, SIZE_MULTIMAP_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg);
+      super(SIZE_MULTIMAP_REQUEST, SIZE_MULTIMAP_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg, null);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/AbstractKeyOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/AbstractKeyOperation.java
index d29c821066d3..5606d2243a04 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/AbstractKeyOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/AbstractKeyOperation.java
@@ -4,6 +4,7 @@
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.VersionedOperationResponse;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
@@ -26,8 +27,8 @@ public abstract class AbstractKeyOperation<T> extends RetryOnFailureOperation<T>
    protected final byte[] keyBytes;
 
    protected AbstractKeyOperation(short requestCode, short responseCode, Codec codec, ChannelFactory channelFactory,
-                                  Object key, byte[] keyBytes, byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg) {
-      super(requestCode, responseCode, codec, channelFactory, cacheName, topologyId, flags, cfg);
+                                  Object key, byte[] keyBytes, byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg, DataFormat dataFormat) {
+      super(requestCode, responseCode, codec, channelFactory, cacheName, topologyId, flags, cfg, dataFormat);
       this.key = key;
       this.keyBytes = keyBytes;
    }
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/AbstractKeyValueOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/AbstractKeyValueOperation.java
index 67d97db414ca..531854908591 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/AbstractKeyValueOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/AbstractKeyValueOperation.java
@@ -5,6 +5,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
 import org.infinispan.client.hotrod.impl.transport.netty.ByteBufUtil;
@@ -35,8 +36,9 @@ public abstract class AbstractKeyValueOperation<T> extends AbstractKeyOperation<
 
    protected AbstractKeyValueOperation(short requestCode, short responseCode, Codec codec, ChannelFactory channelFactory, Object key, byte[] keyBytes, byte[] cacheName,
                                        AtomicInteger topologyId, int flags, Configuration cfg, byte[] value,
-                                       long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit) {
-      super(requestCode, responseCode, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg);
+                                       long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit,
+                                       DataFormat dataFormat) {
+      super(requestCode, responseCode, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, dataFormat);
       this.value = value;
       this.lifespan = lifespan;
       this.maxIdle = maxIdle;
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/AddClientListenerOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/AddClientListenerOperation.java
index c6903bd02bde..c8da93ec69fc 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/AddClientListenerOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/AddClientListenerOperation.java
@@ -4,6 +4,7 @@
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.RemoteCacheManager;
 import org.infinispan.client.hotrod.annotation.ClientListener;
 import org.infinispan.client.hotrod.configuration.Configuration;
@@ -12,9 +13,9 @@
 import org.infinispan.client.hotrod.impl.protocol.Codec;
 import org.infinispan.client.hotrod.impl.protocol.HotRodConstants;
 import org.infinispan.client.hotrod.impl.transport.netty.ByteBufUtil;
+import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;
 import org.infinispan.client.hotrod.impl.transport.netty.ChannelRecord;
 import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;
-import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;
 import org.infinispan.client.hotrod.logging.Log;
 import org.infinispan.client.hotrod.logging.LogFactory;
 import org.infinispan.commons.util.ReflectionUtil;
@@ -40,16 +41,16 @@ public class AddClientListenerOperation extends RetryOnFailureOperation<Short> {
    protected AddClientListenerOperation(Codec codec, ChannelFactory channelFactory,
                                         String cacheName, AtomicInteger topologyId, int flags, Configuration cfg,
                                         ClientListenerNotifier listenerNotifier, Object listener,
-                                        byte[][] filterFactoryParams, byte[][] converterFactoryParams) {
+                                        byte[][] filterFactoryParams, byte[][] converterFactoryParams, DataFormat dataFormat) {
       this(codec, channelFactory, cacheName, topologyId, flags, cfg, generateListenerId(),
-            listenerNotifier, listener, filterFactoryParams, converterFactoryParams);
+            listenerNotifier, listener, filterFactoryParams, converterFactoryParams, dataFormat);
    }
 
    private AddClientListenerOperation(Codec codec, ChannelFactory channelFactory,
                                       String cacheName, AtomicInteger topologyId, int flags, Configuration cfg,
                                       byte[] listenerId, ClientListenerNotifier listenerNotifier, Object listener,
-                                      byte[][] filterFactoryParams, byte[][] converterFactoryParams) {
-      super(ADD_CLIENT_LISTENER_REQUEST, ADD_CLIENT_LISTENER_RESPONSE, codec, channelFactory, RemoteCacheManager.cacheNameBytes(cacheName), topologyId, flags, cfg);
+                                      byte[][] filterFactoryParams, byte[][] converterFactoryParams, DataFormat dataFormat) {
+      super(ADD_CLIENT_LISTENER_REQUEST, ADD_CLIENT_LISTENER_RESPONSE, codec, channelFactory, RemoteCacheManager.cacheNameBytes(cacheName), topologyId, flags, cfg, dataFormat);
       this.listenerId = listenerId;
       this.listenerNotifier = listenerNotifier;
       this.listener = listener;
@@ -60,7 +61,7 @@ private AddClientListenerOperation(Codec codec, ChannelFactory channelFactory,
 
    public AddClientListenerOperation copy() {
       return new AddClientListenerOperation(codec, channelFactory, cacheNameString, header.topologyId(), flags, cfg,
-            listenerId, listenerNotifier, listener, filterFactoryParams, converterFactoryParams);
+            listenerId, listenerNotifier, listener, filterFactoryParams, converterFactoryParams, dataFormat);
    }
 
    private static byte[] generateListenerId() {
@@ -94,6 +95,14 @@ protected void executeOperation(Channel channel) {
       }
       ClientListener clientListener = extractClientListener();
 
+      boolean usesRawData = clientListener.useRawData();
+      boolean usesFilter = !(clientListener.converterFactoryName().equals("") && clientListener.filterFactoryName().equals(""));
+      boolean customDataFormat = dataFormat != null && dataFormat.hasCustomFormat();
+
+      if (customDataFormat && usesFilter && !usesRawData) {
+         throw log.clientListenerMustUseRawDataWithCustomDataFormat();
+      }
+
       channel.pipeline().get(HeaderDecoder.class).registerOperation(channel, this);
 
       listenerNotifier.addDispatcher(ClientEventDispatcher.create(this,
@@ -162,4 +171,8 @@ public void postponeTimeout(Channel channel) {
    protected void addParams(StringBuilder sb) {
       sb.append("listenerId=").append(Util.printArray(listenerId));
    }
+
+   public DataFormat getDataFormat() {
+      return dataFormat;
+   }
 }
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/BulkGetKeysOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/BulkGetKeysOperation.java
index 0c6048cfd814..12a5db1718d1 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/BulkGetKeysOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/BulkGetKeysOperation.java
@@ -7,8 +7,8 @@
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
 import org.infinispan.client.hotrod.impl.transport.netty.ByteBufUtil;
-import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;
 import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;
+import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
@@ -25,7 +25,7 @@ public class BulkGetKeysOperation<K> extends RetryOnFailureOperation<Set<K>> {
 
    public BulkGetKeysOperation(Codec codec, ChannelFactory channelFactory, byte[] cacheName,
                                AtomicInteger topologyId, int flags, Configuration cfg, int scope) {
-      super(BULK_GET_KEYS_REQUEST, BULK_GET_KEYS_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg);
+      super(BULK_GET_KEYS_REQUEST, BULK_GET_KEYS_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg, null);
       this.scope = scope;
    }
 
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/BulkGetOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/BulkGetOperation.java
index eda139079c39..877276644272 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/BulkGetOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/BulkGetOperation.java
@@ -7,8 +7,8 @@
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
 import org.infinispan.client.hotrod.impl.transport.netty.ByteBufUtil;
-import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;
 import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;
+import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
@@ -25,7 +25,7 @@ public class BulkGetOperation<K, V> extends RetryOnFailureOperation<Map<K, V>> {
 
    public BulkGetOperation(Codec codec, ChannelFactory channelFactory, byte[] cacheName, AtomicInteger topologyId,
                            int flags, Configuration cfg, int entryCount) {
-      super(BULK_GET_REQUEST, BULK_GET_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg);
+      super(BULK_GET_REQUEST, BULK_GET_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg, null);
       this.entryCount = entryCount;
    }
 
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ClearOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ClearOperation.java
index 6094016d2f94..31fa6c8ecfab 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ClearOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ClearOperation.java
@@ -22,7 +22,7 @@ public class ClearOperation extends RetryOnFailureOperation<Void> {
 
    public ClearOperation(Codec codec, ChannelFactory channelFactory,
                          byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg) {
-      super(CLEAR_REQUEST, CLEAR_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg);
+      super(CLEAR_REQUEST, CLEAR_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg, null);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ContainsKeyOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ContainsKeyOperation.java
index f3d5ecd7bc60..c7512033dfdc 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ContainsKeyOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ContainsKeyOperation.java
@@ -2,6 +2,7 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
 import org.infinispan.client.hotrod.impl.protocol.HotRodConstants;
@@ -22,8 +23,8 @@
 public class ContainsKeyOperation extends AbstractKeyOperation<Boolean> {
 
    public ContainsKeyOperation(Codec codec, ChannelFactory channelFactory, Object key, byte[] keyBytes,
-                               byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg) {
-      super(CONTAINS_KEY_REQUEST, CONTAINS_KEY_RESPONSE, codec, channelFactory, key, keyBytes,cacheName, topologyId, flags, cfg);
+                               byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg, DataFormat dataFormat) {
+      super(CONTAINS_KEY_REQUEST, CONTAINS_KEY_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, dataFormat);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ExecuteOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ExecuteOperation.java
index 6fd0f98209ec..6d5e4fecf693 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ExecuteOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ExecuteOperation.java
@@ -27,7 +27,7 @@ public class ExecuteOperation<T> extends RetryOnFailureOperation<T> {
    protected ExecuteOperation(Codec codec, ChannelFactory channelFactory, byte[] cacheName,
                               AtomicInteger topologyId, int flags, Configuration cfg,
                               String taskName, Map<String, byte[]> marshalledParams) {
-      super(EXEC_REQUEST, EXEC_RESPONSE, codec, channelFactory, cacheName == null ? DEFAULT_CACHE_NAME_BYTES : cacheName, topologyId, flags, cfg);
+      super(EXEC_REQUEST, EXEC_RESPONSE, codec, channelFactory, cacheName == null ? DEFAULT_CACHE_NAME_BYTES : cacheName, topologyId, flags, cfg, null);
       this.taskName = taskName;
       this.marshalledParams = marshalledParams;
    }
@@ -41,7 +41,7 @@ protected void executeOperation(Channel channel) {
       codec.writeHeader(buf, header);
       ByteBufUtil.writeString(buf, taskName);
       ByteBufUtil.writeVInt(buf, marshalledParams.size());
-      for(Entry<String, byte[]> entry : marshalledParams.entrySet()) {
+      for (Entry<String, byte[]> entry : marshalledParams.entrySet()) {
          ByteBufUtil.writeString(buf, entry.getKey());
          ByteBufUtil.writeArray(buf, entry.getValue());
       }
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/FaultTolerantPingOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/FaultTolerantPingOperation.java
index 87cba83aefdb..49f586eaef07 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/FaultTolerantPingOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/FaultTolerantPingOperation.java
@@ -27,7 +27,7 @@ public class FaultTolerantPingOperation extends RetryOnFailureOperation<PingOper
    protected FaultTolerantPingOperation(Codec codec, ChannelFactory channelFactory,
                                         byte[] cacheName, AtomicInteger topologyId, int flags,
                                         Configuration cfg) {
-      super(PING_REQUEST, PING_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg);
+      super(PING_REQUEST, PING_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg, null);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetAllOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetAllOperation.java
index 70f1df9a04e6..ae0ddc94e61b 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetAllOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetAllOperation.java
@@ -6,11 +6,12 @@
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
 import org.infinispan.client.hotrod.impl.transport.netty.ByteBufUtil;
-import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;
 import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;
+import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
@@ -30,8 +31,8 @@ public class GetAllOperation<K, V> extends RetryOnFailureOperation<Map<K, V>> {
 
    public GetAllOperation(Codec codec, ChannelFactory channelFactory,
                           Set<byte[]> keys, byte[] cacheName, AtomicInteger topologyId,
-                          int flags, Configuration cfg) {
-      super(GET_ALL_REQUEST, GET_ALL_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg);
+                          int flags, Configuration cfg, DataFormat dataFormat) {
+      super(GET_ALL_REQUEST, GET_ALL_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg, dataFormat);
       this.keys = keys;
    }
 
@@ -75,8 +76,8 @@ public void acceptResponse(ByteBuf buf, short status, HeaderDecoder decoder) {
          decoder.checkpoint();
       }
       while (result.size() < size) {
-         K key = codec.readUnmarshallByteArray(buf, status, cfg.serialWhitelist(), channelFactory.getMarshaller());
-         V value = codec.readUnmarshallByteArray(buf, status, cfg.serialWhitelist(), channelFactory.getMarshaller());
+         K key = dataFormat.keyToObj(ByteBufUtil.readArray(buf), status, cfg.serialWhitelist());
+         V value = dataFormat.valueToObj(ByteBufUtil.readArray(buf), status, cfg.serialWhitelist());
          result.put(key, value);
          decoder.checkpoint();
       }
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetAllParallelOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetAllParallelOperation.java
index 26a9cc205b04..a40663b72e0a 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetAllParallelOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetAllParallelOperation.java
@@ -9,6 +9,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.stream.Collectors;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
 import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;
@@ -21,8 +22,8 @@ public class GetAllParallelOperation<K, V> extends ParallelHotRodOperation<Map<K
    private final Set<byte[]> keys;
 
    protected GetAllParallelOperation(Codec codec, ChannelFactory channelFactory, Set<byte[]> keys, byte[]
-         cacheName, AtomicInteger topologyId, int flags, Configuration cfg) {
-      super(codec, channelFactory, cacheName, topologyId, flags, cfg);
+         cacheName, AtomicInteger topologyId, int flags, Configuration cfg, DataFormat dataFormat) {
+      super(codec, channelFactory, cacheName, topologyId, flags, cfg, dataFormat);
       this.keys = keys;
    }
 
@@ -32,17 +33,13 @@ protected List<GetAllOperation<K, V>> mapOperations() {
 
       for (byte[] key : keys) {
          SocketAddress socketAddress = channelFactory.getSocketAddress(key, cacheName);
-         Set<byte[]> keys = splittedKeys.get(socketAddress);
-         if (keys == null) {
-            keys = new HashSet<>();
-            splittedKeys.put(socketAddress, keys);
-         }
+         Set<byte[]> keys = splittedKeys.computeIfAbsent(socketAddress, k -> new HashSet<>());
          keys.add(key);
       }
 
       return splittedKeys.values().stream().map(
             keysSubset -> new GetAllOperation<K, V>(codec, channelFactory, keysSubset, cacheName, header.topologyId(),
-                  flags, cfg)).collect(Collectors.toList());
+                  flags, cfg, dataFormat)).collect(Collectors.toList());
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetOperation.java
index b815ccb85999..58fbd52b887c 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetOperation.java
@@ -2,9 +2,11 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
 import org.infinispan.client.hotrod.impl.protocol.HotRodConstants;
+import org.infinispan.client.hotrod.impl.transport.netty.ByteBufUtil;
 import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;
 import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;
 
@@ -23,8 +25,8 @@ public class GetOperation<V> extends AbstractKeyOperation<V> {
 
    public GetOperation(Codec codec, ChannelFactory channelFactory,
                        Object key, byte[] keyBytes, byte[] cacheName, AtomicInteger topologyId, int flags,
-                       Configuration cfg) {
-      super(GET_REQUEST, GET_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg);
+                       Configuration cfg, DataFormat dataFormat) {
+      super(GET_REQUEST, GET_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, dataFormat);
    }
 
    @Override
@@ -36,7 +38,7 @@ public void executeOperation(Channel channel) {
    @Override
    public void acceptResponse(ByteBuf buf, short status, HeaderDecoder decoder) {
       if (!HotRodConstants.isNotExist(status) && HotRodConstants.isSuccess(status)) {
-         complete(codec.readUnmarshallByteArray(buf, status, cfg.serialWhitelist(), channelFactory.getMarshaller()));
+         complete(dataFormat.valueToObj(ByteBufUtil.readArray(buf), status, cfg.serialWhitelist()));
       } else {
          complete(null);
       }
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetStreamOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetStreamOperation.java
index e8b4cf0cf911..098c4cd32723 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetStreamOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetStreamOperation.java
@@ -28,7 +28,7 @@ public class GetStreamOperation extends AbstractKeyOperation<ChannelInputStream>
 
    public GetStreamOperation(Codec codec, ChannelFactory channelFactory,
                              Object key, byte[] keyBytes, int offset, byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg) {
-      super(GET_STREAM_REQUEST, GET_STREAM_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg);
+      super(GET_STREAM_REQUEST, GET_STREAM_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, null);
       this.offset = offset;
    }
 
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetWithMetadataOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetWithMetadataOperation.java
index 411462d7cb04..35701a539300 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetWithMetadataOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetWithMetadataOperation.java
@@ -2,6 +2,7 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.MetadataValue;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.MetadataValueImpl;
@@ -32,8 +33,8 @@ public class GetWithMetadataOperation<V> extends AbstractKeyOperation<MetadataVa
 
    public GetWithMetadataOperation(Codec codec, ChannelFactory channelFactory, Object key, byte[] keyBytes,
                                    byte[] cacheName, AtomicInteger topologyId, int flags,
-                                   Configuration cfg) {
-      super(GET_WITH_METADATA, GET_WITH_METADATA_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg);
+                                   Configuration cfg, DataFormat dataFormat) {
+      super(GET_WITH_METADATA, GET_WITH_METADATA_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, dataFormat);
    }
 
    @Override
@@ -65,7 +66,7 @@ public void acceptResponse(ByteBuf buf, short status, HeaderDecoder decoder) {
       if (trace) {
          log.tracef("Received version: %d", version);
       }
-      V value = codec.readUnmarshallByteArray(buf, status, cfg.serialWhitelist(), channelFactory.getMarshaller());
+      V value = dataFormat.valueToObj(ByteBufUtil.readArray(buf), status, cfg.serialWhitelist());
       complete(new MetadataValueImpl<V>(creation, lifespan, lastUsed, maxIdle, version, value));
    }
 }
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetWithVersionOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetWithVersionOperation.java
index b5076f9b9a6b..4b9bf151eab2 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetWithVersionOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/GetWithVersionOperation.java
@@ -2,6 +2,7 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.VersionedValue;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.VersionedValueImpl;
@@ -33,8 +34,8 @@ public class GetWithVersionOperation<V> extends AbstractKeyOperation<VersionedVa
 
    public GetWithVersionOperation(Codec codec, ChannelFactory channelFactory, Object key, byte[] keyBytes,
                                   byte[] cacheName, AtomicInteger topologyId, int flags,
-                                  Configuration cfg) {
-      super(GET_WITH_VERSION, GET_WITH_VERSION_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg);
+                                  Configuration cfg, DataFormat dataFormat) {
+      super(GET_WITH_VERSION, GET_WITH_VERSION_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, dataFormat);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/HotRodOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/HotRodOperation.java
index 96e48f1b16bd..edd0193f4c43 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/HotRodOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/HotRodOperation.java
@@ -8,14 +8,16 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.exceptions.HotRodClientException;
+import org.infinispan.client.hotrod.impl.MarshallerRegistry;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
 import org.infinispan.client.hotrod.impl.protocol.HeaderParams;
 import org.infinispan.client.hotrod.impl.protocol.HotRodConstants;
 import org.infinispan.client.hotrod.impl.transport.netty.ByteBufUtil;
-import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;
 import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;
+import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;
 import org.infinispan.client.hotrod.logging.Log;
 import org.infinispan.client.hotrod.logging.LogFactory;
 
@@ -47,26 +49,37 @@ public abstract class HotRodOperation<T> extends CompletableFuture<T> implements
    protected final Codec codec;
    protected final Configuration cfg;
    protected final ChannelFactory channelFactory;
+   protected final DataFormat dataFormat;
    protected final HeaderParams header;
+   private final MarshallerRegistry marshallerRegistry;
    protected volatile ScheduledFuture<?> timeoutFuture;
 
    private static final byte NO_TX = 0;
    private static final byte XA_TX = 1;
 
-   protected HotRodOperation(short requestCode, short responseCode, Codec codec, int flags, Configuration cfg, byte[] cacheName, AtomicInteger topologyId, ChannelFactory channelFactory) {
+   protected HotRodOperation(short requestCode, short responseCode, Codec codec, int flags, Configuration cfg,
+                             byte[] cacheName, AtomicInteger topologyId, ChannelFactory channelFactory,
+                             DataFormat dataFormat) {
       this.flags = flags;
       this.cfg = cfg;
       this.cacheName = cacheName;
       this.codec = codec;
       this.channelFactory = channelFactory;
+      this.marshallerRegistry = channelFactory.getMarshallerRegistry();
+      this.dataFormat = dataFormat;
       // TODO: we could inline all the header here
       this.header = new HeaderParams(requestCode, responseCode, MSG_ID.getAndIncrement())
             .cacheName(cacheName).flags(flags)
             .clientIntel(cfg.clientIntelligence())
             .topologyId(topologyId).txMarker(NO_TX)
+            .dataFormat(dataFormat)
             .topologyAge(channelFactory.getTopologyAge());
    }
 
+   protected HotRodOperation(short requestCode, short responseCode, Codec codec, int flags, Configuration cfg, byte[] cacheName, AtomicInteger topologyId, ChannelFactory channelFactory) {
+      this(requestCode, responseCode, codec, flags, cfg, cacheName, topologyId, channelFactory, null);
+   }
+
    public abstract CompletableFuture<T> execute();
 
    public HeaderParams header() {
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/IterationNextOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/IterationNextOperation.java
index 72201ecce51a..0ad26e254a4a 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/IterationNextOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/IterationNextOperation.java
@@ -8,18 +8,17 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.MetadataValueImpl;
 import org.infinispan.client.hotrod.impl.iteration.KeyTracker;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
 import org.infinispan.client.hotrod.impl.protocol.HotRodConstants;
 import org.infinispan.client.hotrod.impl.transport.netty.ByteBufUtil;
-import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;
 import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;
+import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;
 import org.infinispan.client.hotrod.logging.Log;
 import org.infinispan.client.hotrod.logging.LogFactory;
-import org.infinispan.client.hotrod.marshall.MarshallerUtil;
-import org.infinispan.commons.marshall.Marshaller;
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
@@ -44,8 +43,8 @@ public class IterationNextOperation<E> extends HotRodOperation<IterationNextResp
 
    protected IterationNextOperation(Codec codec, int flags, Configuration cfg, byte[] cacheName,
                                     AtomicInteger topologyId, byte[] iterationId, Channel channel,
-                                    ChannelFactory channelFactory, KeyTracker segmentKeyTracker) {
-      super(ITERATION_NEXT_REQUEST, ITERATION_NEXT_RESPONSE, codec, flags, cfg, cacheName, topologyId, channelFactory);
+                                    ChannelFactory channelFactory, KeyTracker segmentKeyTracker, DataFormat dataFormat) {
+      super(ITERATION_NEXT_REQUEST, ITERATION_NEXT_RESPONSE, codec, flags, cfg, cacheName, topologyId, channelFactory, dataFormat);
       this.iterationId = iterationId;
       this.channel = channel;
       this.segmentKeyTracker = segmentKeyTracker;
@@ -99,18 +98,19 @@ public void acceptResponse(ByteBuf buf, short status, HeaderDecoder decoder) {
          if (projectionsSize > 1) {
             Object[] projections = new Object[projectionsSize];
             for (int j = 0; j < projectionsSize; j++) {
-               projections[j] = unmarshall(ByteBufUtil.readArray(buf), status);
+               projections[j] = unmarshallValue(ByteBufUtil.readArray(buf), status);
             }
             value = projections;
          } else {
-            value = unmarshall(ByteBufUtil.readArray(buf), status);
+            value = unmarshallValue(ByteBufUtil.readArray(buf), status);
          }
          if (meta == 1) {
             value = new MetadataValueImpl<>(creation, lifespan, lastUsed, maxIdle, version, value);
          }
 
          if (segmentKeyTracker.track(key, status, cfg.serialWhitelist())) {
-            entries.add(new SimpleEntry<>(unmarshall(key, status), (E) value));
+            Object unmarshallKey = dataFormat.keyToObj(key, status, cfg.serialWhitelist());
+            entries.add(new SimpleEntry<>(unmarshallKey, (E) value));
          } else {
             untrackedEntries++;
          }
@@ -123,8 +123,7 @@ public void acceptResponse(ByteBuf buf, short status, HeaderDecoder decoder) {
       complete(new IterationNextResponse(status, entries, entriesSize > 0));
    }
 
-   private Object unmarshall(byte[] bytes, short status) {
-      Marshaller marshaller = channelFactory.getMarshaller();
-      return MarshallerUtil.bytes2obj(marshaller, bytes, status, cfg.serialWhitelist());
+   private Object unmarshallValue(byte[] bytes, short status) {
+      return dataFormat.valueToObj(bytes, status, cfg.serialWhitelist());
    }
 }
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/IterationStartOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/IterationStartOperation.java
index 9ba730e3627c..5f6f87341e8d 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/IterationStartOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/IterationStartOperation.java
@@ -3,6 +3,7 @@
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.consistenthash.SegmentConsistentHash;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
@@ -29,8 +30,8 @@ public class IterationStartOperation extends RetryOnFailureOperation<IterationSt
 
    IterationStartOperation(Codec codec, int flags, Configuration cfg, byte[] cacheName, AtomicInteger topologyId,
                            String filterConverterFactory, byte[][] filterParameters, Set<Integer> segments,
-                           int batchSize, ChannelFactory channelFactory, boolean metadata) {
-      super(ITERATION_START_REQUEST, ITERATION_START_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg);
+                           int batchSize, ChannelFactory channelFactory, boolean metadata, DataFormat dataFormat) {
+      super(ITERATION_START_REQUEST, ITERATION_START_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg, dataFormat);
       this.filterConverterFactory = filterConverterFactory;
       this.filterParameters = filterParameters;
       this.segments = segments;
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/OperationsFactory.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/OperationsFactory.java
index 988fbc88b27f..59723bf0238f 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/OperationsFactory.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/OperationsFactory.java
@@ -6,6 +6,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.infinispan.client.hotrod.CacheTopologyInfo;
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.Flag;
 import org.infinispan.client.hotrod.RemoteCacheManager;
 import org.infinispan.client.hotrod.configuration.Configuration;
@@ -52,8 +53,8 @@ public OperationsFactory(ChannelFactory channelFactory, String cacheName, boolea
       this.cacheNameBytes = cacheName == null ? DEFAULT_CACHE_NAME_BYTES : RemoteCacheManager.cacheNameBytes(cacheName);
       this.cacheName = cacheName;
       this.topologyId = channelFactory != null
-         ? channelFactory.createTopologyId(cacheNameBytes)
-         : new AtomicInteger(-1);
+            ? channelFactory.createTopologyId(cacheNameBytes)
+            : new AtomicInteger(-1);
       this.forceReturnValue = forceReturnValue;
       this.codec = codec;
       this.listenerNotifier = listenerNotifier;
@@ -76,41 +77,41 @@ public Codec getCodec() {
       return codec;
    }
 
-   public <V> GetOperation<V> newGetKeyOperation(Object key, byte[] keyBytes) {
+   public <V> GetOperation<V> newGetKeyOperation(Object key, byte[] keyBytes, DataFormat dataFormat) {
       return new GetOperation<>(
-            codec, channelFactory, key, keyBytes, cacheNameBytes, topologyId, flags(), cfg);
+            codec, channelFactory, key, keyBytes, cacheNameBytes, topologyId, flags(), cfg, dataFormat);
    }
 
-   public <K, V> GetAllParallelOperation<K, V> newGetAllOperation(Set<byte[]> keys) {
+   public <K, V> GetAllParallelOperation<K, V> newGetAllOperation(Set<byte[]> keys, DataFormat dataFormat) {
       return new GetAllParallelOperation<>(codec, channelFactory, keys, cacheNameBytes, topologyId, flags(),
-            cfg);
+            cfg, dataFormat);
    }
 
-   public <V> RemoveOperation<V> newRemoveOperation(Object key, byte[] keyBytes) {
+   public <V> RemoveOperation<V> newRemoveOperation(Object key, byte[] keyBytes, DataFormat dataFormat) {
       return new RemoveOperation<>(
-            codec, channelFactory, key, keyBytes, cacheNameBytes, topologyId, flags(), cfg);
+            codec, channelFactory, key, keyBytes, cacheNameBytes, topologyId, flags(), cfg, dataFormat);
    }
 
-   public <V> RemoveIfUnmodifiedOperation<V> newRemoveIfUnmodifiedOperation(Object key, byte[] keyBytes, long version) {
+   public <V> RemoveIfUnmodifiedOperation<V> newRemoveIfUnmodifiedOperation(Object key, byte[] keyBytes, long version, DataFormat dataFormat) {
       return new RemoveIfUnmodifiedOperation<>(
-            codec, channelFactory, key, keyBytes, cacheNameBytes, topologyId, flags(), cfg, version);
+            codec, channelFactory, key, keyBytes, cacheNameBytes, topologyId, flags(), cfg, version, dataFormat);
    }
 
    public ReplaceIfUnmodifiedOperation newReplaceIfUnmodifiedOperation(Object key, byte[] keyBytes,
-            byte[] value, long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit, long version) {
+                                                                       byte[] value, long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit, long version, DataFormat dataFormat) {
       return new ReplaceIfUnmodifiedOperation(
             codec, channelFactory, key, keyBytes, cacheNameBytes, topologyId, flags(lifespan, maxIdle),
-            cfg, value, lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit, version);
+            cfg, value, lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit, version, dataFormat);
    }
 
-   public <V> GetWithVersionOperation<V> newGetWithVersionOperation(Object key, byte[] keyBytes) {
+   public <V> GetWithVersionOperation<V> newGetWithVersionOperation(Object key, byte[] keyBytes, DataFormat dataFormat) {
       return new GetWithVersionOperation<>(
-            codec, channelFactory, key, keyBytes, cacheNameBytes, topologyId, flags(), cfg);
+            codec, channelFactory, key, keyBytes, cacheNameBytes, topologyId, flags(), cfg, dataFormat);
    }
 
-   public <V> GetWithMetadataOperation<V> newGetWithMetadataOperation(Object key, byte[] keyBytes) {
+   public <V> GetWithMetadataOperation<V> newGetWithMetadataOperation(Object key, byte[] keyBytes, DataFormat dataFormat) {
       return new GetWithMetadataOperation<>(
-            codec, channelFactory, key, keyBytes, cacheNameBytes, topologyId, flags(), cfg);
+            codec, channelFactory, key, keyBytes, cacheNameBytes, topologyId, flags(), cfg, dataFormat);
    }
 
    public StatsOperation newStatsOperation() {
@@ -119,36 +120,38 @@ public StatsOperation newStatsOperation() {
    }
 
    public <V> PutOperation<V> newPutKeyValueOperation(Object key, byte[] keyBytes, byte[] value,
-          long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit) {
+                                                      long lifespan, TimeUnit lifespanTimeUnit, long maxIdle,
+                                                      TimeUnit maxIdleTimeUnit, DataFormat dataFormat) {
       return new PutOperation<>(
             codec, channelFactory, key, keyBytes, cacheNameBytes, topologyId, flags(lifespan, maxIdle),
-            cfg, value, lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit);
+            cfg, value, lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit, dataFormat);
    }
 
    public PutAllParallelOperation newPutAllOperation(Map<byte[], byte[]> map,
-                                                     long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit) {
+                                                     long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit, DataFormat dataFormat) {
       return new PutAllParallelOperation(
             codec, channelFactory, map, cacheNameBytes, topologyId, flags(lifespan, maxIdle), cfg,
-              lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit);
+            lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit, dataFormat);
    }
 
    public <V> PutIfAbsentOperation<V> newPutIfAbsentOperation(Object key, byte[] keyBytes, byte[] value,
-             long lifespan, TimeUnit lifespanUnit, long maxIdleTime, TimeUnit maxIdleTimeUnit) {
+                                                              long lifespan, TimeUnit lifespanUnit, long maxIdleTime,
+                                                              TimeUnit maxIdleTimeUnit, DataFormat dataFormat) {
       return new PutIfAbsentOperation<>(
             codec, channelFactory, key, keyBytes, cacheNameBytes, topologyId, flags(lifespan, maxIdleTime),
-            cfg, value, lifespan, lifespanUnit, maxIdleTime, maxIdleTimeUnit);
+            cfg, value, lifespan, lifespanUnit, maxIdleTime, maxIdleTimeUnit, dataFormat);
    }
 
    public <V> ReplaceOperation<V> newReplaceOperation(Object key, byte[] keyBytes, byte[] values,
-           long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit) {
+           long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit, DataFormat dataFormat) {
       return new ReplaceOperation<>(
             codec, channelFactory, key, keyBytes, cacheNameBytes, topologyId, flags(lifespan, maxIdle),
-            cfg, values, lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit);
+            cfg, values, lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit, dataFormat);
    }
 
-   public ContainsKeyOperation newContainsKeyOperation(Object key, byte[] keyBytes) {
+   public ContainsKeyOperation newContainsKeyOperation(Object key, byte[] keyBytes, DataFormat dataFormat) {
       return new ContainsKeyOperation(
-            codec, channelFactory, key, keyBytes, cacheNameBytes, topologyId, flags(), cfg);
+            codec, channelFactory, key, keyBytes, cacheNameBytes, topologyId, flags(), cfg, dataFormat);
    }
 
    public ClearOperation newClearOperation() {
@@ -166,17 +169,17 @@ public <K> BulkGetKeysOperation<K> newBulkGetKeysOperation(int scope) {
          codec, channelFactory, cacheNameBytes, topologyId, flags(), cfg, scope);
    }
 
-   public AddClientListenerOperation newAddClientListenerOperation(Object listener) {
+   public AddClientListenerOperation newAddClientListenerOperation(Object listener, DataFormat dataFormat) {
       return new AddClientListenerOperation(codec, channelFactory,
             cacheName, topologyId, flags(), cfg, listenerNotifier,
-            listener, null, null);
+            listener, null, null, dataFormat);
    }
 
    public AddClientListenerOperation newAddClientListenerOperation(
-         Object listener, byte[][] filterFactoryParams, byte[][] converterFactoryParams) {
+         Object listener, byte[][] filterFactoryParams, byte[][] converterFactoryParams, DataFormat dataFormat) {
       return new AddClientListenerOperation(codec, channelFactory,
             cacheName, topologyId, flags(), cfg, listenerNotifier,
-            listener, filterFactoryParams, converterFactoryParams);
+            listener, filterFactoryParams, converterFactoryParams, dataFormat);
    }
 
    public RemoveClientListenerOperation newRemoveClientListenerOperation(Object listener) {
@@ -251,7 +254,7 @@ public int flags() {
 
    public void setFlags(Flag[] flags) {
       int intFlags = 0;
-      for(Flag flag : flags)
+      for (Flag flag : flags)
          intFlags |= flag.getFlagInt();
       this.flagsMap.set(intFlags);
    }
@@ -269,16 +272,16 @@ public CacheTopologyInfo getCacheTopologyInfo() {
       return channelFactory.getCacheTopologyInfo(cacheNameBytes);
    }
 
-   public IterationStartOperation newIterationStartOperation(String filterConverterFactory, byte[][] filterParameters, Set<Integer> segments, int batchSize, boolean metadata) {
-      return new IterationStartOperation(codec, flags(), cfg, cacheNameBytes, topologyId, filterConverterFactory, filterParameters, segments, batchSize, channelFactory, metadata);
+   public IterationStartOperation newIterationStartOperation(String filterConverterFactory, byte[][] filterParameters, Set<Integer> segments, int batchSize, boolean metadata, DataFormat dataFormat) {
+      return new IterationStartOperation(codec, flags(), cfg, cacheNameBytes, topologyId, filterConverterFactory, filterParameters, segments, batchSize, channelFactory, metadata, dataFormat);
    }
 
    public IterationEndOperation newIterationEndOperation(byte[] iterationId, Channel channel) {
       return new IterationEndOperation(codec, flags(), cfg, cacheNameBytes, topologyId, iterationId, channelFactory, channel);
    }
 
-   public <E> IterationNextOperation<E> newIterationNextOperation(byte[] iterationId, Channel channel, KeyTracker segmentKeyTracker) {
-      return new IterationNextOperation(codec, flags(), cfg, cacheNameBytes, topologyId, iterationId, channel, channelFactory, segmentKeyTracker);
+   public <E> IterationNextOperation<E> newIterationNextOperation(byte[] iterationId, Channel channel, KeyTracker segmentKeyTracker, DataFormat dataFormat) {
+      return new IterationNextOperation(codec, flags(), cfg, cacheNameBytes, topologyId, iterationId, channel, channelFactory, segmentKeyTracker, dataFormat);
    }
 
    public <K> GetStreamOperation newGetStreamOperation(K key, byte[] keyBytes, int offset) {
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ParallelHotRodOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ParallelHotRodOperation.java
index 4f1ec795a5cf..e07d2ed1dd21 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ParallelHotRodOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ParallelHotRodOperation.java
@@ -4,6 +4,7 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
 import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;
@@ -20,8 +21,8 @@ public abstract class ParallelHotRodOperation<T, SUBOP extends HotRodOperation<T
    protected final ChannelFactory channelFactory;
 
    protected ParallelHotRodOperation(Codec codec, ChannelFactory channelFactory, byte[] cacheName, AtomicInteger
-         topologyId, int flags, Configuration cfg) {
-      super(ILLEGAL_OP_CODE, ILLEGAL_OP_CODE, codec, flags, cfg, cacheName, topologyId, channelFactory);
+         topologyId, int flags, Configuration cfg, DataFormat dataFormat) {
+      super(ILLEGAL_OP_CODE, ILLEGAL_OP_CODE, codec, flags, cfg, cacheName, topologyId, channelFactory, dataFormat);
       this.channelFactory = channelFactory;
    }
 
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutAllOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutAllOperation.java
index 7775caf4b32c..d6696531226b 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutAllOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutAllOperation.java
@@ -7,6 +7,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.exceptions.InvalidResponseException;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
@@ -31,8 +32,8 @@ public class PutAllOperation extends RetryOnFailureOperation<Void> {
    public PutAllOperation(Codec codec, ChannelFactory channelFactory,
                           Map<byte[], byte[]> map, byte[] cacheName, AtomicInteger topologyId,
                           int flags, Configuration cfg,
-                          long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit) {
-      super(PUT_ALL_REQUEST, PUT_ALL_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg);
+                          long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit, DataFormat dataFormat) {
+      super(PUT_ALL_REQUEST, PUT_ALL_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg, dataFormat);
       this.map = map;
       this.lifespan = lifespan;
       this.lifespanTimeUnit = lifespanTimeUnit;
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutAllParallelOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutAllParallelOperation.java
index 54b51ae36806..ade6a7a583ec 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutAllParallelOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutAllParallelOperation.java
@@ -8,6 +8,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.stream.Collectors;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
 import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;
@@ -26,8 +27,8 @@ public class PutAllParallelOperation extends ParallelHotRodOperation<Void, PutAl
    public PutAllParallelOperation(Codec codec, ChannelFactory channelFactory, Map<byte[], byte[]> map, byte[]
          cacheName, AtomicInteger topologyId, int flags, Configuration cfg, long lifespan,
                                   TimeUnit lifespanTimeUnit, long maxIdle,
-                                  TimeUnit maxIdleTimeUnit) {
-      super(codec, channelFactory, cacheName, topologyId, flags, cfg);
+                                  TimeUnit maxIdleTimeUnit, DataFormat dataFormat) {
+      super(codec, channelFactory, cacheName, topologyId, flags, cfg, dataFormat);
       this.map = map;
       this.lifespan = lifespan;
       this.lifespanTimeUnit = lifespanTimeUnit;
@@ -51,7 +52,7 @@ protected List<PutAllOperation> mapOperations() {
 
       return splittedMaps.values().stream().map(
             mapSubset -> new PutAllOperation(codec, channelFactory, mapSubset, cacheName, header.topologyId(), flags,
-                  cfg, lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit)).collect(Collectors.toList());
+                  cfg, lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit, dataFormat)).collect(Collectors.toList());
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutIfAbsentOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutIfAbsentOperation.java
index b42a33edc30d..b62196840dc4 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutIfAbsentOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutIfAbsentOperation.java
@@ -3,6 +3,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
 import org.infinispan.client.hotrod.impl.protocol.HotRodConstants;
@@ -31,9 +32,9 @@ public class PutIfAbsentOperation<V> extends AbstractKeyValueOperation<V> {
    public PutIfAbsentOperation(Codec codec, ChannelFactory channelFactory,
                                Object key, byte[] keyBytes, byte[] cacheName, AtomicInteger topologyId,
                                int flags, Configuration cfg, byte[] value, long lifespan,
-                               TimeUnit lifespanTimeUnit, long maxIdleTime, TimeUnit maxIdleTimeUnit) {
+                               TimeUnit lifespanTimeUnit, long maxIdleTime, TimeUnit maxIdleTimeUnit, DataFormat dataFormat) {
       super(PUT_IF_ABSENT_REQUEST, PUT_IF_ABSENT_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, value,
-            lifespan, lifespanTimeUnit, maxIdleTime, maxIdleTimeUnit);
+            lifespan, lifespanTimeUnit, maxIdleTime, maxIdleTimeUnit, dataFormat);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutOperation.java
index 90abc5c8a5d5..70e7796e3a94 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutOperation.java
@@ -3,6 +3,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.exceptions.InvalidResponseException;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
@@ -26,9 +27,9 @@ public class PutOperation<V> extends AbstractKeyValueOperation<V> {
    public PutOperation(Codec codec, ChannelFactory channelFactory,
                        Object key, byte[] keyBytes, byte[] cacheName, AtomicInteger topologyId,
                        int flags, Configuration cfg, byte[] value, long lifespan, TimeUnit lifespanTimeUnit,
-                       long maxIdle, TimeUnit maxIdleTimeUnit) {
+                       long maxIdle, TimeUnit maxIdleTimeUnit, DataFormat dataFormat) {
       super(PUT_REQUEST, PUT_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId,
-         flags, cfg, value, lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit);
+            flags, cfg, value, lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit, dataFormat);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutStreamOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutStreamOperation.java
index 5ebc4d3a9d39..d87a9d422add 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutStreamOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/PutStreamOperation.java
@@ -43,7 +43,7 @@ public PutStreamOperation(Codec codec, ChannelFactory channelFactory,
                              int flags, Configuration cfg, long version,
                              long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit) {
       super(PUT_STREAM_REQUEST, PUT_STREAM_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId,
-         flags, cfg);
+            flags, cfg, null);
       this.version = version;
       this.lifespan = lifespan;
       this.maxIdle = maxIdle;
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/QueryOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/QueryOperation.java
index 15f358c518c6..bb2b7b47aa7c 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/QueryOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/QueryOperation.java
@@ -36,7 +36,7 @@ public final class QueryOperation extends RetryOnFailureOperation<QueryResponse>
 
    public QueryOperation(Codec codec, ChannelFactory channelFactory, byte[] cacheName, AtomicInteger topologyId,
                          int flags, Configuration cfg, RemoteQuery remoteQuery) {
-      super(QUERY_REQUEST, QUERY_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg);
+      super(QUERY_REQUEST, QUERY_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg, null);
       this.remoteQuery = remoteQuery;
    }
 
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/RemoveIfUnmodifiedOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/RemoveIfUnmodifiedOperation.java
index 47e30c93f192..0cd6c3d3c158 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/RemoveIfUnmodifiedOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/RemoveIfUnmodifiedOperation.java
@@ -2,6 +2,7 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.VersionedOperationResponse;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
@@ -28,8 +29,8 @@ public class RemoveIfUnmodifiedOperation<V> extends AbstractKeyOperation<Version
    public RemoveIfUnmodifiedOperation(Codec codec, ChannelFactory channelFactory,
                                       Object key, byte[] keyBytes, byte[] cacheName, AtomicInteger topologyId,
                                       int flags, Configuration cfg,
-                                      long version) {
-      super(REMOVE_IF_UNMODIFIED_REQUEST, REMOVE_IF_UNMODIFIED_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg);
+                                      long version, DataFormat dataFormat) {
+      super(REMOVE_IF_UNMODIFIED_REQUEST, REMOVE_IF_UNMODIFIED_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, dataFormat.withoutValueType());
       this.version = version;
    }
 
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/RemoveOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/RemoveOperation.java
index f37722999851..395f6044dcc8 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/RemoveOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/RemoveOperation.java
@@ -2,6 +2,7 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
 import org.infinispan.client.hotrod.impl.protocol.HotRodConstants;
@@ -23,8 +24,8 @@
 public class RemoveOperation<V> extends AbstractKeyOperation<V> {
 
    public RemoveOperation(Codec codec, ChannelFactory channelFactory,
-                          Object key, byte[] keyBytes, byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg) {
-      super(REMOVE_REQUEST, REMOVE_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg);
+                          Object key, byte[] keyBytes, byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg, DataFormat dataFormat) {
+      super(REMOVE_REQUEST, REMOVE_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, dataFormat);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ReplaceIfUnmodifiedOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ReplaceIfUnmodifiedOperation.java
index 287f81d4d2bd..b6158d50d8c2 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ReplaceIfUnmodifiedOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ReplaceIfUnmodifiedOperation.java
@@ -3,6 +3,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.VersionedOperationResponse;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
@@ -25,8 +26,8 @@ public class ReplaceIfUnmodifiedOperation extends AbstractKeyValueOperation<Vers
 
    public ReplaceIfUnmodifiedOperation(Codec codec, ChannelFactory channelFactory, Object key, byte[] keyBytes, byte[] cacheName,
                                        AtomicInteger topologyId, int flags, Configuration cfg, byte[] value,
-                                       long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit, long version) {
-      super(REPLACE_IF_UNMODIFIED_REQUEST, REPLACE_IF_UNMODIFIED_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, value, lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit);
+                                       long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit, long version, DataFormat dataFormat) {
+      super(REPLACE_IF_UNMODIFIED_REQUEST, REPLACE_IF_UNMODIFIED_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, value, lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit, dataFormat);
       this.version = version;
    }
 
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ReplaceOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ReplaceOperation.java
index 2be4c5b02eca..58d98d32caa5 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ReplaceOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/ReplaceOperation.java
@@ -3,6 +3,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
 import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;
@@ -25,9 +26,9 @@ public class ReplaceOperation<V> extends AbstractKeyValueOperation<V> {
    public ReplaceOperation(Codec codec, ChannelFactory channelFactory,
                            Object key, byte[] keyBytes, byte[] cacheName, AtomicInteger topologyId,
                            int flags, Configuration cfg, byte[] value,
-                           long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit) {
+                           long lifespan, TimeUnit lifespanTimeUnit, long maxIdle, TimeUnit maxIdleTimeUnit, DataFormat dataFormat) {
       super(REPLACE_REQUEST, REPLACE_RESPONSE, codec, channelFactory, key, keyBytes, cacheName, topologyId, flags, cfg, value,
-            lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit);
+            lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit, dataFormat);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/RetryOnFailureOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/RetryOnFailureOperation.java
index 962c28a3a222..807239fa47fe 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/RetryOnFailureOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/RetryOnFailureOperation.java
@@ -7,6 +7,7 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.exceptions.HotRodClientException;
 import org.infinispan.client.hotrod.exceptions.RemoteIllegalLifecycleStateException;
@@ -44,8 +45,8 @@ public abstract class RetryOnFailureOperation<T> extends HotRodOperation<T> impl
    private String currentClusterName;
 
    protected RetryOnFailureOperation(short requestCode, short responseCode, Codec codec, ChannelFactory channelFactory,
-                                     byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg) {
-      super(requestCode, responseCode, codec, flags, cfg, cacheName, topologyId, channelFactory);
+                                     byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg, DataFormat dataFormat) {
+      super(requestCode, responseCode, codec, flags, cfg, cacheName, topologyId, channelFactory, dataFormat);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/SizeOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/SizeOperation.java
index 68c225cbda4e..b65939c51fcb 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/SizeOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/SizeOperation.java
@@ -15,7 +15,7 @@ public class SizeOperation extends RetryOnFailureOperation<Integer> {
 
    protected SizeOperation(Codec codec, ChannelFactory channelFactory,
                            byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg) {
-      super(SIZE_REQUEST, SIZE_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg);
+      super(SIZE_REQUEST, SIZE_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg, null);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/StatsOperation.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/StatsOperation.java
index 402eab454278..061b530442f2 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/StatsOperation.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/operations/StatsOperation.java
@@ -7,8 +7,8 @@
 import org.infinispan.client.hotrod.configuration.Configuration;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
 import org.infinispan.client.hotrod.impl.transport.netty.ByteBufUtil;
-import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;
 import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;
+import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
@@ -27,7 +27,7 @@ public class StatsOperation extends RetryOnFailureOperation<Map<String, String>>
 
    public StatsOperation(Codec codec, ChannelFactory channelFactory,
                          byte[] cacheName, AtomicInteger topologyId, int flags, Configuration cfg) {
-      super(STATS_REQUEST, STATS_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg);
+      super(STATS_REQUEST, STATS_RESPONSE, codec, channelFactory, cacheName, topologyId, flags, cfg, null);
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec.java
index 5ca51a62348f..968d8d5eda5f 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec.java
@@ -6,7 +6,9 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
+import java.util.function.Function;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.RemoteCache;
 import org.infinispan.client.hotrod.annotation.ClientListener;
 import org.infinispan.client.hotrod.counter.impl.HotRodCounterEvent;
@@ -58,7 +60,7 @@ void writeClientListenerParams(ByteBuf buf, ClientListener clientListener,
     */
    short readHeader(ByteBuf buf, double receivedOpCode, HeaderParams params, ChannelFactory channelFactory, SocketAddress serverAddress);
 
-   AbstractClientEvent readCacheEvent(ByteBuf buf, Marshaller marshaller, short eventTypeId, List<String> whitelist, SocketAddress serverAddress);
+   AbstractClientEvent readCacheEvent(ByteBuf buf, Function<byte[], DataFormat> listenerDataFormat, short eventTypeId, List<String> whitelist, SocketAddress serverAddress);
 
    Object returnPossiblePrevValue(ByteBuf buf, short status, int flags, List<String> whitelist, Marshaller marshaller);
 
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec10.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec10.java
index 8efce008dd09..563ffdce845a 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec10.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec10.java
@@ -10,7 +10,9 @@
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Function;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.Flag;
 import org.infinispan.client.hotrod.annotation.ClientListener;
 import org.infinispan.client.hotrod.counter.impl.HotRodCounterEvent;
@@ -145,7 +147,7 @@ public short readHeader(ByteBuf buf, double receivedOpCode, HeaderParams params,
    }
 
    @Override
-   public AbstractClientEvent readCacheEvent(ByteBuf buf, Marshaller marshaller, short eventTypeId, List<String> whitelist, SocketAddress serverAddress) {
+   public AbstractClientEvent readCacheEvent(ByteBuf buf, Function<byte[], DataFormat> dataFormatFunction, short eventTypeId, List<String> whitelist, SocketAddress serverAddress) {
       return null;  // No events sent in Hot Rod 1.x protocol
    }
 
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec20.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec20.java
index d438dd3c853e..6882f5a99257 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec20.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec20.java
@@ -11,7 +11,9 @@
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
+import java.util.function.Function;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.RemoteCache;
 import org.infinispan.client.hotrod.annotation.ClientListener;
 import org.infinispan.client.hotrod.configuration.ClientIntelligence;
@@ -32,7 +34,6 @@
 import org.infinispan.client.hotrod.impl.transport.netty.ChannelFactory;
 import org.infinispan.client.hotrod.logging.Log;
 import org.infinispan.client.hotrod.logging.LogFactory;
-import org.infinispan.client.hotrod.marshall.MarshallerUtil;
 import org.infinispan.commons.marshall.Marshaller;
 import org.infinispan.commons.util.CloseableIterator;
 import org.infinispan.commons.util.Closeables;
@@ -69,7 +70,7 @@ public HeaderParams writeHeader(ByteBuf buf, HeaderParams params) {
    @Override
    public void writeClientListenerParams(ByteBuf buf, ClientListener clientListener,
                                          byte[][] filterFactoryParams, byte[][] converterFactoryParams) {
-      buf.writeByte((short)(clientListener.includeCurrentState() ? 1 : 0));
+      buf.writeByte((short) (clientListener.includeCurrentState() ? 1 : 0));
       writeNamedFactory(buf, clientListener.filterFactoryName(), filterFactoryParams);
       writeNamedFactory(buf, clientListener.converterFactoryName(), converterFactoryParams);
    }
@@ -124,7 +125,7 @@ protected HeaderParams writeHeader(
 
       if (trace)
          getLog().tracef("[%s] Wrote header for messageId=%d to %s. Operation code: %#04x(%s). Flags: %#x. Topology id: %s",
-            new String(params.cacheName), params.messageId, buf, params.opCode,
+               new String(params.cacheName), params.messageId, buf, params.opCode,
                Names.of(params.opCode), joinedFlags, topologyId);
 
       return params;
@@ -170,7 +171,7 @@ public short readHeader(ByteBuf buf, double receivedOpCode, HeaderParams params,
       readNewTopologyIfPresent(buf, params, channelFactory);
 
       // Now that all headers values have been read, check the error responses.
-      // This avoids situatations where an exceptional return ends up with
+      // This avoids situations where an exceptional return ends up with
       // the socket containing data from previous request responses.
       if (receivedOpCode != params.opRespCode) {
          if (receivedOpCode == HotRodConstants.ERROR_RESPONSE) {
@@ -233,7 +234,7 @@ public <K> CloseableIterator<K> keyIterator(RemoteCache<K, ?> remoteCache, Opera
    }
 
    @Override
-   public AbstractClientEvent readCacheEvent(ByteBuf buf, Marshaller marshaller, short eventTypeId, List<String> whitelist, SocketAddress serverAddress) {
+   public AbstractClientEvent readCacheEvent(ByteBuf buf, Function<byte[], DataFormat> listenerDataFormat, short eventTypeId, List<String> whitelist, SocketAddress serverAddress) {
       short status = buf.readUnsignedByte();
       buf.readUnsignedByte(); // ignore, no topology expected
       ClientEvent.Type eventType;
@@ -257,24 +258,21 @@ public AbstractClientEvent readCacheEvent(ByteBuf buf, Marshaller marshaller, sh
       byte[] listenerId = ByteBufUtil.readArray(buf);
 
       short isCustom = buf.readUnsignedByte();
-      boolean isRetried = buf.readUnsignedByte() == 1 ? true : false;
-
+      boolean isRetried = buf.readUnsignedByte() == 1;
+      DataFormat dataFormat = listenerDataFormat.apply(listenerId);
       if (isCustom == 1) {
-         final Object eventData = MarshallerUtil.bytes2obj(marshaller, ByteBufUtil.readArray(buf), status, whitelist);
+         final Object eventData = dataFormat.valueToObj(ByteBufUtil.readArray(buf), status, whitelist);
          return createCustomEvent(listenerId, eventData, eventType, isRetried);
       } else {
          switch (eventType) {
             case CLIENT_CACHE_ENTRY_CREATED:
-               Object createdKey = MarshallerUtil.bytes2obj(marshaller, ByteBufUtil.readArray(buf), status, whitelist);
                long createdDataVersion = buf.readLong();
-               return createCreatedEvent(listenerId, createdKey, createdDataVersion, isRetried);
+               return createCreatedEvent(listenerId, dataFormat.keyToObj(ByteBufUtil.readArray(buf), status, whitelist), createdDataVersion, isRetried);
             case CLIENT_CACHE_ENTRY_MODIFIED:
-               Object modifiedKey = MarshallerUtil.bytes2obj(marshaller, ByteBufUtil.readArray(buf), status, whitelist);
                long modifiedDataVersion = buf.readLong();
-               return createModifiedEvent(listenerId, modifiedKey, modifiedDataVersion, isRetried);
+               return createModifiedEvent(listenerId, dataFormat.keyToObj(ByteBufUtil.readArray(buf), status, whitelist), modifiedDataVersion, isRetried);
             case CLIENT_CACHE_ENTRY_REMOVED:
-               Object removedKey = MarshallerUtil.bytes2obj(marshaller, ByteBufUtil.readArray(buf), status, whitelist);
-               return createRemovedEvent(listenerId, removedKey, isRetried);
+               return createRemovedEvent(listenerId, dataFormat.keyToObj(ByteBufUtil.readArray(buf), status, whitelist), isRetried);
             default:
                throw log.unknownEvent(eventTypeId);
          }
@@ -341,7 +339,7 @@ protected void checkForErrorsInResponseStatus(ByteBuf buf, HeaderParams params,
                msgFromServer = ByteBufUtil.readString(buf);
                if (trace)
                   localLog.tracef("[%s] A remote node was suspected while executing messageId=%d. " +
-                        "Check if retry possible. Message from server: %s",
+                              "Check if retry possible. Message from server: %s",
                         new String(params.cacheName), params.messageId, msgFromServer);
 
                throw new RemoteNodeSuspectException(msgFromServer, params.messageId, status);
@@ -408,7 +406,7 @@ protected void readNewTopologyAndHash(ByteBuf buf, HeaderParams params, ChannelF
          List<SocketAddress> addressList = Arrays.asList(addresses);
          if (localLog.isInfoEnabled()) {
             localLog.newTopology(newTopologyId, topologyAge,
-               addresses.length, new HashSet<>(addressList));
+                  addresses.length, new HashSet<>(addressList));
          }
          channelFactory.updateServers(addressList, params.cacheName, false);
          if (hashFunctionVersion >= 0) {
@@ -425,7 +423,7 @@ protected void readNewTopologyAndHash(ByteBuf buf, HeaderParams params, ChannelF
       } else {
          if (trace)
             localLog.tracef("[%s] Outdated topology received (topology id = %s, topology age = %s), so ignoring it: %s",
-               new String(params.cacheName), newTopologyId, topologyAge, Arrays.toString(addresses));
+                  new String(params.cacheName), newTopologyId, topologyAge, Arrays.toString(addresses));
       }
    }
 
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec21.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec21.java
index d3299e9c1b1d..57f13843ad2f 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec21.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec21.java
@@ -2,7 +2,9 @@
 
 import java.net.SocketAddress;
 import java.util.List;
+import java.util.function.Function;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.annotation.ClientListener;
 import org.infinispan.client.hotrod.event.ClientEvent;
 import org.infinispan.client.hotrod.event.impl.AbstractClientEvent;
@@ -10,8 +12,6 @@
 import org.infinispan.client.hotrod.impl.transport.netty.ByteBufUtil;
 import org.infinispan.client.hotrod.logging.Log;
 import org.infinispan.client.hotrod.logging.LogFactory;
-import org.infinispan.client.hotrod.marshall.MarshallerUtil;
-import org.infinispan.commons.marshall.Marshaller;
 
 import io.netty.buffer.ByteBuf;
 
@@ -36,7 +36,7 @@ public void writeClientListenerParams(ByteBuf buf, ClientListener clientListener
    }
 
    @Override
-   public AbstractClientEvent readCacheEvent(ByteBuf buf, Marshaller marshaller, short eventTypeId, List<String> whitelist, SocketAddress serverAddress) {
+   public AbstractClientEvent readCacheEvent(ByteBuf buf, Function<byte[], DataFormat> listenerDataFormat, short eventTypeId, List<String> whitelist, SocketAddress serverAddress) {
       short status = buf.readUnsignedByte();
       buf.readUnsignedByte(); // ignore, no topology expected
       ClientEvent.Type eventType;
@@ -61,28 +61,29 @@ public AbstractClientEvent readCacheEvent(ByteBuf buf, Marshaller marshaller, sh
 
       byte[] listenerId = ByteBufUtil.readArray(buf);
       short isCustom = buf.readUnsignedByte();
-      boolean isRetried = buf.readUnsignedByte() == 1 ? true : false;
+      boolean isRetried = buf.readUnsignedByte() == 1;
+      DataFormat dataFormat = listenerDataFormat.apply(listenerId);
 
       if (isCustom == 1) {
-         final Object eventData = MarshallerUtil.bytes2obj(marshaller, ByteBufUtil.readArray(buf), status, whitelist);
+         final Object eventData = dataFormat.valueToObj(ByteBufUtil.readArray(buf), status, whitelist);
          return createCustomEvent(listenerId, eventData, eventType, isRetried);
       } else if (isCustom == 2) { // New in 2.1, dealing with raw custom events
          return createCustomEvent(listenerId, ByteBufUtil.readArray(buf), eventType, isRetried); // Raw data
       } else {
          switch (eventType) {
             case CLIENT_CACHE_ENTRY_CREATED:
-               Object createdKey = MarshallerUtil.bytes2obj(marshaller, ByteBufUtil.readArray(buf), status, whitelist);
+               Object createdKey = dataFormat.keyToObj(ByteBufUtil.readArray(buf), status, whitelist);
                long createdDataVersion = buf.readLong();
                return createCreatedEvent(listenerId, createdKey, createdDataVersion, isRetried);
             case CLIENT_CACHE_ENTRY_MODIFIED:
-               Object modifiedKey = MarshallerUtil.bytes2obj(marshaller, ByteBufUtil.readArray(buf), status, whitelist);
+               Object modifiedKey = dataFormat.keyToObj(ByteBufUtil.readArray(buf), status, whitelist);
                long modifiedDataVersion = buf.readLong();
                return createModifiedEvent(listenerId, modifiedKey, modifiedDataVersion, isRetried);
             case CLIENT_CACHE_ENTRY_REMOVED:
-               Object removedKey = MarshallerUtil.bytes2obj(marshaller, ByteBufUtil.readArray(buf), status, whitelist);
+               Object removedKey = dataFormat.keyToObj(ByteBufUtil.readArray(buf), status, whitelist);
                return createRemovedEvent(listenerId, removedKey, isRetried);
             case CLIENT_CACHE_ENTRY_EXPIRED:
-               Object expiredKey = MarshallerUtil.bytes2obj(marshaller, ByteBufUtil.readArray(buf), status, whitelist);
+               Object expiredKey = dataFormat.keyToObj(ByteBufUtil.readArray(buf), status, whitelist);
                return createExpiredEvent(listenerId, expiredKey);
             default:
                throw getLog().unknownEvent(eventTypeId);
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec28.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec28.java
index c84fbfe74eb1..0cf6cd1ac52a 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec28.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/Codec28.java
@@ -1,14 +1,55 @@
 package org.infinispan.client.hotrod.impl.protocol;
 
+import java.util.Map;
+
+import org.infinispan.client.hotrod.DataFormat;
+import org.infinispan.client.hotrod.impl.transport.netty.ByteBufUtil;
+import org.infinispan.commons.dataconversion.MediaType;
+import org.infinispan.commons.dataconversion.MediaTypeIds;
+
 import io.netty.buffer.ByteBuf;
 
 /**
  * @since 9.3
  */
 public class Codec28 extends Codec27 {
+
    @Override
    public HeaderParams writeHeader(ByteBuf buf, HeaderParams params) {
-      return writeHeader(buf, params, HotRodConstants.VERSION_28);
+      HeaderParams headerParams = writeHeader(buf, params, HotRodConstants.VERSION_28);
+      writeDataTypes(buf, params.dataFormat);
+      return headerParams;
+   }
+
+   private void writeDataTypes(ByteBuf buf, DataFormat dataFormat) {
+      MediaType keyType = null, valueType = null;
+      if (dataFormat != null) {
+         keyType = dataFormat.getKeyType();
+         valueType = dataFormat.getValueType();
+      }
+      writeMediaType(buf, keyType);
+      writeMediaType(buf, valueType);
+   }
+
+   private void writeMediaType(ByteBuf buf, MediaType mediaType) {
+      if (mediaType == null) {
+         buf.writeByte(0);
+      } else {
+         Short id = MediaTypeIds.getId(mediaType.toString());
+         if (id != null) {
+            buf.writeByte(1);
+            ByteBufUtil.writeVInt(buf, id);
+         } else {
+            buf.writeByte(2);
+            ByteBufUtil.writeString(buf, mediaType.toString());
+         }
+         Map<String, String> parameters = mediaType.getParameters();
+         ByteBufUtil.writeVInt(buf, parameters.size());
+         parameters.forEach((key, value) -> {
+            ByteBufUtil.writeString(buf, key);
+            ByteBufUtil.writeString(buf, value);
+         });
+      }
    }
 
    @Override
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/HeaderParams.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/HeaderParams.java
index ac711339b2fc..d9a0c6d3a464 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/HeaderParams.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/HeaderParams.java
@@ -2,6 +2,7 @@
 
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.configuration.ClientIntelligence;
 
 /**
@@ -20,6 +21,7 @@ public class HeaderParams {
    AtomicInteger topologyId;
    final long messageId;
    int topologyAge;
+   DataFormat dataFormat;
 
    public HeaderParams(short requestCode, short responseCode, long messageId) {
       opCode = requestCode;
@@ -64,4 +66,10 @@ public HeaderParams topologyAge(int topologyAge) {
       this.topologyAge = topologyAge;
       return this;
    }
+
+   public HeaderParams dataFormat(DataFormat dataFormat) {
+      this.dataFormat = dataFormat;
+      return this;
+   }
+
 }
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/HotRodConstants.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/HotRodConstants.java
index 527cacd40d4b..4ba3177b8fd4 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/HotRodConstants.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/protocol/HotRodConstants.java
@@ -143,23 +143,25 @@ public interface HotRodConstants {
    int NODE_SUSPECTED = 0x87;
    int ILLEGAL_LIFECYCLE_STATE = 0x88;
 
-   @Deprecated
    /**
     * @deprecated use {@link org.infinispan.client.hotrod.configuration.ClientIntelligence#BASIC}
     * instead
     */
-   byte CLIENT_INTELLIGENCE_BASIC = 0x01;
    @Deprecated
+   byte CLIENT_INTELLIGENCE_BASIC = 0x01;
+
    /**
     * @deprecated use {@link org.infinispan.client.hotrod.configuration.ClientIntelligence#TOPOLOGY_AWARE}
     * instead
     */
-   byte CLIENT_INTELLIGENCE_TOPOLOGY_AWARE = 0x02;
    @Deprecated
+   byte CLIENT_INTELLIGENCE_TOPOLOGY_AWARE = 0x02;
+
    /**
     * @deprecated use {@link org.infinispan.client.hotrod.configuration.ClientIntelligence#HASH_DISTRIBUTION_AWARE}
     * instead
     */
+   @Deprecated
    byte CLIENT_INTELLIGENCE_HASH_DISTRIBUTION_AWARE = 0x03;
    Charset HOTROD_STRING_CHARSET = Charset.forName("UTF-8");
 
@@ -173,15 +175,15 @@ public interface HotRodConstants {
 
    static boolean isSuccess(int status) {
       return status == NO_ERROR_STATUS
-         || status == NO_ERROR_STATUS_COMPAT
-         || status == SUCCESS_WITH_PREVIOUS
-         || status == SUCCESS_WITH_PREVIOUS_COMPAT;
+            || status == NO_ERROR_STATUS_COMPAT
+            || status == SUCCESS_WITH_PREVIOUS
+            || status == SUCCESS_WITH_PREVIOUS_COMPAT;
    }
 
    static boolean isNotExecuted(int status) {
       return status == NOT_PUT_REMOVED_REPLACED_STATUS
-         || status == NOT_EXECUTED_WITH_PREVIOUS
-         || status == NOT_EXECUTED_WITH_PREVIOUS_COMPAT;
+            || status == NOT_EXECUTED_WITH_PREVIOUS
+            || status == NOT_EXECUTED_WITH_PREVIOUS_COMPAT;
    }
 
    static boolean isNotExist(int status) {
@@ -190,15 +192,15 @@ static boolean isNotExist(int status) {
 
    static boolean hasPrevious(int status) {
       return status == SUCCESS_WITH_PREVIOUS
-         || status == SUCCESS_WITH_PREVIOUS_COMPAT
-         || status == NOT_EXECUTED_WITH_PREVIOUS
-         || status == NOT_EXECUTED_WITH_PREVIOUS_COMPAT;
+            || status == SUCCESS_WITH_PREVIOUS_COMPAT
+            || status == NOT_EXECUTED_WITH_PREVIOUS
+            || status == NOT_EXECUTED_WITH_PREVIOUS_COMPAT;
    }
 
    static boolean hasCompatibility(short status) {
       return status == NO_ERROR_STATUS_COMPAT
-         || status == SUCCESS_WITH_PREVIOUS_COMPAT
-         || status == NOT_EXECUTED_WITH_PREVIOUS_COMPAT;
+            || status == SUCCESS_WITH_PREVIOUS_COMPAT
+            || status == NOT_EXECUTED_WITH_PREVIOUS_COMPAT;
    }
 
    static boolean isInvalidIteration(short status) {
@@ -208,7 +210,8 @@ static boolean isInvalidIteration(short status) {
    final class Names {
       static final String[] NAMES;
 
-      private Names() {}
+      private Names() {
+      }
 
       static {
          Predicate<Field> filterRequestsResponses =
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/transport/netty/ChannelFactory.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/transport/netty/ChannelFactory.java
index a977b807563b..14ffbafca6db 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/transport/netty/ChannelFactory.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/transport/netty/ChannelFactory.java
@@ -21,10 +21,10 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
-import java.util.concurrent.TimeUnit;
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.stream.Collectors;
@@ -36,6 +36,7 @@
 import org.infinispan.client.hotrod.configuration.ServerConfiguration;
 import org.infinispan.client.hotrod.event.impl.ClientListenerNotifier;
 import org.infinispan.client.hotrod.impl.ConfigurationProperties;
+import org.infinispan.client.hotrod.impl.MarshallerRegistry;
 import org.infinispan.client.hotrod.impl.TopologyInfo;
 import org.infinispan.client.hotrod.impl.consistenthash.ConsistentHash;
 import org.infinispan.client.hotrod.impl.consistenthash.ConsistentHashFactory;
@@ -94,9 +95,12 @@ public class ChannelFactory {
    // updates won't be allowed to apply since they refer to older views.
    private final AtomicInteger topologyAge = new AtomicInteger(0);
 
+   private MarshallerRegistry marshallerRegistry;
+
    public void start(Codec codec, Configuration configuration, AtomicInteger defaultCacheTopologyId,
                      Marshaller marshaller, ExecutorService executorService,
-                     ClientListenerNotifier listenerNotifier, Collection<Consumer<Set<SocketAddress>>> failedServerNotifier) {
+                     ClientListenerNotifier listenerNotifier, Collection<Consumer<Set<SocketAddress>>> failedServerNotifier, MarshallerRegistry marshallerRegistry) {
+      this.marshallerRegistry = marshallerRegistry;
       lock.writeLock().lock();
       try {
          this.marshaller = marshaller;
@@ -155,6 +159,10 @@ private int maxAsyncThreads(ExecutorService executorService, Configuration confi
       return new ConfigurationProperties(configuration.asyncExecutorFactory().properties()).getDefaultExecutorFactoryPoolSize();
    }
 
+   public MarshallerRegistry getMarshallerRegistry() {
+      return marshallerRegistry;
+   }
+
    private ChannelPool newPool(SocketAddress address) {
       log.debugf("Creating new channel pool for %s", address);
       Bootstrap bootstrap = new Bootstrap()
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/transport/netty/HeaderDecoder.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/transport/netty/HeaderDecoder.java
index 201a2e41bb72..df496aa05831 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/transport/netty/HeaderDecoder.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/transport/netty/HeaderDecoder.java
@@ -150,7 +150,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
                }
                AbstractClientEvent cacheEvent;
                try {
-                  cacheEvent = codec.readCacheEvent(in, channelFactory.getMarshaller(),
+                  cacheEvent = codec.readCacheEvent(in, listenerNotifier::getCacheDataFormat,
                         receivedOpCode, configuration.serialWhitelist(), ctx.channel().remoteAddress());
                } catch (Signal signal) {
                   throw signal;
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/logging/Log.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/logging/Log.java
index 8ccd4768b8dd..0594b73a5699 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/logging/Log.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/logging/Log.java
@@ -288,4 +288,7 @@ public interface Log extends BasicLogger {
 
    @Message(value = "Event should use messageId of previous Add Client Listener operation but id is %d and operation is %s", id = 4080)
    IllegalStateException operationIsNotAddClientListener(long messageId, String operation);
+
+   @Message(value = "The client listener must be configured with useRawData=true when using a custom data format", id = 4081)
+   IncorrectClientListenerException clientListenerMustUseRawDataWithCustomDataFormat();
 }
diff --git a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/marshall/MarshallerUtil.java b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/marshall/MarshallerUtil.java
index 44972dc1391e..0b7de16c3166 100644
--- a/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/marshall/MarshallerUtil.java
+++ b/client/hotrod-client/src/main/java/org/infinispan/client/hotrod/marshall/MarshallerUtil.java
@@ -24,7 +24,8 @@ public final class MarshallerUtil {
 
    private static final Log log = LogFactory.getLog(MarshallerUtil.class, Log.class);
 
-   private MarshallerUtil() {}
+   private MarshallerUtil() {
+   }
 
    @SuppressWarnings("unchecked")
    public static <T> T bytes2obj(Marshaller marshaller, byte[] bytes, short status, List<String> whitelist) {
@@ -71,10 +72,6 @@ private static boolean isJavaSerialized(byte[] bytes) {
       return false;
    }
 
-   static short getShort(byte[] b, int off) {
-      return (short) ((b[off + 1] & 0xFF) + (b[off] << 8));
-   }
-
    public static byte[] obj2bytes(Marshaller marshaller, Object o, boolean isKey, int estimateKeySize, int estimateValueSize) {
       try {
          return marshaller.objectToByteBuffer(o, isKey ? estimateKeySize : estimateValueSize);
diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/HotRodQueryIspnDirectoryTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/HotRodQueryIspnDirectoryTest.java
index a7e0a4abfeea..80b4e990327c 100644
--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/HotRodQueryIspnDirectoryTest.java
+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/query/HotRodQueryIspnDirectoryTest.java
@@ -1,5 +1,13 @@
 package org.infinispan.client.hotrod.query;
 
+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;
+import static org.testng.AssertJUnit.assertEquals;
+
+import org.codehaus.jackson.JsonNode;
+import org.codehaus.jackson.map.ObjectMapper;
+import org.infinispan.client.hotrod.DataFormat;
+import org.infinispan.client.hotrod.RemoteCache;
+import org.infinispan.commons.marshall.UTF8StringMarshaller;
 import org.infinispan.configuration.cache.ConfigurationBuilder;
 import org.testng.annotations.Test;
 
@@ -18,4 +26,14 @@ protected ConfigurationBuilder getConfigurationBuilder() {
       builder.indexing().addProperty("default.directory_provider", "infinispan");
       return builder;
    }
+
+   public void testReadAsJSON() throws Exception {
+      DataFormat acceptJSON = DataFormat.builder().valueType(APPLICATION_JSON).valueMarshaller(new UTF8StringMarshaller()).build();
+      RemoteCache<Integer, String> jsonCache = this.remoteCache.withDataFormat(acceptJSON);
+
+      JsonNode user1 = new ObjectMapper().readTree(jsonCache.get(1));
+
+      assertEquals("Tom", user1.get("name").asText());
+      assertEquals("Cat", user1.get("surname").asText());
+   }
 }
diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/retry/ClientListenerRetryTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/retry/ClientListenerRetryTest.java
index 9c101b69dad3..6e07e7884688 100644
--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/retry/ClientListenerRetryTest.java
+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/retry/ClientListenerRetryTest.java
@@ -8,8 +8,10 @@
 import java.net.SocketAddress;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Function;
 import java.util.stream.IntStream;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.RemoteCache;
 import org.infinispan.client.hotrod.annotation.ClientCacheEntryCreated;
 import org.infinispan.client.hotrod.annotation.ClientListener;
@@ -19,7 +21,6 @@
 import org.infinispan.client.hotrod.exceptions.TransportException;
 import org.infinispan.client.hotrod.impl.protocol.Codec25;
 import org.infinispan.client.hotrod.test.MultiHotRodServersTest;
-import org.infinispan.commons.marshall.Marshaller;
 import org.infinispan.configuration.cache.CacheMode;
 import org.infinispan.configuration.cache.ConfigurationBuilder;
 import org.testng.annotations.Test;
@@ -105,11 +106,11 @@ private static class FailureInducingCodec extends Codec25 {
       private final IOException failWith = new IOException("Connection reset by peer");
 
       @Override
-      public AbstractClientEvent readCacheEvent(ByteBuf buf, Marshaller marshaller, short eventTypeId, List<String> whitelist, SocketAddress serverAddress) {
+      public AbstractClientEvent readCacheEvent(ByteBuf buf, Function<byte[], DataFormat> listenerDataFormat, short eventTypeId, List<String> whitelist, SocketAddress serverAddress) {
          if (failure) {
             throw new TransportException(failWith, serverAddress);
          }
-         return super.readCacheEvent(buf, marshaller, eventTypeId, whitelist, serverAddress);
+         return super.readCacheEvent(buf, listenerDataFormat, eventTypeId, whitelist, serverAddress);
       }
 
       private void induceFailure() {
diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/retry/RetryOnFailureUnitTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/retry/RetryOnFailureUnitTest.java
index 9cb8de3bc413..550fff76f37a 100644
--- a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/retry/RetryOnFailureUnitTest.java
+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/retry/RetryOnFailureUnitTest.java
@@ -95,7 +95,7 @@ private class MockOperation extends RetryOnFailureOperation<Void> {
       private final boolean failOnTransport;
 
       MockOperation(ChannelFactory channelFactory, boolean failOnTransport) {
-         super(ILLEGAL_OP_CODE, ILLEGAL_OP_CODE, null, channelFactory, null, null, 0, new ConfigurationBuilder().build());
+         super(ILLEGAL_OP_CODE, ILLEGAL_OP_CODE, null, channelFactory, null, null, 0, new ConfigurationBuilder().build(), null);
          this.failOnTransport = failOnTransport;
          channelInvocationCount = new AtomicInteger(0);
          executeInvocationCount = new AtomicInteger(0);
diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/transcoding/DataFormatIndexedTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/transcoding/DataFormatIndexedTest.java
new file mode 100644
index 000000000000..f9c458515ffb
--- /dev/null
+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/transcoding/DataFormatIndexedTest.java
@@ -0,0 +1,21 @@
+package org.infinispan.client.hotrod.transcoding;
+
+import org.infinispan.configuration.cache.ConfigurationBuilder;
+import org.infinispan.configuration.cache.Index;
+import org.testng.annotations.Test;
+
+/**
+ * Tests for the Hot Rod client using multiple data formats with indexing enabled
+ *
+ * @since 9.3
+ */
+@Test(groups = "functional", testName = "client.hotrod.transcoding.DataFormatIndexedTest")
+public class DataFormatIndexedTest extends DataFormatTest {
+
+   @Override
+   protected ConfigurationBuilder buildCacheConfig() {
+      ConfigurationBuilder parentBuilder = super.buildCacheConfig();
+      parentBuilder.indexing().index(Index.PRIMARY_OWNER).addProperty("default.directory_provider", "local-heap");
+      return parentBuilder;
+   }
+}
diff --git a/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/transcoding/DataFormatTest.java b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/transcoding/DataFormatTest.java
new file mode 100644
index 000000000000..5c6bd66967ac
--- /dev/null
+++ b/client/hotrod-client/src/test/java/org/infinispan/client/hotrod/transcoding/DataFormatTest.java
@@ -0,0 +1,405 @@
+package org.infinispan.client.hotrod.transcoding;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.infinispan.client.hotrod.test.HotRodClientTestingUtil.withClientListener;
+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JBOSS_MARSHALLING;
+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;
+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN;
+import static org.infinispan.server.hotrod.test.HotRodTestingUtil.hotRodCacheConfiguration;
+import static org.infinispan.test.fwk.TestCacheManagerFactory.createServerModeCacheManager;
+import static org.testng.Assert.assertTrue;
+import static org.testng.AssertJUnit.assertEquals;
+import static org.testng.AssertJUnit.assertFalse;
+import static org.testng.internal.junit.ArrayAsserts.assertArrayEquals;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.net.InetSocketAddress;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import java.util.UUID;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+
+import org.codehaus.jackson.map.ObjectMapper;
+import org.codehaus.jackson.node.TextNode;
+import org.infinispan.client.hotrod.DataFormat;
+import org.infinispan.client.hotrod.MetadataValue;
+import org.infinispan.client.hotrod.RemoteCache;
+import org.infinispan.client.hotrod.RemoteCacheManager;
+import org.infinispan.client.hotrod.annotation.ClientListener;
+import org.infinispan.client.hotrod.event.EventLogListener;
+import org.infinispan.client.hotrod.event.EventLogListener.StaticFilteredEventLogListener;
+import org.infinispan.client.hotrod.event.IncorrectClientListenerException;
+import org.infinispan.client.hotrod.test.HotRodClientTestingUtil;
+import org.infinispan.client.hotrod.test.SingleHotRodServerTest;
+import org.infinispan.commons.dataconversion.MediaType;
+import org.infinispan.commons.io.ByteBuffer;
+import org.infinispan.commons.io.ByteBufferImpl;
+import org.infinispan.commons.marshall.AbstractMarshaller;
+import org.infinispan.commons.marshall.IdentityMarshaller;
+import org.infinispan.commons.marshall.UTF8StringMarshaller;
+import org.infinispan.configuration.cache.ConfigurationBuilder;
+import org.infinispan.filter.NamedFactory;
+import org.infinispan.manager.EmbeddedCacheManager;
+import org.infinispan.marshall.core.ExternallyMarshallable;
+import org.infinispan.metadata.Metadata;
+import org.infinispan.notifications.cachelistener.filter.CacheEventFilter;
+import org.infinispan.notifications.cachelistener.filter.CacheEventFilterFactory;
+import org.infinispan.notifications.cachelistener.filter.EventType;
+import org.infinispan.server.hotrod.HotRodServer;
+import org.infinispan.server.hotrod.configuration.HotRodServerConfigurationBuilder;
+import org.testng.annotations.Test;
+
+/**
+ * Tests for the Hot Rod client using multiple data formats when interacting with the server.
+ *
+ * @since 9.3
+ */
+@Test(groups = "functional", testName = "client.hotrod.transcoding.DataFormatTest")
+public class DataFormatTest extends SingleHotRodServerTest {
+
+   private static final String CACHE_NAME = "test";
+   private RemoteCache<Object, Object> remoteCache;
+
+   public DataFormatTest() {
+      ExternallyMarshallable.addToWhiteList(ComplexKey.class.getName());
+   }
+
+   protected ConfigurationBuilder buildCacheConfig() {
+      ConfigurationBuilder builder = new ConfigurationBuilder();
+      builder.encoding().key().mediaType(MediaType.APPLICATION_JBOSS_MARSHALLING_TYPE);
+      builder.encoding().value().mediaType(MediaType.APPLICATION_JBOSS_MARSHALLING_TYPE);
+      return builder;
+   }
+
+   @Override
+   protected EmbeddedCacheManager createCacheManager() throws Exception {
+      cacheManager = createServerModeCacheManager(hotRodCacheConfiguration());
+      ConfigurationBuilder builder = buildCacheConfig();
+
+      cacheManager.defineConfiguration(CACHE_NAME, hotRodCacheConfiguration(builder).build());
+      return cacheManager;
+   }
+
+   @Override
+   protected HotRodServer createHotRodServer() {
+      HotRodServer server = HotRodClientTestingUtil.startHotRodServer(cacheManager, new HotRodServerConfigurationBuilder());
+      server.addCacheEventFilterFactory("raw-filter-factory", new RawFilterFactory());
+      return server;
+   }
+
+   @Override
+   protected void setup() throws Exception {
+      super.setup();
+      org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder =
+            new org.infinispan.client.hotrod.configuration.ConfigurationBuilder();
+      clientBuilder.addServer().host("localhost").port(hotrodServer.getPort());
+      remoteCacheManager = new RemoteCacheManager(clientBuilder.build());
+      remoteCache = remoteCacheManager.getCache(CACHE_NAME);
+   }
+
+   @Test
+   public void testValueInMultipleFormats() throws Exception {
+      remoteCache.clear();
+      String quote = "I find your lack of faith disturbing";
+
+      byte[] jbossMarshalledQuote = marshall(quote);
+
+      // Write to the cache using the default marshaller
+      remoteCache.put(1, quote);
+
+      // Read it back as raw bytes using the same key
+      Object asBinary = remoteCache.withDataFormat(DataFormat.builder().valueType(APPLICATION_JBOSS_MARSHALLING).valueMarshaller(IdentityMarshaller.INSTANCE).build()).get(1);
+
+      assertArrayEquals(((byte[]) asBinary), jbossMarshalledQuote);
+
+      // Read it back as UTF-8 byte[] using the same key
+      Object asUTF8 = remoteCache
+            .withDataFormat(DataFormat.builder().valueType(TEXT_PLAIN).valueMarshaller(IdentityMarshaller.INSTANCE).build())
+            .get(1);
+
+      assertArrayEquals(quote.getBytes(UTF_8), (byte[]) asUTF8);
+
+      // Read it back as String using the default marshaller for text/plain
+      Object asString = remoteCache.withDataFormat(DataFormat.builder().valueType(TEXT_PLAIN).build()).get(1);
+
+      assertEquals(quote, asString);
+
+      // Same, but with metadata
+      MetadataValue<Object> metadataValue = remoteCache
+            .withDataFormat(DataFormat.builder().valueType(TEXT_PLAIN).build())
+            .getWithMetadata(1);
+
+      assertEquals(quote, metadataValue.getValue());
+
+      // Get all entries avoiding de-serialization
+      Map<Object, Object> allEntries = remoteCache
+            .withDataFormat(DataFormat.builder().valueMarshaller(IdentityMarshaller.INSTANCE).build())
+            .getAll(new HashSet<>(Collections.singletonList(1)));
+
+      assertArrayEquals(jbossMarshalledQuote, (byte[]) allEntries.get(1));
+
+      // Read value as JSON in the byte[] form, using the same key
+      Object asJSon = remoteCache.withDataFormat(DataFormat.builder().valueType(APPLICATION_JSON).build()).get(1);
+      assertArrayEquals(("\"" + quote + "\"").getBytes(UTF_8), (byte[]) asJSon);
+
+      // Read value as JSON in as JsonNode objects
+      Object asJSonNode = remoteCache
+            .withDataFormat(DataFormat.builder().valueType(APPLICATION_JSON).valueMarshaller(new JacksonMarshaller()).build())
+            .get(1);
+
+      assertEquals(new TextNode(quote), asJSonNode);
+
+      // Iterate values without unmarshalling
+      Object raw = remoteCache
+            .withDataFormat(DataFormat.builder().valueType(APPLICATION_JBOSS_MARSHALLING).valueMarshaller(IdentityMarshaller.INSTANCE).build())
+            .values().iterator().next();
+      assertArrayEquals(((byte[]) raw), jbossMarshalledQuote);
+
+      // Iterate values converting to JsonNode objects
+      Object jsonNode = remoteCache
+            .withDataFormat(DataFormat.builder().valueType(APPLICATION_JSON).valueMarshaller(new JacksonMarshaller()).build())
+            .values().iterator().next();
+      assertEquals(jsonNode, new TextNode(quote));
+   }
+
+   @Test
+   public void testKeysInMultipleFormats() throws Exception {
+      remoteCache.clear();
+      InetSocketAddress value = InetSocketAddress.createUnresolved("infinispan.org", 8080);
+
+      // Write using String using default Marshaller
+      remoteCache.put("1", value);
+      assertEquals(value, remoteCache.get("1"));
+
+      // Use UTF-8 key directly as byte[], bypassing the marshaller.
+      remoteCache.withDataFormat(DataFormat.builder().keyType(TEXT_PLAIN).keyMarshaller(IdentityMarshaller.INSTANCE).build())
+            .put("utf-key".getBytes(), value);
+
+      assertEquals(value, remoteCache.get("utf-key"));
+
+      // Use UTF-8 key with the default UTF8Marshaller
+      RemoteCache<Object, Object> remoteCacheUTFKey = this.remoteCache.withDataFormat(DataFormat.builder().keyType(TEXT_PLAIN).build());
+
+      remoteCache.put("temp-key", value);
+      assertTrue(remoteCacheUTFKey.containsKey("temp-key"));
+      remoteCacheUTFKey.remove("temp-key");
+      assertFalse(remoteCacheUTFKey.containsKey("temp-key"));
+
+      assertEquals(value, remoteCacheUTFKey.get("1"));
+
+      // Read value as UTF-8 using a UTF-8 key
+      Object asString = this.remoteCache
+            .withDataFormat(DataFormat.builder().keyType(TEXT_PLAIN).valueType(TEXT_PLAIN).build())
+            .get("1");
+      assertEquals(asString, "infinispan.org:8080");
+
+      // Write using manually marshalled values
+      remoteCache.withDataFormat(DataFormat.builder()
+            .keyType(APPLICATION_JBOSS_MARSHALLING).keyMarshaller(IdentityMarshaller.INSTANCE)
+            .valueType(APPLICATION_JBOSS_MARSHALLING).valueMarshaller(IdentityMarshaller.INSTANCE)
+            .build())
+            .put(marshall(1024), marshall(value));
+
+      assertEquals(value, this.remoteCache.get(1024));
+
+      // Remove using UTF-8 values
+      boolean removed = this.remoteCache
+            .withDataFormat(DataFormat.builder().valueType(TEXT_PLAIN).build())
+            .remove(1024, "wrong-address.com");
+      assertFalse(removed);
+
+      removed = this.remoteCache
+            .withDataFormat(DataFormat.builder().valueType(TEXT_PLAIN).build())
+            .remove(1024, "infinispan.org:8080");
+      assertTrue(removed);
+      assertFalse(this.remoteCache.containsKey(1024));
+
+   }
+
+   @Test
+   public void testBatchOperations() {
+      remoteCache.clear();
+
+      Map<ComplexKey, String> entries = new HashMap<>();
+      IntStream.range(0, 50).forEach(i -> {
+         ComplexKey key = new ComplexKey(String.valueOf(i), (float) i);
+         entries.put(key, UUID.randomUUID().toString());
+      });
+      remoteCache.putAll(entries);
+
+      // Read all keys as JSON Strings
+      RemoteCache<String, String> jsonCache = this.remoteCache.withDataFormat(DataFormat.builder()
+            .keyType(APPLICATION_JSON).keyMarshaller(new UTF8StringMarshaller()).build());
+
+      Set<String> jsonKeys = new HashSet<>(jsonCache.keySet());
+      jsonKeys.forEach(k -> assertTrue(k.contains("\"_type\":\"org.infinispan.client.hotrod.transcoding.ComplexKey\"")));
+
+
+      Map<String, String> newEntries = new HashMap<>();
+
+      // Write using JSON
+      IntStream.range(50, 100).forEach(i -> {
+         String jsonKey = "{\"_type\":\"org.infinispan.client.hotrod.transcoding.ComplexKey\",\"id\":\"" + i + "\",\"ratio\":" + i + "}";
+         newEntries.put(jsonKey, UUID.randomUUID().toString());
+      });
+      jsonCache.putAll(newEntries);
+
+      // Read it back as regular objects
+      Set<ComplexKey> keys = new HashSet<>();
+      IntStream.range(60, 70).forEach(i -> keys.add(new ComplexKey(String.valueOf(i), (float) i)));
+      Set<ComplexKey> returned = remoteCache.getAll(keys).keySet().stream().map(ComplexKey.class::cast).collect(Collectors.toSet());
+      assertEquals(keys, returned);
+   }
+
+   @Test
+   public void testListenersWithDifferentFormats() {
+      remoteCache.clear();
+
+      ComplexKey complexKey = new ComplexKey("Key-1", 89.88f);
+
+      // Receive events as JSON Strings
+      DataFormat jsonStringFormat = DataFormat.builder().keyType(APPLICATION_JSON).keyMarshaller(new UTF8StringMarshaller()).build();
+
+      EventLogListener<Object> l = new EventLogListener<>(remoteCache.withDataFormat(jsonStringFormat));
+
+      withClientListener(l, remote -> {
+         remoteCache.put(complexKey, UUID.randomUUID());
+         l.expectOnlyCreatedEvent("{\"_type\":\"org.infinispan.client.hotrod.transcoding.ComplexKey\",\"id\":\"Key-1\",\"ratio\":89.88}");
+      });
+   }
+
+   @Test(expectedExceptions = IncorrectClientListenerException.class)
+   public void testNonRawFilteredListeners() {
+      // Currently the Hot Rod server maintain a single marshaller for all events of all caches. Until this is fixed,
+      // throw an exception when trying to add filtered listeners with custom data formats.
+      RemoteCache<?, ?> remoteCache = this.remoteCache.withDataFormat(DataFormat.builder().valueType(TEXT_PLAIN).build());
+      StaticFilteredEventLogListener<?> l = new StaticFilteredEventLogListener<>(remoteCache);
+      remoteCache.addClientListener(l);
+   }
+
+   @Test
+   public void testRawFilteredListeners() {
+      remoteCache.clear();
+
+      RemoteCache<Object, Object> remoteCache = this.remoteCache
+            .withDataFormat(DataFormat.builder().keyType(APPLICATION_JSON).keyMarshaller(new UTF8StringMarshaller()).build());
+
+      RawFilterFactoryListener<Object> l = new RawFilterFactoryListener<>(remoteCache);
+
+      withClientListener(l, remote -> {
+         this.remoteCache.put("1", UUID.randomUUID());
+         l.expectNoEvents();
+         this.remoteCache.put("2", UUID.randomUUID());
+         l.expectOnlyCreatedEvent("\"2\"");
+      });
+   }
+
+   @NamedFactory(name = "raw-filter-factory")
+   @SuppressWarnings("unchecked")
+   public static class RawFilterFactory implements CacheEventFilterFactory {
+      @Override
+      public CacheEventFilter<byte[], byte[]> getFilter(final Object[] params) {
+         return new RawFilter();
+      }
+
+      static class RawFilter implements CacheEventFilter<byte[], byte[]>, Serializable {
+         final byte[] magicKey = "\"2\"".getBytes(UTF_8);// JSON "2" literal
+
+         @Override
+         public boolean accept(byte[] key, byte[] previousValue, Metadata previousMetadata, byte[] value,
+                               Metadata metadata, EventType eventType) {
+            return Arrays.equals(key, magicKey);
+         }
+      }
+   }
+
+   @ClientListener(filterFactoryName = "raw-filter-factory", useRawData = true)
+   public static class RawFilterFactoryListener<K> extends EventLogListener<K> {
+      RawFilterFactoryListener(RemoteCache<K, ?> r) {
+         super(r);
+      }
+   }
+
+   private byte[] marshall(Object o) throws Exception {
+      return remoteCache.getRemoteCacheManager().getMarshaller().objectToByteBuffer(o);
+   }
+}
+
+class JacksonMarshaller extends AbstractMarshaller {
+
+   private static final ObjectMapper MAPPER = new ObjectMapper();
+
+   @Override
+   protected ByteBuffer objectToBuffer(Object o, int estimatedSize) throws IOException {
+      byte[] bytes = MAPPER.writeValueAsBytes(o);
+      return new ByteBufferImpl(bytes, 0, bytes.length);
+   }
+
+   @Override
+   public Object objectFromByteBuffer(byte[] buf, int offset, int length) throws IOException {
+      return MAPPER.readTree(buf);
+   }
+
+   @Override
+   public boolean isMarshallable(Object o) {
+      return true;
+   }
+
+   @Override
+   public MediaType mediaType() {
+      return APPLICATION_JSON;
+   }
+}
+
+@SuppressWarnings("unused")
+class ComplexKey implements Serializable {
+   public ComplexKey() {
+   }
+
+   private String id;
+
+   private Float ratio;
+
+   ComplexKey(String id, Float ratio) {
+      this.id = id;
+      this.ratio = ratio;
+   }
+
+   public void setId(String id) {
+      this.id = id;
+   }
+
+   public void setRatio(Float ratio) {
+      this.ratio = ratio;
+   }
+
+   public String getId() {
+      return id;
+   }
+
+   public Float getRatio() {
+      return ratio;
+   }
+
+   @Override
+   public boolean equals(Object o) {
+      if (this == o) return true;
+      if (o == null || getClass() != o.getClass()) return false;
+      ComplexKey that = (ComplexKey) o;
+      return Objects.equals(id, that.id) &&
+            Objects.equals(ratio, that.ratio);
+   }
+
+   @Override
+   public int hashCode() {
+
+      return Objects.hash(id, ratio);
+   }
+}
diff --git a/client/marshaller/kryo/kryo-marshaller/src/main/java/org/infinispan/marshaller/kryo/KryoMarshaller.java b/client/marshaller/kryo/kryo-marshaller/src/main/java/org/infinispan/marshaller/kryo/KryoMarshaller.java
index 19b062357364..553ae45e31b0 100644
--- a/client/marshaller/kryo/kryo-marshaller/src/main/java/org/infinispan/marshaller/kryo/KryoMarshaller.java
+++ b/client/marshaller/kryo/kryo-marshaller/src/main/java/org/infinispan/marshaller/kryo/KryoMarshaller.java
@@ -4,6 +4,7 @@
 import java.util.List;
 import java.util.ServiceLoader;
 
+import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.io.ByteBuffer;
 import org.infinispan.commons.io.ByteBufferImpl;
 import org.infinispan.commons.io.ExposedByteArrayOutputStream;
@@ -22,6 +23,7 @@
 public class KryoMarshaller extends AbstractMarshaller {
 
    private static final List<SerializerRegistryService> serializerServices = new ArrayList<>();
+
    static {
       ServiceLoader.load(SerializerRegistryService.class, KryoMarshaller.class.getClassLoader())
             .forEach(serializerServices::add);
@@ -67,4 +69,9 @@ public boolean isMarshallable(Object obj) throws Exception {
          return false;
       }
    }
+
+   @Override
+   public MediaType mediaType() {
+      return MediaType.APPLICATION_KRYO;
+   }
 }
diff --git a/client/marshaller/protostuff/protostuff-marshaller/src/main/java/org/infinispan/marshaller/protostuff/ProtostuffMarshaller.java b/client/marshaller/protostuff/protostuff-marshaller/src/main/java/org/infinispan/marshaller/protostuff/ProtostuffMarshaller.java
index 482aaad67012..b4cb5e27878c 100644
--- a/client/marshaller/protostuff/protostuff-marshaller/src/main/java/org/infinispan/marshaller/protostuff/ProtostuffMarshaller.java
+++ b/client/marshaller/protostuff/protostuff-marshaller/src/main/java/org/infinispan/marshaller/protostuff/ProtostuffMarshaller.java
@@ -5,6 +5,7 @@
 import java.io.IOException;
 import java.util.ServiceLoader;
 
+import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.io.ByteBuffer;
 import org.infinispan.commons.io.ByteBufferImpl;
 import org.infinispan.commons.marshall.AbstractMarshaller;
@@ -24,6 +25,7 @@ public class ProtostuffMarshaller extends AbstractMarshaller {
       ClassLoader loader = ProtostuffMarshaller.class.getClassLoader();
       ServiceLoader.load(SchemaRegistryService.class, loader).forEach(SchemaRegistryService::register);
    }
+
    private static final Schema<Wrapper> WRAPPER_SCHEMA = RuntimeSchema.getSchema(Wrapper.class);
 
    @Override
@@ -49,4 +51,9 @@ public boolean isMarshallable(Object obj) throws Exception {
          return false;
       }
    }
+
+   @Override
+   public MediaType mediaType() {
+      return MediaType.APPLICATION_PROTOSTUFF;
+   }
 }
diff --git a/commons/src/main/java/org/infinispan/commons/dataconversion/MediaType.java b/commons/src/main/java/org/infinispan/commons/dataconversion/MediaType.java
index 5682ec3908af..fd198e637a7b 100644
--- a/commons/src/main/java/org/infinispan/commons/dataconversion/MediaType.java
+++ b/commons/src/main/java/org/infinispan/commons/dataconversion/MediaType.java
@@ -8,6 +8,7 @@
 import java.io.ObjectInput;
 import java.io.ObjectOutput;
 import java.nio.charset.Charset;
+import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.Map;
@@ -188,6 +189,10 @@ public String getTypeSubtype() {
       return typeSubtype;
    }
 
+   public MediaType withoutParameters() {
+      return new MediaType(type, subType);
+   }
+
    public double getWeight() {
       return weight;
    }
@@ -227,6 +232,14 @@ public Optional<String> getParameter(String name) {
       return Optional.ofNullable(params.get(name));
    }
 
+   public Map<String, String> getParameters() {
+      return Collections.unmodifiableMap(params);
+   }
+
+   public MediaType withParameters(Map<String, String> parameters) {
+      return new MediaType(this.type, this.subType, parameters);
+   }
+
    private static String validate(String token) {
       if (token == null) throw new NullPointerException("type and subtype cannot be null");
       for (char c : token.toCharArray()) {
diff --git a/commons/src/main/java/org/infinispan/commons/dataconversion/MediaTypeIds.java b/commons/src/main/java/org/infinispan/commons/dataconversion/MediaTypeIds.java
index a614eace1dcf..b8af1699bd67 100644
--- a/commons/src/main/java/org/infinispan/commons/dataconversion/MediaTypeIds.java
+++ b/commons/src/main/java/org/infinispan/commons/dataconversion/MediaTypeIds.java
@@ -23,7 +23,7 @@
 /**
  * @since 9.2
  */
-final class MediaTypeIds {
+public final class MediaTypeIds {
 
    private static final Map<String, Short> idByType = new HashMap<>(32);
    private static final Map<Short, String> typeById = new HashMap<>(32);
@@ -46,14 +46,14 @@ final class MediaTypeIds {
       idByType.put(APPLICATION_JBOSS_MARSHALLING_TYPE, (short) 15);
       idByType.put(APPLICATION_INFINISPAN_MARSHALLING_TYPE, (short) 16);
 
-      idByType.entrySet().forEach(e -> typeById.put(e.getValue(), e.getKey()));
+      idByType.forEach((key, value) -> typeById.put(value, key));
    }
 
-   static Short getId(String mediaType) {
+   public static Short getId(String mediaType) {
       return idByType.get(mediaType);
    }
 
-   static String getMediaType(Short id) {
+   public static String getMediaType(Short id) {
       return typeById.get(id);
    }
 
diff --git a/commons/src/main/java/org/infinispan/commons/dataconversion/StandardConversions.java b/commons/src/main/java/org/infinispan/commons/dataconversion/StandardConversions.java
index a157c95f649c..448b876e1ac4 100644
--- a/commons/src/main/java/org/infinispan/commons/dataconversion/StandardConversions.java
+++ b/commons/src/main/java/org/infinispan/commons/dataconversion/StandardConversions.java
@@ -78,9 +78,9 @@ public static byte[] convertTextToOctetStream(Object source, MediaType sourceTyp
     * @return String representation of the text content.
     * @throws EncodingException if the source cannot be interpreted as plain text.
     */
-   public static Object convertTextToObject(Object source, MediaType sourceType) {
+   public static String convertTextToObject(Object source, MediaType sourceType) {
       if (source == null) return null;
-      if (source instanceof String) return source;
+      if (source instanceof String) return source.toString();
       if (source instanceof byte[]) {
          byte[] bytesSource = (byte[]) source;
          return new String(bytesSource, sourceType.getCharset());
diff --git a/commons/src/main/java/org/infinispan/commons/marshall/IdentityMarshaller.java b/commons/src/main/java/org/infinispan/commons/marshall/IdentityMarshaller.java
new file mode 100644
index 000000000000..f179adc317ba
--- /dev/null
+++ b/commons/src/main/java/org/infinispan/commons/marshall/IdentityMarshaller.java
@@ -0,0 +1,38 @@
+package org.infinispan.commons.marshall;
+
+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OCTET_STREAM;
+
+import org.infinispan.commons.dataconversion.MediaType;
+import org.infinispan.commons.io.ByteBuffer;
+import org.infinispan.commons.io.ByteBufferImpl;
+
+/**
+ * A marshaller that does not transform the content, only applicable to byte[] payloads.
+ *
+ * @since 9.3
+ */
+public class IdentityMarshaller extends AbstractMarshaller {
+
+   public static final IdentityMarshaller INSTANCE = new IdentityMarshaller();
+
+   @Override
+   protected ByteBuffer objectToBuffer(Object o, int estimatedSize) {
+      byte[] payload = (byte[]) o;
+      return new ByteBufferImpl(payload, 0, payload.length);
+   }
+
+   @Override
+   public Object objectFromByteBuffer(byte[] buf, int offset, int length) {
+      return buf;
+   }
+
+   @Override
+   public boolean isMarshallable(Object o) {
+      return o instanceof byte[];
+   }
+
+   @Override
+   public MediaType mediaType() {
+      return APPLICATION_OCTET_STREAM;
+   }
+}
diff --git a/commons/src/main/java/org/infinispan/commons/marshall/JavaSerializationMarshaller.java b/commons/src/main/java/org/infinispan/commons/marshall/JavaSerializationMarshaller.java
index 6d054eb998db..8a1ff8408254 100644
--- a/commons/src/main/java/org/infinispan/commons/marshall/JavaSerializationMarshaller.java
+++ b/commons/src/main/java/org/infinispan/commons/marshall/JavaSerializationMarshaller.java
@@ -10,6 +10,7 @@
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 
+import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.io.ByteBuffer;
 import org.infinispan.commons.io.ByteBufferImpl;
 
@@ -47,4 +48,9 @@ public boolean isMarshallable(Object o) throws Exception {
       return o instanceof Serializable;
    }
 
+   @Override
+   public MediaType mediaType() {
+      return MediaType.APPLICATION_SERIALIZED_OBJECT;
+   }
+
 }
diff --git a/commons/src/main/java/org/infinispan/commons/marshall/Marshaller.java b/commons/src/main/java/org/infinispan/commons/marshall/Marshaller.java
index f87a75c7c0f7..7d156a3c6b6c 100644
--- a/commons/src/main/java/org/infinispan/commons/marshall/Marshaller.java
+++ b/commons/src/main/java/org/infinispan/commons/marshall/Marshaller.java
@@ -2,6 +2,7 @@
 
 import java.io.IOException;
 
+import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.io.ByteBuffer;
 
 import net.jcip.annotations.ThreadSafe;
@@ -100,4 +101,9 @@ public interface Marshaller {
     */
    BufferSizePredictor getBufferSizePredictor(Object o);
 
+   /**
+    * @return the {@link MediaType} associated with the content produced by the marshaller
+    */
+   MediaType mediaType();
+
 }
diff --git a/commons/src/main/java/org/infinispan/commons/marshall/StringMarshaller.java b/commons/src/main/java/org/infinispan/commons/marshall/StringMarshaller.java
index 13aa629a6db3..d0941f8161aa 100644
--- a/commons/src/main/java/org/infinispan/commons/marshall/StringMarshaller.java
+++ b/commons/src/main/java/org/infinispan/commons/marshall/StringMarshaller.java
@@ -3,6 +3,7 @@
 import java.io.IOException;
 import java.nio.charset.Charset;
 
+import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.io.ByteBuffer;
 import org.infinispan.commons.io.ByteBufferImpl;
 
@@ -30,4 +31,9 @@ public boolean isMarshallable(Object o) throws Exception {
       return o instanceof String;
    }
 
+   @Override
+   public MediaType mediaType() {
+      return MediaType.TEXT_PLAIN;
+   }
+
 }
diff --git a/commons/src/main/java/org/infinispan/commons/marshall/UTF8StringMarshaller.java b/commons/src/main/java/org/infinispan/commons/marshall/UTF8StringMarshaller.java
index 1113afa15324..87b4c002c4ab 100644
--- a/commons/src/main/java/org/infinispan/commons/marshall/UTF8StringMarshaller.java
+++ b/commons/src/main/java/org/infinispan/commons/marshall/UTF8StringMarshaller.java
@@ -2,10 +2,18 @@
 
 import static java.nio.charset.StandardCharsets.UTF_8;
 
+import org.infinispan.commons.dataconversion.MediaType;
+
 public final class UTF8StringMarshaller extends StringMarshaller {
 
+   private static final MediaType UTF8_MEDIA_TYPE = MediaType.parse("text/plain; charset=UTF-8");
+
    public UTF8StringMarshaller() {
       super(UTF_8);
    }
 
+   @Override
+   public MediaType mediaType() {
+      return UTF8_MEDIA_TYPE;
+   }
 }
diff --git a/commons/src/main/java/org/infinispan/commons/marshall/jboss/AbstractJBossMarshaller.java b/commons/src/main/java/org/infinispan/commons/marshall/jboss/AbstractJBossMarshaller.java
index f94035bba9e9..0921c3c825d7 100644
--- a/commons/src/main/java/org/infinispan/commons/marshall/jboss/AbstractJBossMarshaller.java
+++ b/commons/src/main/java/org/infinispan/commons/marshall/jboss/AbstractJBossMarshaller.java
@@ -13,6 +13,7 @@
 import java.lang.reflect.Method;
 import java.net.URL;
 
+import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.io.ByteBuffer;
 import org.infinispan.commons.io.ByteBufferImpl;
 import org.infinispan.commons.io.ExposedByteArrayOutputStream;
@@ -104,7 +105,7 @@ final public void finishObjectOutput(final ObjectOutput oo) {
 
    @Override
    final public Object objectFromByteBuffer(final byte[] buf, final int offset, final int length) throws IOException,
-           ClassNotFoundException {
+         ClassNotFoundException {
       ByteArrayInputStream is = new ByteArrayInputStream(buf, offset, length);
       ObjectInput unmarshaller = startObjectInput(is, false);
       Object o = null;
@@ -123,7 +124,7 @@ final public ObjectInput startObjectInput(final InputStream is, final boolean is
 
       if (trace)
          log.tracef("Start unmarshaller after retrieving marshaller from %s",
-                   isReentrant ? "factory" : "thread local");
+               isReentrant ? "factory" : "thread local");
 
       unmarshaller.start(Marshalling.createByteInput(is));
       return unmarshaller;
@@ -153,7 +154,7 @@ public boolean isMarshallable(Object o) throws Exception {
          boolean marshallable = marshallableTypeHints.isMarshallable(clazz);
          if (trace)
             log.tracef("Marshallable type '%s' known and is marshallable=%b",
-               clazz.getName(), marshallable);
+                  clazz.getName(), marshallable);
 
          return marshallable;
       } else {
@@ -180,7 +181,7 @@ public void start() {
 
    @Override
    public void stop() {
-       // Clear class cache
+      // Clear class cache
       marshallableTypeHints.clear();
       marshallerTL.clear();
    }
@@ -276,14 +277,12 @@ Unmarshaller getUnmarshaller() throws IOException {
             //we're above the pool threshold: make a throw-away-after usage Marshaller
             configuration.setBufferSize(512);//reset to default as it might be changed by getMarshaller
             return factory.createUnmarshaller(configuration);
-         }
-         else {
+         } else {
             ExtendedRiverUnmarshaller unMarshaller = reusableUnMarshaller[availableUnMarshallerIndex];
             if (unMarshaller != null) {
                availableUnMarshallerIndex++;
                return unMarshaller;
-            }
-            else {
+            } else {
                configuration.setBufferSize(RIVER_INTERNAL_BUFFER);//reset to default as it might be changed by getMarshaller
                unMarshaller = factory.createUnmarshaller(configuration);
                unMarshaller.setCloseListener(this);
@@ -300,14 +299,12 @@ ExtendedRiverMarshaller getMarshaller(int estimatedSize) throws IOException {
             //setting the buffer as cheap as possible:
             configuration.setBufferSize(estimatedSize);
             return factory.createMarshaller(configuration);
-         }
-         else {
+         } else {
             ExtendedRiverMarshaller marshaller = reusableMarshaller[availableMarshallerIndex];
             if (marshaller != null) {
                availableMarshallerIndex++;
                return marshaller;
-            }
-            else {
+            } else {
                //we're going to pool this one, make sure the buffer size is set to a reasonable value
                //as we might have changed it previously:
                configuration.setBufferSize(RIVER_INTERNAL_BUFFER);
@@ -331,4 +328,8 @@ public void closeUnmarshaller() {
       }
    }
 
+   @Override
+   public MediaType mediaType() {
+      return MediaType.APPLICATION_JBOSS_MARSHALLING;
+   }
 }
diff --git a/core/src/main/java/org/infinispan/cache/impl/EncoderCache.java b/core/src/main/java/org/infinispan/cache/impl/EncoderCache.java
index 0949fea2a0df..f99115f81488 100644
--- a/core/src/main/java/org/infinispan/cache/impl/EncoderCache.java
+++ b/core/src/main/java/org/infinispan/cache/impl/EncoderCache.java
@@ -36,7 +36,6 @@
 import org.infinispan.encoding.DataConversion;
 import org.infinispan.factories.ComponentRegistry;
 import org.infinispan.factories.annotations.Inject;
-import org.infinispan.lifecycle.ComponentStatus;
 import org.infinispan.metadata.Metadata;
 import org.infinispan.notifications.cachelistener.ListenerHolder;
 import org.infinispan.notifications.cachelistener.filter.CacheEventConverter;
@@ -56,8 +55,10 @@ public class EncoderCache<K, V> extends AbstractDelegatingAdvancedCache<K, V> {
 
    private static Log log = LogFactory.getLog(EncoderCache.class);
 
-   @Inject private InternalEntryFactory entryFactory;
-   @Inject private ComponentRegistry componentRegistry;
+   @Inject
+   private InternalEntryFactory entryFactory;
+   @Inject
+   private ComponentRegistry componentRegistry;
 
    private final DataConversion keyDataConversion;
    private final DataConversion valueDataConversion;
@@ -493,11 +494,8 @@ public V putIfAbsent(K key, V value) {
    }
 
    private void lookupEncoderWrapper() {
-      ComponentStatus status = cache.getAdvancedCache().getComponentRegistry().getStatus();
-      if (!status.equals(ComponentStatus.STOPPING) && !status.equals(ComponentStatus.TERMINATED)) {
-         componentRegistry.wireDependencies(keyDataConversion);
-         componentRegistry.wireDependencies(valueDataConversion);
-      }
+      componentRegistry.wireDependencies(keyDataConversion);
+      componentRegistry.wireDependencies(valueDataConversion);
    }
 
    private void initState(EncoderCache<K, V> encoderCache, EncoderCache<K, V> template) {
@@ -571,7 +569,7 @@ private void checkSubclass(Class<?> configured, Class<?> required) {
     * @return true if all classes are identity oness
     */
    private boolean allIdentity(Class<? extends Encoder> keyEncoderClass, Class<? extends Encoder> valueEncoderClass,
-         Class<? extends Wrapper> keyWrapperClass, Class<? extends Wrapper> valueWrapperClass) {
+                               Class<? extends Wrapper> keyWrapperClass, Class<? extends Wrapper> valueWrapperClass) {
       return keyEncoderClass == IdentityEncoder.class && valueEncoderClass == IdentityEncoder.class &&
             keyWrapperClass == IdentityWrapper.class && valueWrapperClass == IdentityWrapper.class;
    }
diff --git a/core/src/main/java/org/infinispan/cache/impl/EncoderEntryMapper.java b/core/src/main/java/org/infinispan/cache/impl/EncoderEntryMapper.java
index 2c2217162134..fca691a4641c 100644
--- a/core/src/main/java/org/infinispan/cache/impl/EncoderEntryMapper.java
+++ b/core/src/main/java/org/infinispan/cache/impl/EncoderEntryMapper.java
@@ -7,7 +7,6 @@
 import java.util.Map;
 import java.util.Set;
 
-import org.infinispan.commons.dataconversion.Encoder;
 import org.infinispan.commons.marshall.AdvancedExternalizer;
 import org.infinispan.commons.marshall.Ids;
 import org.infinispan.commons.util.InjectiveFunction;
@@ -23,13 +22,14 @@
  * the requested format.
  */
 public class EncoderEntryMapper<K, V, T extends Map.Entry<K, V>> implements InjectiveFunction<T, T> {
-   @Inject private transient InternalEntryFactory entryFactory;
+   @Inject
+   private transient InternalEntryFactory entryFactory;
 
    private final DataConversion keyDataConversion;
    private final DataConversion valueDataConversion;
 
    public static <K, V> EncoderEntryMapper<K, V, Map.Entry<K, V>> newEntryMapper(DataConversion keyDataConversion,
-         DataConversion valueDataConversion, InternalEntryFactory entryFactory) {
+                                                                                 DataConversion valueDataConversion, InternalEntryFactory entryFactory) {
       EncoderEntryMapper<K, V, Map.Entry<K, V>> mapper = new EncoderEntryMapper<>(keyDataConversion, valueDataConversion);
       mapper.entryFactory = entryFactory;
       return mapper;
@@ -53,11 +53,6 @@ public void injectDependencies(ComponentRegistry registry) {
       registry.wireDependencies(valueDataConversion);
    }
 
-   private Object decode(Object o, Encoder encoder) {
-      if (o == null) return null;
-      return encoder.fromStorage(o);
-   }
-
    @Override
    @SuppressWarnings("unchecked")
    public T apply(T e) {
@@ -69,11 +64,11 @@ public T apply(T e, boolean ignoreStorageFormatFilterable) {
       boolean valueFilterable = !ignoreStorageFormatFilterable && valueDataConversion.isStorageFormatFilterable();
       K key = e.getKey();
       Object unwrapped = keyDataConversion.getWrapper().unwrap(key);
-      Object newKey = keyFilterable ? unwrapped : decode(unwrapped, keyDataConversion.getEncoder());
+      Object newKey = keyFilterable ? unwrapped : keyDataConversion.fromStorage(key);
       V value = e.getValue();
 
       Object unwrappedValue = valueDataConversion.getWrapper().unwrap(value);
-      Object newValue = valueFilterable ? unwrappedValue : decode(unwrappedValue, valueDataConversion.getEncoder());
+      Object newValue = valueFilterable ? unwrappedValue : valueDataConversion.fromStorage(value);
       if (key != newKey || value != newValue) {
          if (e instanceof CacheEntry) {
             CacheEntry<K, V> ce = (CacheEntry<K, V>) e;
diff --git a/core/src/main/java/org/infinispan/marshall/core/ExternalJBossMarshaller.java b/core/src/main/java/org/infinispan/marshall/core/ExternalJBossMarshaller.java
index 103294179208..1b790381ad4d 100644
--- a/core/src/main/java/org/infinispan/marshall/core/ExternalJBossMarshaller.java
+++ b/core/src/main/java/org/infinispan/marshall/core/ExternalJBossMarshaller.java
@@ -6,6 +6,7 @@
 import java.io.ObjectOutput;
 import java.io.OutputStream;
 
+import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.io.ByteBuffer;
 import org.infinispan.commons.marshall.BufferSizePredictor;
 import org.infinispan.commons.marshall.MarshallableTypeHints;
@@ -121,6 +122,11 @@ public BufferSizePredictor getBufferSizePredictor(Object o) {
       throw new UnsupportedOperationException("No longer in use");
    }
 
+   @Override
+   public MediaType mediaType() {
+      return MediaType.APPLICATION_JBOSS_MARSHALLING;
+   }
+
    static final class JBossByteOutput extends OutputStream implements ByteOutput {
 
       final ObjectOutput out;
diff --git a/core/src/main/java/org/infinispan/marshall/core/GlobalMarshaller.java b/core/src/main/java/org/infinispan/marshall/core/GlobalMarshaller.java
index 0cf8113debb5..d02e3d3e8447 100644
--- a/core/src/main/java/org/infinispan/marshall/core/GlobalMarshaller.java
+++ b/core/src/main/java/org/infinispan/marshall/core/GlobalMarshaller.java
@@ -11,6 +11,7 @@
 
 import org.infinispan.commands.RemoteCommandsFactory;
 import org.infinispan.commons.CacheException;
+import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.io.ByteBuffer;
 import org.infinispan.commons.io.ExposedByteArrayOutputStream;
 import org.infinispan.commons.marshall.AdvancedExternalizer;
@@ -293,6 +294,11 @@ public BufferSizePredictor getBufferSizePredictor(Object o) {
       return marshallableTypeHints.getBufferSizePredictor(o.getClass());
    }
 
+   @Override
+   public MediaType mediaType() {
+      return MediaType.APPLICATION_INFINISPAN_MARSHALLED;
+   }
+
    @Override
    public ByteBuffer objectToBuffer(Object o) throws IOException, InterruptedException {
       try {
diff --git a/core/src/main/java/org/infinispan/notifications/cachelistener/CacheNotifierImpl.java b/core/src/main/java/org/infinispan/notifications/cachelistener/CacheNotifierImpl.java
index e86238ddcee0..34abd30ccb9a 100644
--- a/core/src/main/java/org/infinispan/notifications/cachelistener/CacheNotifierImpl.java
+++ b/core/src/main/java/org/infinispan/notifications/cachelistener/CacheNotifierImpl.java
@@ -283,7 +283,7 @@ private K convertKey(DataConversion keyDataConversion, K key) {
       Wrapper wrp = keyDataConversion != null ? keyDataConversion.getWrapper() : defaultWrapper;
       Encoder enc = keyDataConversion != null ? keyDataConversion.getEncoder() : defaultEncoder;
       Object unwrappedKey = wrp.unwrap(key);
-      return enc.isStorageFormatFilterable() ? (K) unwrappedKey : (K) enc.fromStorage(unwrappedKey);
+      return enc.isStorageFormatFilterable() ? (K) unwrappedKey : (K) keyDataConversion.fromStorage(key);
    }
 
    private V convertValue(DataConversion valueDataConversion, V value) {
@@ -291,7 +291,7 @@ private V convertValue(DataConversion valueDataConversion, V value) {
       Wrapper wrp = valueDataConversion != null ? valueDataConversion.getWrapper() : defaultWrapper;
       Encoder enc = valueDataConversion != null ? valueDataConversion.getEncoder() : defaultEncoder;
       Object unwrappedValue = wrp.unwrap(value);
-      return enc.isStorageFormatFilterable() ? (V) unwrappedValue : (V) enc.fromStorage(unwrappedValue);
+      return enc.isStorageFormatFilterable() ? (V) unwrappedValue : (V) valueDataConversion.fromStorage(unwrappedValue);
    }
 
    @Override
@@ -785,7 +785,7 @@ private <C> void addListenerInternal(Object listener, DataConversion keyDataConv
       boolean foundMethods = false;
       // We use identity for null as this means it was invoked by a non encoder cache
       DataConversion keyConversion = keyDataConversion == null ? DataConversion.IDENTITY_KEY : keyDataConversion;
-      DataConversion valueConversion = valueDataConversion == null ? DataConversion.IDENTITY_VALUE: valueDataConversion;
+      DataConversion valueConversion = valueDataConversion == null ? DataConversion.IDENTITY_VALUE : valueDataConversion;
       if (filter instanceof IndexedFilter) {
          IndexedFilter indexedFilter = (IndexedFilter) filter;
          indexingProvider = findIndexingServiceProvider(indexedFilter);
diff --git a/core/src/main/java/org/infinispan/util/logging/Log.java b/core/src/main/java/org/infinispan/util/logging/Log.java
index c5a70383eefb..ac14a315cc16 100644
--- a/core/src/main/java/org/infinispan/util/logging/Log.java
+++ b/core/src/main/java/org/infinispan/util/logging/Log.java
@@ -1690,8 +1690,8 @@ TimeoutException coordinatorTimeoutWaitingForView(int expectedViewId, int curren
 //   @Message(value = "Invalid text format: '%s'", id = 493)
 //   EncodingException invalidTextFormat(Object content);
 
-//   @Message(value = "Invalid binary format: '%s'", id = 494)
-//   EncodingException invalidBinaryFormat(Object content);
+   @Message(value = "Invalid binary format: '%s'", id = 494)
+   EncodingException invalidBinaryFormat(Object content);
 
    @Message(value = "Error transcoding content", id = 495)
    EncodingException errorTranscoding(@Cause Throwable cause);
@@ -1798,4 +1798,7 @@ CacheConfigurationException offHeapMemoryEvictionSizeNotLargeEnoughForAddresses(
    @LogMessage(level = DEBUG)
    @Message(value = "Conflict resolution cancelled for cache %s with topology %s", id = 525)
    void cancelledConflictResolution(String cacheName, CacheTopology currentTopology);
+
+   @Message(value = "Deserialization of class '%s' is not allowed", id = 526)
+   CacheException errorDeserializing(Class<?> rawClass);
 }
diff --git a/core/src/test/java/org/infinispan/marshall/TestObjectStreamMarshaller.java b/core/src/test/java/org/infinispan/marshall/TestObjectStreamMarshaller.java
index aa03726dfbcf..50eb45730abf 100644
--- a/core/src/test/java/org/infinispan/marshall/TestObjectStreamMarshaller.java
+++ b/core/src/test/java/org/infinispan/marshall/TestObjectStreamMarshaller.java
@@ -6,6 +6,7 @@
 import java.io.ObjectOutput;
 import java.io.OutputStream;
 
+import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.io.ByteBuffer;
 import org.infinispan.commons.marshall.AbstractMarshaller;
 import org.infinispan.commons.marshall.StreamingMarshaller;
@@ -93,4 +94,9 @@ public void stop() {
    @Override
    public void start() {
    }
+
+   @Override
+   public MediaType mediaType() {
+      return marshaller.mediaType();
+   }
 }
diff --git a/documentation/src/main/asciidoc/user_guide/server_protocols_hotrod_wire.adoc b/documentation/src/main/asciidoc/user_guide/server_protocols_hotrod_wire.adoc
index 3d67b4f3aa24..1369a3e1481e 100644
--- a/documentation/src/main/asciidoc/user_guide/server_protocols_hotrod_wire.adoc
+++ b/documentation/src/main/asciidoc/user_guide/server_protocols_hotrod_wire.adoc
@@ -2645,6 +2645,45 @@ Response Header `Status` possible values:
 * `0x02`: The counter isn't defined.
 * See the <<Response Header>> for error codes.
 
+==== Hot Rod Protocol 2.8
+
+.Infinispan versions
+TIP: This version of the protocol is implemented since Infinispan 9.3
+
+This Hot Rod protocol version adds support for specifying the MediaType of Keys and Values, allowing data
+to be read (and written) in different formats. This information is part of the Header.
+
+The data formats are described using a _MediaType_ object, that is represented as follows:
+
+[cols="3,^2,10",options="header"]
+|==============================================================================
+| Field Name          | Size       | Value
+| type   | 1 byte   | 
++0x00+ = No MediaType supplied +
++0x01+ = Pre-defined MediaType supplied +
++0x02+ = Custom MediaType supplied +
+| id  | vInt       | (Optional) For a pre-defined MediaType (type=0x01), the Id of the MediaType. The currently supported Ids can be found at link:https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/dataconversion/MediaTypeIds.java[MediaTypeIds]
+| customString | string | (Optional) If a custom MediaType is supplied (type=0x02), the custom MediaType of the key, including type and subtype. E.g.: _text/plain_, _application/json_, etc.
+| paramSize | vInt | The size of the parameters for the MediaType
+| paramKey1 | string | (Optional) The first parameter's key
+| paramValue1 | string | (Optional) The first parameter's value
+| ...             | ...    | ...
+| paramKeyN | string | (Optional) The nth parameter's key
+| paramValueN | string | (Optional) The nth parameter's value
+|==============================================================================
+
+ 
+===== Request Header
+
+The request header has the following extra fields:
+
+[cols="3,^2,10",options="header"]
+|==============================================================================
+| Field Name          | Type       | Value
+| Key Format  | MediaType   | The MediaType to be used for keys during the operation. It applies to both the keys sent and received.
+| Value Format  | MediaType   | Analogous to Key Format, but applied for the values.
+|==============================================================================
+
 ==== Hot Rod Hash Functions
 {brandname} makes use of a consistent hash function to place nodes on a hash
 wheel, and to place keys of entries on the same wheel to determine where
diff --git a/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility/BaseJsonTest.java b/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility/BaseJsonTest.java
index 6bc5cbe1e783..3694881ad6c0 100644
--- a/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility/BaseJsonTest.java
+++ b/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility/BaseJsonTest.java
@@ -22,9 +22,11 @@
 import org.codehaus.jackson.JsonNode;
 import org.codehaus.jackson.map.ObjectMapper;
 import org.codehaus.jackson.node.ObjectNode;
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.RemoteCache;
 import org.infinispan.client.hotrod.RemoteCacheManager;
 import org.infinispan.client.hotrod.Search;
+import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.configuration.cache.ConfigurationBuilder;
 import org.infinispan.manager.EmbeddedCacheManager;
 import org.infinispan.query.dsl.Query;
@@ -152,6 +154,12 @@ public void testHotRodInteroperability() throws Exception {
       CryptoCurrency litecoin = (CryptoCurrency) query.list().iterator().next();
       assertEquals(litecoin.getDescription(), "Litecoin");
       assertTrue(litecoin.getRank() == 4);
+
+      // Read as JSON from the Hot Rod client
+      Object jsonResult = remoteCache.withDataFormat(DataFormat.builder().valueType(MediaType.APPLICATION_JSON).build()).get("LTC");
+
+      JsonNode jsonNode = new ObjectMapper().readTree((byte[]) jsonResult);
+      assertEquals("Litecoin", jsonNode.get("description").asText());
    }
 
    @AfterClass
diff --git a/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility/EndpointInteroperabilityTest.java b/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility/EndpointInteroperabilityTest.java
index 18cb1f22ae2a..53a42f1b1224 100644
--- a/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility/EndpointInteroperabilityTest.java
+++ b/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility/EndpointInteroperabilityTest.java
@@ -6,6 +6,7 @@
 import static org.infinispan.client.hotrod.test.HotRodClientTestingUtil.startHotRodServer;
 import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JBOSS_MARSHALLING;
 import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JBOSS_MARSHALLING_TYPE;
+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;
 import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OCTET_STREAM;
 import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OCTET_STREAM_TYPE;
 import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN;
@@ -25,10 +26,12 @@
 import org.apache.commons.httpclient.methods.GetMethod;
 import org.apache.commons.httpclient.methods.PostMethod;
 import org.apache.commons.httpclient.methods.StringRequestEntity;
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.RemoteCache;
 import org.infinispan.client.hotrod.RemoteCacheManager;
 import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.dataconversion.StandardConversions;
+import org.infinispan.commons.marshall.IdentityMarshaller;
 import org.infinispan.commons.marshall.Marshaller;
 import org.infinispan.commons.marshall.UTF8StringMarshaller;
 import org.infinispan.commons.marshall.jboss.GenericJBossMarshaller;
@@ -45,7 +48,7 @@
 
 /**
  * Tests for interoperability between REST and HotRod endpoints without using compatibility mode,
- * but relying on MediaType configuration and HTTP Headers.
+ * but relying on MediaType configuration, HTTP Headers and Hot Rod client DataFormat support.
  *
  * @since 9.2
  */
@@ -92,7 +95,7 @@ protected void setup() throws Exception {
 
       hotRodServer = startHotRodServer(cacheManager);
 
-      bytesRemoteCache = createRemoteCacheManager(new NoOpMarshaller()).getCache(BYTES_CACHE_NAME);
+      bytesRemoteCache = createRemoteCacheManager(IdentityMarshaller.INSTANCE).getCache(BYTES_CACHE_NAME);
       defaultMarshalledRemoteCache = createRemoteCacheManager(null).getCache(MARSHALLED_CACHE_NAME);
       stringRemoteCache = createRemoteCacheManager(new UTF8StringMarshaller()).getCache(STRING_CACHE_NAME);
    }
@@ -115,7 +118,7 @@ private ConfigurationBuilder getStringsCacheConfiguration() {
       return builder;
    }
 
-   protected RemoteCacheManager createRemoteCacheManager(Marshaller marshaller) {
+   private RemoteCacheManager createRemoteCacheManager(Marshaller marshaller) {
       org.infinispan.client.hotrod.configuration.ConfigurationBuilder builder =
             new org.infinispan.client.hotrod.configuration.ConfigurationBuilder();
       builder.addServer().host("localhost").port(hotRodServer.getPort());
@@ -131,31 +134,43 @@ public void testStringKeysAndByteArrayValue() throws Exception {
       // 'application/x-jboss-marshalling' for both K and V.
       String key = "string-1";
       byte[] value = {1, 2, 3};
+      byte[] marshalledValue = new GenericJBossMarshaller().objectToByteBuffer(value);
+
       defaultMarshalledRemoteCache.put(key, value);
       assertEquals(defaultMarshalledRemoteCache.get(key), value);
 
-      // Read via rest the unmarshalled content.
-      Object bytesFromRest = new RestRequest().cache(MARSHALLED_CACHE_NAME)
-            .key(key).accept(APPLICATION_OCTET_STREAM)
-            .read();
-      assertArrayEquals((byte[]) bytesFromRest, value);
-
       // Read via Rest the raw content, as it is stored
       Object rawFromRest = new RestRequest().cache(MARSHALLED_CACHE_NAME)
             .key(key).accept(APPLICATION_JBOSS_MARSHALLING)
             .read();
 
-      assertArrayEquals((byte[]) rawFromRest, new GenericJBossMarshaller().objectToByteBuffer(value));
+      assertArrayEquals((byte[]) rawFromRest, marshalledValue);
 
       // Write via rest raw bytes
       String otherKey = "string-2";
       byte[] otherValue = {0x4, 0x5, 0x6};
+      byte[] otherValueMarshalled = new GenericJBossMarshaller().objectToByteBuffer(otherValue);
+
       new RestRequest().cache(MARSHALLED_CACHE_NAME)
             .key(otherKey).value(otherValue, APPLICATION_OCTET_STREAM)
             .write();
 
       // Read via Hot Rod
       assertEquals(defaultMarshalledRemoteCache.get(otherKey), otherValue);
+
+      // Read via Hot Rod using a String key, and getting the raw value (as it is stored) back
+      DataFormat format = DataFormat.builder()
+            .keyType(TEXT_PLAIN)
+            .valueType(APPLICATION_JBOSS_MARSHALLING).valueMarshaller(IdentityMarshaller.INSTANCE)
+            .build();
+      byte[] rawValue = (byte[]) defaultMarshalledRemoteCache.withDataFormat(format).get(otherKey);
+      assertArrayEquals(otherValueMarshalled, rawValue);
+
+      // Read via Hot Rod using a String key, and getting the original value back
+      DataFormat.builder().keyType(TEXT_PLAIN).build();
+      byte[] result = (byte[]) defaultMarshalledRemoteCache
+            .withDataFormat(DataFormat.builder().keyType(TEXT_PLAIN).build()).get(otherKey);
+      assertArrayEquals(otherValue, result);
    }
 
    @Test
@@ -238,6 +253,13 @@ public void testStringKeysAndStringValues() throws Exception {
 
       // Read via Hot Rod
       assertEquals(stringRemoteCache.get("key2"), "Testing");
+
+      // Get values as JSON from Hot Rod
+      Object jsonString = stringRemoteCache.withDataFormat(DataFormat.builder()
+            .valueType(APPLICATION_JSON).valueMarshaller(new UTF8StringMarshaller()).build())
+            .get("key");
+      assertEquals("\"Hello World\"", jsonString);
+
    }
 
    @Test
@@ -332,7 +354,7 @@ public void testCustomKeysAndByteValues() throws Exception {
       assertArrayEquals((byte[]) bytesFromRest, value);
    }
 
-   String getEndpoint(String cache) {
+   private String getEndpoint(String cache) {
       return String.format("http://localhost:%s/rest/%s", restServer.getPort(), cache);
    }
 
@@ -384,12 +406,12 @@ public RestRequest value(Object value) {
          return this;
       }
 
-      public RestRequest accept(MediaType valueContentType) {
+      RestRequest accept(MediaType valueContentType) {
          this.accept = valueContentType;
          return this;
       }
 
-      public void write() throws Exception {
+      void write() throws Exception {
          EntityEnclosingMethod post = new PostMethod(getEndpoint(this.cacheName) + "/" + this.key);
          if (this.keyContentType != null) {
             post.addRequestHeader("Key-Content-Type", this.keyContentType);
@@ -406,7 +428,7 @@ public void write() throws Exception {
          assertEquals(post.getStatusCode(), HttpStatus.SC_OK);
       }
 
-      public Object read() throws IOException {
+      Object read() throws IOException {
          HttpMethod get = new GetMethod(getEndpoint(this.cacheName) + "/" + this.key);
          if (this.accept != null) {
             get.setRequestHeader(ACCEPT, this.accept.toString());
diff --git a/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility/NoOpMarshaller.java b/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility/NoOpMarshaller.java
deleted file mode 100644
index c1b813e96760..000000000000
--- a/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility/NoOpMarshaller.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package org.infinispan.it.compatibility;
-
-import org.infinispan.commons.io.ByteBuffer;
-import org.infinispan.commons.io.ByteBufferImpl;
-import org.infinispan.commons.marshall.AbstractMarshaller;
-
-/**
- * Marshaller that writes and reads raw bytes only. Simulates a client that only reads and writes opaque byte[].
- *
- * @since 9.2
- */
-public class NoOpMarshaller extends AbstractMarshaller {
-
-   @Override
-   protected ByteBuffer objectToBuffer(Object o, int estimatedSize) {
-      if (!(o instanceof byte[])) throw new IllegalArgumentException("Content must be byte[]");
-      byte[] bytes = (byte[]) o;
-      return new ByteBufferImpl(bytes, 0, bytes.length);
-   }
-
-   @Override
-   public Object objectFromByteBuffer(byte[] buf, int offset, int length) {
-      return buf;
-   }
-
-   @Override
-   public boolean isMarshallable(Object o) {
-      return o instanceof byte[];
-   }
-}
diff --git a/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility/SpyMemcachedCompatibleMarshaller.java b/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility/SpyMemcachedCompatibleMarshaller.java
index 0f295bb9c4a6..f43ee6cc4b45 100644
--- a/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility/SpyMemcachedCompatibleMarshaller.java
+++ b/integrationtests/compatibility-mode-it/src/test/java/org/infinispan/it/compatibility/SpyMemcachedCompatibleMarshaller.java
@@ -1,5 +1,6 @@
 package org.infinispan.it.compatibility;
 
+import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.io.ByteBuffer;
 import org.infinispan.commons.io.ByteBufferImpl;
 import org.infinispan.commons.marshall.AbstractMarshaller;
@@ -34,4 +35,9 @@ public boolean isMarshallable(Object o) throws Exception {
       }
    }
 
+   @Override
+   public MediaType mediaType() {
+      return MediaType.parse("application/x-memcached");
+   }
+
 }
diff --git a/jcache/remote/src/main/java/org/infinispan/jcache/remote/RemoteCacheWrapper.java b/jcache/remote/src/main/java/org/infinispan/jcache/remote/RemoteCacheWrapper.java
index aec354ee9b64..5f3835cc7f56 100644
--- a/jcache/remote/src/main/java/org/infinispan/jcache/remote/RemoteCacheWrapper.java
+++ b/jcache/remote/src/main/java/org/infinispan/jcache/remote/RemoteCacheWrapper.java
@@ -7,6 +7,7 @@
 import java.util.function.BiFunction;
 
 import org.infinispan.client.hotrod.CacheTopologyInfo;
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.Flag;
 import org.infinispan.client.hotrod.MetadataValue;
 import org.infinispan.client.hotrod.RemoteCache;
@@ -161,7 +162,7 @@ public void putAll(Map<? extends K, ? extends V> map, long lifespan, TimeUnit un
 
    @Override
    public void putAll(Map<? extends K, ? extends V> map, long lifespan, TimeUnit lifespanUnit, long maxIdleTime,
-         TimeUnit maxIdleTimeUnit) {
+                      TimeUnit maxIdleTimeUnit) {
       delegate.putAll(map, lifespan, lifespanUnit, maxIdleTime, maxIdleTimeUnit);
    }
 
@@ -177,7 +178,7 @@ public CompletableFuture<Void> putAllAsync(Map<? extends K, ? extends V> data, l
 
    @Override
    public CompletableFuture<Void> putAllAsync(Map<? extends K, ? extends V> data, long lifespan, TimeUnit lifespanUnit,
-         long maxIdle, TimeUnit maxIdleUnit) {
+                                              long maxIdle, TimeUnit maxIdleUnit) {
       return delegate.putAllAsync(data, lifespan, lifespanUnit, maxIdle, maxIdleUnit);
    }
 
@@ -193,7 +194,7 @@ public CompletableFuture<V> putAsync(K key, V value, long lifespan, TimeUnit uni
 
    @Override
    public CompletableFuture<V> putAsync(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdle,
-         TimeUnit maxIdleUnit) {
+                                        TimeUnit maxIdleUnit) {
       return delegate.putAsync(key, value, lifespan, lifespanUnit, maxIdle, maxIdleUnit);
    }
 
@@ -224,7 +225,7 @@ public CompletableFuture<V> putIfAbsentAsync(K key, V value, long lifespan, Time
 
    @Override
    public CompletableFuture<V> putIfAbsentAsync(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdle,
-         TimeUnit maxIdleUnit) {
+                                                TimeUnit maxIdleUnit) {
       return delegate.putIfAbsentAsync(key, value, lifespan, lifespanUnit, maxIdle, maxIdleUnit);
    }
 
@@ -290,25 +291,25 @@ public boolean replace(K key, V oldValue, V value, long lifespan, TimeUnit unit)
 
    @Override
    public boolean replace(K key, V oldValue, V value, long lifespan, TimeUnit lifespanUnit, long maxIdleTime,
-         TimeUnit maxIdleTimeUnit) {
+                          TimeUnit maxIdleTimeUnit) {
       return delegate.replace(key, oldValue, value, lifespan, lifespanUnit, maxIdleTime, maxIdleTimeUnit);
    }
 
    @Override
    public V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
-      return delegate.merge(key,  value,  remappingFunction);
+      return delegate.merge(key, value, remappingFunction);
    }
 
    @Override
    public V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction, long lifespan,
                   TimeUnit lifespanUnit) {
-      return delegate.merge(key,  value,  remappingFunction, lifespan, lifespanUnit);
+      return delegate.merge(key, value, remappingFunction, lifespan, lifespanUnit);
    }
 
    @Override
    public V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction, long lifespan,
                   TimeUnit lifespanUnit, long maxIdleTime, TimeUnit maxIdleTimeUnit) {
-      return delegate.merge(key,  value,  remappingFunction, lifespan, lifespanUnit, maxIdleTime, maxIdleTimeUnit);
+      return delegate.merge(key, value, remappingFunction, lifespan, lifespanUnit, maxIdleTime, maxIdleTimeUnit);
    }
 
    @Override
@@ -323,7 +324,7 @@ public CompletableFuture<V> replaceAsync(K key, V value, long lifespan, TimeUnit
 
    @Override
    public CompletableFuture<V> replaceAsync(K key, V value, long lifespan, TimeUnit lifespanUnit, long maxIdle,
-         TimeUnit maxIdleUnit) {
+                                            TimeUnit maxIdleUnit) {
       return delegate.replaceAsync(key, value, lifespan, lifespanUnit, maxIdle, maxIdleUnit);
    }
 
@@ -339,7 +340,7 @@ public CompletableFuture<Boolean> replaceAsync(K key, V oldValue, V newValue, lo
 
    @Override
    public CompletableFuture<Boolean> replaceAsync(K key, V oldValue, V newValue, long lifespan, TimeUnit lifespanUnit,
-         long maxIdle, TimeUnit maxIdleUnit) {
+                                                  long maxIdle, TimeUnit maxIdleUnit) {
       return delegate.replaceAsync(key, oldValue, newValue, lifespan, lifespanUnit, maxIdle, maxIdleUnit);
    }
 
@@ -375,7 +376,7 @@ public CompletableFuture<Boolean> replaceWithVersionAsync(K key, V newValue, lon
 
    @Override
    public CompletableFuture<Boolean> replaceWithVersionAsync(K key, V newValue, long version, int lifespanSeconds,
-         int maxIdleSeconds) {
+                                                             int maxIdleSeconds) {
       return delegate.replaceWithVersionAsync(key, newValue, version, lifespanSeconds, maxIdleSeconds);
    }
 
@@ -445,8 +446,18 @@ public CloseableIterator<Entry<Object, MetadataValue<Object>>> retrieveEntriesWi
       return delegate.retrieveEntriesWithMetadata(segments, batchSize);
    }
 
+   @Override
+   public RemoteCache<K, V> withDataFormat(DataFormat dataFormat) {
+      return delegate.withDataFormat(dataFormat);
+   }
+
    @Override
    public StreamingRemoteCache<K> streaming() {
       return delegate.streaming();
    }
+
+   @Override
+   public DataFormat getDataFormat() {
+      return delegate.getDataFormat();
+   }
 }
diff --git a/persistence/remote/src/main/java/org/infinispan/persistence/remote/wrapper/HotRodEntryMarshaller.java b/persistence/remote/src/main/java/org/infinispan/persistence/remote/wrapper/HotRodEntryMarshaller.java
index 5723744725ca..d93621702cc7 100644
--- a/persistence/remote/src/main/java/org/infinispan/persistence/remote/wrapper/HotRodEntryMarshaller.java
+++ b/persistence/remote/src/main/java/org/infinispan/persistence/remote/wrapper/HotRodEntryMarshaller.java
@@ -3,6 +3,7 @@
 import java.io.IOException;
 import java.util.Arrays;
 
+import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.io.ByteBuffer;
 import org.infinispan.commons.io.ByteBufferFactory;
 import org.infinispan.commons.marshall.BufferSizePredictor;
@@ -40,12 +41,12 @@ public Object objectFromByteBuffer(byte[] buf) throws IOException, ClassNotFound
 
    @Override
    public Object objectFromByteBuffer(byte[] buf, int offset, int length) throws IOException, ClassNotFoundException {
-      return Arrays.copyOfRange(buf, offset, offset+length);
+      return Arrays.copyOfRange(buf, offset, offset + length);
    }
 
    @Override
    public ByteBuffer objectToBuffer(Object o) throws IOException, InterruptedException {
-      byte[] b = (byte[])o;
+      byte[] b = (byte[]) o;
       return byteBufferFactory.newByteBuffer(b, 0, b.length);
    }
 
@@ -59,11 +60,16 @@ public BufferSizePredictor getBufferSizePredictor(Object o) {
       return predictor;
    }
 
+   @Override
+   public MediaType mediaType() {
+      return MediaType.APPLICATION_OCTET_STREAM;
+   }
+
    class IdentityBufferSizePredictor implements BufferSizePredictor {
 
       @Override
       public int nextSize(Object obj) {
-         return ((byte[])obj).length;
+         return ((byte[]) obj).length;
       }
 
       @Override
diff --git a/persistence/remote/src/test/java/org/infinispan/persistence/remote/upgrade/CallbackRemoteIterator.java b/persistence/remote/src/test/java/org/infinispan/persistence/remote/upgrade/CallbackRemoteIterator.java
index 07dac2aeb6dd..9d9aa02ace1b 100644
--- a/persistence/remote/src/test/java/org/infinispan/persistence/remote/upgrade/CallbackRemoteIterator.java
+++ b/persistence/remote/src/test/java/org/infinispan/persistence/remote/upgrade/CallbackRemoteIterator.java
@@ -6,6 +6,7 @@
 import java.util.Map;
 import java.util.Set;
 
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.impl.iteration.RemoteCloseableIterator;
 import org.infinispan.client.hotrod.impl.operations.OperationsFactory;
 import org.infinispan.commons.marshall.jboss.GenericJBossMarshaller;
@@ -18,8 +19,8 @@ class CallbackRemoteIterator<E> extends RemoteCloseableIterator<E> {
    private Set<Object> callBackKeys = new HashSet<>();
    private IterationCallBack callback;
 
-   CallbackRemoteIterator(OperationsFactory operationsFactory, int batchSize, Set<Integer> segments, boolean metadata) {
-      super(operationsFactory, new GenericJBossMarshaller(), batchSize, segments, metadata);
+   CallbackRemoteIterator(OperationsFactory operationsFactory, int batchSize, Set<Integer> segments, boolean metadata, DataFormat dataFormat) {
+      super(operationsFactory, new GenericJBossMarshaller(), batchSize, segments, metadata, dataFormat);
    }
 
    @Override
diff --git a/persistence/remote/src/test/java/org/infinispan/persistence/remote/upgrade/HotRodUpgradeSynchronizerTest.java b/persistence/remote/src/test/java/org/infinispan/persistence/remote/upgrade/HotRodUpgradeSynchronizerTest.java
index b1e1e9500e21..589f829080ec 100644
--- a/persistence/remote/src/test/java/org/infinispan/persistence/remote/upgrade/HotRodUpgradeSynchronizerTest.java
+++ b/persistence/remote/src/test/java/org/infinispan/persistence/remote/upgrade/HotRodUpgradeSynchronizerTest.java
@@ -150,7 +150,7 @@ private void doWhenSourceIterationReaches(String key, TestCluster cluster, Strin
          RemoteCacheImpl spy = spy(remoteCache);
          doAnswer(invocation -> {
             Object[] params = invocation.getArguments();
-            CallbackRemoteIterator<Object> remoteCloseableIterator = new CallbackRemoteIterator<>(spy.getOperationsFactory(), (int) params[1], null, true);
+            CallbackRemoteIterator<Object> remoteCloseableIterator = new CallbackRemoteIterator<>(spy.getOperationsFactory(), (int) params[1], null, true, spy.getDataFormat());
             remoteCloseableIterator.addCallback(callback, key);
             remoteCloseableIterator.start();
             return remoteCloseableIterator;
diff --git a/remote-query/remote-query-client/src/main/java/org/infinispan/query/remote/client/BaseProtoStreamMarshaller.java b/remote-query/remote-query-client/src/main/java/org/infinispan/query/remote/client/BaseProtoStreamMarshaller.java
index 930cc1b7d519..f95df9280ad9 100644
--- a/remote-query/remote-query-client/src/main/java/org/infinispan/query/remote/client/BaseProtoStreamMarshaller.java
+++ b/remote-query/remote-query-client/src/main/java/org/infinispan/query/remote/client/BaseProtoStreamMarshaller.java
@@ -2,6 +2,7 @@
 
 import java.io.IOException;
 
+import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.io.ByteBuffer;
 import org.infinispan.commons.io.ByteBufferImpl;
 import org.infinispan.commons.marshall.AbstractMarshaller;
@@ -56,4 +57,9 @@ protected ByteBuffer objectToBuffer(Object o, int estimatedSize) throws IOExcept
       byte[] bytes = ProtobufUtil.toWrappedByteArray(getSerializationContext(), o);
       return new ByteBufferImpl(bytes, 0, bytes.length);
    }
+
+   @Override
+   public MediaType mediaType() {
+      return MediaType.APPLICATION_PROTOSTREAM;
+   }
 }
diff --git a/remote-query/remote-query-server/src/main/java/org/infinispan/query/remote/impl/dataconversion/ProtostreamJsonTranscoder.java b/remote-query/remote-query-server/src/main/java/org/infinispan/query/remote/impl/dataconversion/ProtostreamJsonTranscoder.java
index 10c3393c7610..79cdeeffe82d 100644
--- a/remote-query/remote-query-server/src/main/java/org/infinispan/query/remote/impl/dataconversion/ProtostreamJsonTranscoder.java
+++ b/remote-query/remote-query-server/src/main/java/org/infinispan/query/remote/impl/dataconversion/ProtostreamJsonTranscoder.java
@@ -12,6 +12,7 @@
 import java.util.Set;
 
 import org.infinispan.commons.dataconversion.MediaType;
+import org.infinispan.commons.dataconversion.StandardConversions;
 import org.infinispan.commons.dataconversion.Transcoder;
 import org.infinispan.commons.logging.LogFactory;
 import org.infinispan.protostream.ProtobufUtil;
@@ -39,7 +40,8 @@ public ProtostreamJsonTranscoder(SerializationContext ctx) {
    public Object transcode(Object content, MediaType contentType, MediaType destinationType) {
       try {
          if (destinationType.match(APPLICATION_JSON)) {
-            return ProtobufUtil.toCanonicalJSON(ctx, (byte[]) content);
+            String converted = ProtobufUtil.toCanonicalJSON(ctx, (byte[]) content);
+            return StandardConversions.convertCharset(converted, contentType.getCharset(), destinationType.getCharset());
          }
          if (destinationType.match(APPLICATION_PROTOSTREAM)) {
             Reader reader;
diff --git a/remote-query/remote-query-server/src/test/java/org/infinispan/query/remote/impl/dataconversion/ProtostreamJsonTranscoderTest.java b/remote-query/remote-query-server/src/test/java/org/infinispan/query/remote/impl/dataconversion/ProtostreamJsonTranscoderTest.java
index 0253eab2ebf7..428ac7439023 100644
--- a/remote-query/remote-query-server/src/test/java/org/infinispan/query/remote/impl/dataconversion/ProtostreamJsonTranscoderTest.java
+++ b/remote-query/remote-query-server/src/test/java/org/infinispan/query/remote/impl/dataconversion/ProtostreamJsonTranscoderTest.java
@@ -1,5 +1,10 @@
 package org.infinispan.query.remote.impl.dataconversion;
 
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+
+import java.io.IOException;
+
 import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.protostream.FileDescriptorSource;
 import org.infinispan.protostream.ProtobufUtil;
@@ -9,11 +14,6 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import java.io.IOException;
-
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-
 
 @Test(groups = "functional", testName = "query.remote.impl.ProtostreamJsonTranscoderTest")
 public class ProtostreamJsonTranscoderTest extends AbstractTranscoderTest {
@@ -57,7 +57,7 @@ public void testTranscoderTranscode() throws Exception {
       Object transcodedBack = transcoder.transcode(transcoded, MediaType.APPLICATION_PROTOSTREAM, MediaType.APPLICATION_JSON);
       assertEquals(
             dataSrc.replace(" ", ""),
-            ((String) transcodedBack).replace(" ", "").replace("\n", ""),
+            (new String((byte[]) transcodedBack)).replace(" ", "").replace("\n", ""),
             "Must be the same JSON string"
       );
    }
diff --git a/server/core/pom.xml b/server/core/pom.xml
index 24b7953ebb47..40520563e120 100644
--- a/server/core/pom.xml
+++ b/server/core/pom.xml
@@ -1,5 +1,6 @@
 <?xml version='1.0' encoding='UTF-8'?>
-<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
+<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <modelVersion>4.0.0</modelVersion>
    <parent>
       <groupId>org.infinispan</groupId>
@@ -23,16 +24,16 @@
          <groupId>io.netty</groupId>
          <artifactId>netty-handler</artifactId>
       </dependency>
-      <!-- Workaround for ISPN-8843 -->
-      <dependency>
+       <!-- Workaround for ISPN-8843 -->
+       <dependency>
          <groupId>org.conscrypt</groupId>
          <artifactId>conscrypt-openjdk</artifactId>
          <version>${version.netty-conscrypt-optional}</version>
          <classifier>${os.detected.classifier}</classifier>
          <optional>true</optional>
       </dependency>
-      <!-- Workaround for ISPN-8843 -->
-      <dependency>
+       <!-- Workaround for ISPN-8843 -->
+       <dependency>
          <groupId>io.netty</groupId>
          <artifactId>netty-tcnative</artifactId>
          <version>${version.netty-tcnative-boringssl-static}</version>
@@ -52,6 +53,14 @@
          <groupId>org.infinispan</groupId>
          <artifactId>infinispan-tasks</artifactId>
       </dependency>
+      <dependency>
+         <groupId>org.codehaus.jackson</groupId>
+         <artifactId>jackson-mapper-asl</artifactId>
+      </dependency>
+      <dependency>
+         <groupId>com.thoughtworks.xstream</groupId>
+         <artifactId>xstream</artifactId>
+      </dependency>
       <dependency>
          <groupId>org.infinispan</groupId>
          <artifactId>infinispan-query</artifactId>
@@ -76,7 +85,7 @@
 
    <build>
       <!-- Workaround for ISPN-8843 -->
-      <extensions>
+       <extensions>
          <extension>
             <groupId>kr.motd.maven</groupId>
             <artifactId>os-maven-plugin</artifactId>
diff --git a/server/core/src/main/java/org/infinispan/server/core/LifecycleCallbacks.java b/server/core/src/main/java/org/infinispan/server/core/LifecycleCallbacks.java
index 733c5d4edea6..f209ee0aa2f3 100644
--- a/server/core/src/main/java/org/infinispan/server/core/LifecycleCallbacks.java
+++ b/server/core/src/main/java/org/infinispan/server/core/LifecycleCallbacks.java
@@ -4,6 +4,11 @@
 import org.infinispan.factories.GlobalComponentRegistry;
 import org.infinispan.factories.components.ComponentMetadataRepo;
 import org.infinispan.lifecycle.ModuleLifecycle;
+import org.infinispan.marshall.core.EncoderRegistry;
+import org.infinispan.server.core.dataconversion.JBossMarshallingTranscoder;
+import org.infinispan.server.core.dataconversion.JavaSerializationTranscoder;
+import org.infinispan.server.core.dataconversion.JsonTranscoder;
+import org.infinispan.server.core.dataconversion.XMLTranscoder;
 
 /**
  * Module lifecycle callbacks implementation that enables module specific
@@ -19,5 +24,11 @@ public class LifecycleCallbacks implements ModuleLifecycle {
    @Override
    public void cacheManagerStarting(GlobalComponentRegistry gcr, GlobalConfiguration globalConfiguration) {
       componentMetadataRepo = gcr.getComponentMetadataRepo();
+      EncoderRegistry encoderRegistry = gcr.getComponent(EncoderRegistry.class);
+      encoderRegistry.registerTranscoder(new JsonTranscoder());
+      encoderRegistry.registerTranscoder(new JBossMarshallingTranscoder(encoderRegistry));
+      encoderRegistry.registerTranscoder(new XMLTranscoder());
+      encoderRegistry.registerTranscoder(new JavaSerializationTranscoder());
+
    }
 }
diff --git a/server/rest/src/main/java/org/infinispan/rest/dataconversion/JBossMarshallingTranscoder.java b/server/core/src/main/java/org/infinispan/server/core/dataconversion/JBossMarshallingTranscoder.java
similarity index 55%
rename from server/rest/src/main/java/org/infinispan/rest/dataconversion/JBossMarshallingTranscoder.java
rename to server/core/src/main/java/org/infinispan/server/core/dataconversion/JBossMarshallingTranscoder.java
index d1c6c40a3127..80e7fd1e8886 100644
--- a/server/rest/src/main/java/org/infinispan/rest/dataconversion/JBossMarshallingTranscoder.java
+++ b/server/core/src/main/java/org/infinispan/server/core/dataconversion/JBossMarshallingTranscoder.java
@@ -1,16 +1,22 @@
-package org.infinispan.rest.dataconversion;
+package org.infinispan.server.core.dataconversion;
 
 import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JBOSS_MARSHALLING;
+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;
 import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OBJECT;
 import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OCTET_STREAM;
 import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN;
+import static org.infinispan.commons.dataconversion.StandardConversions.convertTextToObject;
 import static org.infinispan.commons.dataconversion.StandardConversions.decodeObjectContent;
 import static org.infinispan.commons.dataconversion.StandardConversions.decodeOctetStream;
 
+import java.io.IOException;
+
 import org.infinispan.commons.dataconversion.Encoder;
 import org.infinispan.commons.dataconversion.GenericJbossMarshallerEncoder;
 import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.dataconversion.OneToManyTranscoder;
+import org.infinispan.commons.dataconversion.StandardConversions;
+import org.infinispan.commons.dataconversion.Transcoder;
 import org.infinispan.marshall.core.EncoderRegistry;
 import org.infinispan.util.logging.Log;
 import org.infinispan.util.logging.LogFactory;
@@ -24,10 +30,12 @@ public class JBossMarshallingTranscoder extends OneToManyTranscoder {
 
    protected final static Log logger = LogFactory.getLog(JBossMarshallingTranscoder.class, Log.class);
    private final Encoder encoder;
+   private final Transcoder jsonObjectTranscoder;
 
    public JBossMarshallingTranscoder(EncoderRegistry encoderRegistry) {
-      super(APPLICATION_JBOSS_MARSHALLING, APPLICATION_OCTET_STREAM, TEXT_PLAIN, APPLICATION_OBJECT);
+      super(APPLICATION_JBOSS_MARSHALLING, APPLICATION_OCTET_STREAM, TEXT_PLAIN, APPLICATION_OBJECT, APPLICATION_JSON);
       encoder = encoderRegistry.getEncoder(GenericJbossMarshallerEncoder.class, null);
+      jsonObjectTranscoder = encoderRegistry.getTranscoder(APPLICATION_JSON, APPLICATION_OBJECT);
    }
 
    @Override
@@ -40,15 +48,40 @@ public Object transcode(Object content, MediaType contentType, MediaType destina
          if (contentType.match(APPLICATION_OCTET_STREAM)) {
             decoded = decodeOctetStream(content, destinationType);
          }
+         if (contentType.match(TEXT_PLAIN)) {
+            decoded = convertTextToObject(content, contentType);
+         }
+         if (contentType.match(APPLICATION_JSON)) {
+            decoded = jsonObjectTranscoder.transcode(content, contentType, MediaType.APPLICATION_OBJECT);
+         }
          return encoder.toStorage(decoded);
       }
       if (destinationType.match(MediaType.APPLICATION_OCTET_STREAM)) {
-         return encoder.fromStorage(content);
+         try {
+            Object unmarshalled = encoder.fromStorage(content);
+            if(unmarshalled instanceof byte[]) {
+               return unmarshalled;
+            }
+            return StandardConversions.convertJavaToOctetStream(unmarshalled, MediaType.APPLICATION_OBJECT);
+         } catch (IOException | InterruptedException e) {
+            throw logger.unsupportedContent(content);
+         }
       }
       if (destinationType.match(MediaType.TEXT_PLAIN)) {
          String fromStorage = encoder.fromStorage(content).toString();
          return fromStorage.getBytes(destinationType.getCharset());
       }
+      if (destinationType.match(MediaType.APPLICATION_OBJECT)) {
+         return encoder.fromStorage(content);
+      }
+      if (destinationType.match(MediaType.APPLICATION_JSON)) {
+         // A more efficient way would be to read the jboss marshalling binary payload and convert it directly to json
+         // For now it will unmarshall as Java Object first.
+         Object fromStorage = encoder.fromStorage(content);
+         Object result = jsonObjectTranscoder.transcode(fromStorage, MediaType.APPLICATION_OBJECT, MediaType.APPLICATION_JSON);
+         return StandardConversions.convertTextToOctetStream(result, MediaType.APPLICATION_JSON);
+      }
+
       throw logger.unsupportedContent(content);
    }
 
diff --git a/server/rest/src/main/java/org/infinispan/rest/dataconversion/JavaSerializationTranscoder.java b/server/core/src/main/java/org/infinispan/server/core/dataconversion/JavaSerializationTranscoder.java
similarity index 96%
rename from server/rest/src/main/java/org/infinispan/rest/dataconversion/JavaSerializationTranscoder.java
rename to server/core/src/main/java/org/infinispan/server/core/dataconversion/JavaSerializationTranscoder.java
index a2f4293c4d23..7b04f13485f3 100644
--- a/server/rest/src/main/java/org/infinispan/rest/dataconversion/JavaSerializationTranscoder.java
+++ b/server/core/src/main/java/org/infinispan/server/core/dataconversion/JavaSerializationTranscoder.java
@@ -1,4 +1,4 @@
-package org.infinispan.rest.dataconversion;
+package org.infinispan.server.core.dataconversion;
 
 import java.io.IOException;
 import java.util.HashSet;
diff --git a/server/rest/src/main/java/org/infinispan/rest/dataconversion/JsonTranscoder.java b/server/core/src/main/java/org/infinispan/server/core/dataconversion/JsonTranscoder.java
similarity index 73%
rename from server/rest/src/main/java/org/infinispan/rest/dataconversion/JsonTranscoder.java
rename to server/core/src/main/java/org/infinispan/server/core/dataconversion/JsonTranscoder.java
index 42686a244237..7f0fb8729052 100644
--- a/server/rest/src/main/java/org/infinispan/rest/dataconversion/JsonTranscoder.java
+++ b/server/core/src/main/java/org/infinispan/server/core/dataconversion/JsonTranscoder.java
@@ -1,10 +1,9 @@
-package org.infinispan.rest.dataconversion;
+package org.infinispan.server.core.dataconversion;
 
 import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;
 import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OBJECT;
 import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OCTET_STREAM;
 import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN;
-import static org.infinispan.rest.JSONConstants.TYPE;
 
 import java.io.IOException;
 import java.nio.charset.Charset;
@@ -17,6 +16,7 @@
 import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.dataconversion.OneToManyTranscoder;
 import org.infinispan.commons.dataconversion.StandardConversions;
+import org.infinispan.server.core.dataconversion.json.SecureTypeResolverBuilder;
 import org.infinispan.util.logging.Log;
 import org.infinispan.util.logging.LogFactory;
 
@@ -27,19 +27,27 @@ public class JsonTranscoder extends OneToManyTranscoder {
 
    protected final static Log logger = LogFactory.getLog(JsonTranscoder.class, Log.class);
 
-   private final ObjectMapper jsonMapper = new ObjectMapper().setDefaultTyping(
-         new ObjectMapper.DefaultTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL) {
-            {
-               init(JsonTypeInfo.Id.CLASS, null);
-               inclusion(JsonTypeInfo.As.PROPERTY);
-               typeProperty(TYPE);
-            }
+   public static final String TYPE_PROPERTY = "_type";
 
-            @Override
-            public boolean useForType(JavaType t) {
-               return !t.isContainerType() && super.useForType(t);
-            }
-         });
+   private static class MapperHolder {
+      static final ObjectMapper INSTANCE = new ObjectMapper().setDefaultTyping(
+            new SecureTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL) {
+               {
+                  init(JsonTypeInfo.Id.CLASS, null);
+                  inclusion(JsonTypeInfo.As.PROPERTY);
+                  typeProperty(TYPE_PROPERTY);
+               }
+
+               @Override
+               public boolean useForType(JavaType t) {
+                  return !t.isContainerType() && super.useForType(t);
+               }
+            });
+   }
+
+   public static ObjectMapper getMapper() {
+      return MapperHolder.INSTANCE;
+   }
 
    public JsonTranscoder() {
       super(APPLICATION_JSON, APPLICATION_OBJECT, APPLICATION_OCTET_STREAM, TEXT_PLAIN);
@@ -62,9 +70,9 @@ public Object transcode(Object content, MediaType contentType, MediaType destina
          try {
             if (content instanceof byte[]) {
                String contentAsString = new String((byte[]) content, destinationType.getCharset());
-               return jsonMapper.writeValueAsString(contentAsString);
+               return getMapper().writeValueAsBytes(contentAsString);
             }
-            return jsonMapper.writeValueAsString(content);
+            return getMapper().writeValueAsBytes(content);
          } catch (IOException e) {
             throw new CacheException(e);
          }
@@ -72,9 +80,9 @@ public Object transcode(Object content, MediaType contentType, MediaType destina
       if (destinationType.match(APPLICATION_OBJECT)) {
          try {
             if (content instanceof byte[]) {
-               return jsonMapper.readValue((byte[]) content, Object.class);
+               return getMapper().readValue((byte[]) content, Object.class);
             }
-            return jsonMapper.readValue((String) content, Object.class);
+            return getMapper().readValue((String) content, Object.class);
          } catch (IOException e) {
             throw new CacheException(e);
          }
diff --git a/server/core/src/main/java/org/infinispan/server/core/dataconversion/TranscodingException.java b/server/core/src/main/java/org/infinispan/server/core/dataconversion/TranscodingException.java
new file mode 100644
index 000000000000..d1aaa86a57ff
--- /dev/null
+++ b/server/core/src/main/java/org/infinispan/server/core/dataconversion/TranscodingException.java
@@ -0,0 +1,8 @@
+package org.infinispan.server.core.dataconversion;
+
+public class TranscodingException extends RuntimeException {
+
+   public TranscodingException(String message) {
+      super(message);
+   }
+}
diff --git a/server/rest/src/main/java/org/infinispan/rest/dataconversion/XMLTranscoder.java b/server/core/src/main/java/org/infinispan/server/core/dataconversion/XMLTranscoder.java
similarity index 70%
rename from server/rest/src/main/java/org/infinispan/rest/dataconversion/XMLTranscoder.java
rename to server/core/src/main/java/org/infinispan/server/core/dataconversion/XMLTranscoder.java
index acd9cae93ce0..7ab63458c704 100644
--- a/server/rest/src/main/java/org/infinispan/rest/dataconversion/XMLTranscoder.java
+++ b/server/core/src/main/java/org/infinispan/server/core/dataconversion/XMLTranscoder.java
@@ -1,4 +1,4 @@
-package org.infinispan.rest.dataconversion;
+package org.infinispan.server.core.dataconversion;
 
 import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OBJECT;
 import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OCTET_STREAM;
@@ -10,7 +10,6 @@
 import java.io.InputStreamReader;
 import java.io.Reader;
 import java.io.StringReader;
-import java.nio.charset.Charset;
 
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.parsers.SAXParserFactory;
@@ -18,8 +17,9 @@
 import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.dataconversion.OneToManyTranscoder;
 import org.infinispan.commons.dataconversion.StandardConversions;
-import org.infinispan.rest.logging.Log;
-import org.infinispan.util.logging.LogFactory;
+import org.infinispan.commons.logging.LogFactory;
+import org.infinispan.marshall.core.ExternallyMarshallable;
+import org.infinispan.server.core.logging.Log;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 import org.xml.sax.XMLReader;
@@ -34,7 +34,8 @@
  */
 public class XMLTranscoder extends OneToManyTranscoder {
 
-   protected final static Log logger = LogFactory.getLog(XMLTranscoder.class, Log.class);
+   private static final Log logger = LogFactory.getLog(XMLTranscoder.class, Log.class);
+
    private static final SAXParserFactory SAXFACTORY = SAXParserFactory.newInstance();
 
    private static class XStreamHolder {
@@ -43,6 +44,7 @@ private static class XStreamHolder {
 
    public XMLTranscoder() {
       super(APPLICATION_XML, APPLICATION_OBJECT, APPLICATION_OCTET_STREAM, TEXT_PLAIN);
+      XStreamHolder.XStream.addPermission(ExternallyMarshallable::isAllowed);
    }
 
    @Override
@@ -53,13 +55,16 @@ public Object transcode(Object content, MediaType contentType, MediaType destina
             return XStreamHolder.XStream.toXML(decoded);
          }
          if (contentType.match(TEXT_PLAIN)) {
-            validate(content, contentType.getCharset());
-            return StandardConversions.convertCharset(content, contentType.getCharset(), destinationType.getCharset());
+            String inputText = StandardConversions.convertTextToObject(content, contentType);
+            if (isWellFormed(inputText.getBytes())) return inputText.getBytes();
+            String xmlString = XStreamHolder.XStream.toXML(inputText);
+            return xmlString.getBytes(destinationType.getCharset());
          }
          if (contentType.match(APPLICATION_OCTET_STREAM)) {
-            byte[] bytes = StandardConversions.decodeOctetStream(content, contentType);
-            validate(content, contentType.getCharset());
-            return StandardConversions.convertOctetStreamToText(bytes, destinationType);
+            String inputText = StandardConversions.convertTextToObject(content, contentType);
+            if (isWellFormed(inputText.getBytes())) return inputText.getBytes();
+            String xmlString = XStreamHolder.XStream.toXML(inputText);
+            return xmlString.getBytes(destinationType.getCharset());
          }
       }
       if (destinationType.match(APPLICATION_OCTET_STREAM)) {
@@ -75,21 +80,20 @@ public Object transcode(Object content, MediaType contentType, MediaType destina
                   new StringReader(content.toString());
             return XStreamHolder.XStream.fromXML(xmlReader);
          } catch (XStreamException e) {
-            throw logger.errorTranscoding(e);
+            throw logger.errorDuringTranscoding(e);
          }
       }
-      throw logger.unsupportedDataFormat(contentType.toString());
+      throw logger.unsupportedDataFormat(contentType);
    }
 
-   private void validate(Object content, Charset contentType) {
+   private boolean isWellFormed(byte[] content) {
       XMLReader xmlReader;
       try {
          xmlReader = SAXFACTORY.newSAXParser().getXMLReader();
-         byte[] source = content instanceof byte[] ? (byte[]) content : content.toString().getBytes(contentType);
-         xmlReader.parse(new InputSource(new ByteArrayInputStream(source)));
+         xmlReader.parse(new InputSource(new ByteArrayInputStream(content)));
       } catch (SAXException | IOException | ParserConfigurationException e) {
-         throw logger.cannotConvertToXML(e);
+         return false;
       }
+      return true;
    }
-
 }
diff --git a/server/core/src/main/java/org/infinispan/server/core/dataconversion/json/SecureTypeIdResolver.java b/server/core/src/main/java/org/infinispan/server/core/dataconversion/json/SecureTypeIdResolver.java
new file mode 100644
index 000000000000..d1b80ecbafe4
--- /dev/null
+++ b/server/core/src/main/java/org/infinispan/server/core/dataconversion/json/SecureTypeIdResolver.java
@@ -0,0 +1,54 @@
+package org.infinispan.server.core.dataconversion.json;
+
+import org.codehaus.jackson.annotate.JsonTypeInfo;
+import org.codehaus.jackson.map.jsontype.TypeIdResolver;
+import org.codehaus.jackson.type.JavaType;
+import org.infinispan.marshall.core.ExternallyMarshallable;
+import org.infinispan.util.logging.Log;
+import org.infinispan.util.logging.LogFactory;
+
+/**
+ * Jackson TypeIdResolver that checks the serialization whitelist before deserializing JSON types.
+ *
+ * @since 9.3
+ */
+public class SecureTypeIdResolver implements TypeIdResolver {
+
+   protected final static Log logger = LogFactory.getLog(SecureTypeIdResolver.class, Log.class);
+
+   private TypeIdResolver internalTypeIdResolver;
+
+   SecureTypeIdResolver(TypeIdResolver typeIdResolver) {
+      this.internalTypeIdResolver = typeIdResolver;
+   }
+
+   @Override
+   public void init(JavaType baseType) {
+      internalTypeIdResolver.init(baseType);
+   }
+
+   @Override
+   public String idFromValue(Object value) {
+      return internalTypeIdResolver.idFromValue(value);
+   }
+
+   @Override
+   public String idFromValueAndType(Object value, Class<?> suggestedType) {
+      return internalTypeIdResolver.idFromValueAndType(value, suggestedType);
+   }
+
+   @Override
+   public JavaType typeFromId(String id) {
+      JavaType javaType = internalTypeIdResolver.typeFromId(id);
+      Class<?> rawClass = javaType.getRawClass();
+      if (!ExternallyMarshallable.isAllowed(rawClass)) {
+         throw logger.errorDeserializing(rawClass);
+      }
+      return javaType;
+   }
+
+   @Override
+   public JsonTypeInfo.Id getMechanism() {
+      return internalTypeIdResolver.getMechanism();
+   }
+}
diff --git a/server/core/src/main/java/org/infinispan/server/core/dataconversion/json/SecureTypeResolverBuilder.java b/server/core/src/main/java/org/infinispan/server/core/dataconversion/json/SecureTypeResolverBuilder.java
new file mode 100644
index 000000000000..6ecb06572e2e
--- /dev/null
+++ b/server/core/src/main/java/org/infinispan/server/core/dataconversion/json/SecureTypeResolverBuilder.java
@@ -0,0 +1,27 @@
+package org.infinispan.server.core.dataconversion.json;
+
+import java.util.Collection;
+
+import org.codehaus.jackson.map.MapperConfig;
+import org.codehaus.jackson.map.ObjectMapper;
+import org.codehaus.jackson.map.jsontype.NamedType;
+import org.codehaus.jackson.map.jsontype.TypeIdResolver;
+import org.codehaus.jackson.type.JavaType;
+
+/**
+ * Builder that can produce {@link SecureTypeIdResolver} from an existing TypeIdResolver.
+ *
+ * @since 9.3
+ */
+public class SecureTypeResolverBuilder extends ObjectMapper.DefaultTypeResolverBuilder {
+
+   protected SecureTypeResolverBuilder(ObjectMapper.DefaultTyping defaultTyping) {
+      super(defaultTyping);
+   }
+
+   protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType,
+                                       Collection<NamedType> subtypes, boolean forSer, boolean forDeser) {
+      TypeIdResolver result = super.idResolver(config, baseType, subtypes, forSer, forDeser);
+      return new SecureTypeIdResolver(result);
+   }
+}
diff --git a/server/core/src/main/java/org/infinispan/server/core/logging/Log.java b/server/core/src/main/java/org/infinispan/server/core/logging/Log.java
index 6ee96a8e89d9..bab59f5efde6 100644
--- a/server/core/src/main/java/org/infinispan/server/core/logging/Log.java
+++ b/server/core/src/main/java/org/infinispan/server/core/logging/Log.java
@@ -6,7 +6,10 @@
 import java.net.SocketAddress;
 
 import org.infinispan.commons.CacheConfigurationException;
+import org.infinispan.commons.dataconversion.MediaType;
+import org.infinispan.server.core.dataconversion.TranscodingException;
 import org.jboss.logging.BasicLogger;
+import org.jboss.logging.annotations.Cause;
 import org.jboss.logging.annotations.LogMessage;
 import org.jboss.logging.annotations.Message;
 import org.jboss.logging.annotations.MessageLogger;
@@ -85,4 +88,10 @@ public interface Log extends BasicLogger {
 
    @Message(value = "The supplied configuration for cache '%s' is missing a named configuration for it: %s", id = 5031)
    CacheConfigurationException missingCacheConfiguration(String name, String configuration);
+
+   @Message(value = "Error during transcoding", id = 5032)
+   TranscodingException errorDuringTranscoding(@Cause Throwable e);
+
+   @Message(value = "Data format '%s' not supported", id = 5033)
+   TranscodingException unsupportedDataFormat(MediaType contentFormat);
 }
diff --git a/server/rest/src/test/java/org/infinispan/rest/dataconversion/JavaSerializationTranscoderTest.java b/server/core/src/test/java/org/infinispan/server/core/dataconversion/JavaSerializationTranscoderTest.java
similarity index 96%
rename from server/rest/src/test/java/org/infinispan/rest/dataconversion/JavaSerializationTranscoderTest.java
rename to server/core/src/test/java/org/infinispan/server/core/dataconversion/JavaSerializationTranscoderTest.java
index bbbe20037a6c..44d86671ac5f 100644
--- a/server/rest/src/test/java/org/infinispan/rest/dataconversion/JavaSerializationTranscoderTest.java
+++ b/server/core/src/test/java/org/infinispan/server/core/dataconversion/JavaSerializationTranscoderTest.java
@@ -1,4 +1,7 @@
-package org.infinispan.rest.dataconversion;
+package org.infinispan.server.core.dataconversion;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
 
 import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.test.data.Address;
@@ -7,9 +10,6 @@
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.Test;
 
-import static org.testng.Assert.assertEquals;
-import static org.testng.Assert.assertTrue;
-
 @Test(groups = "functional", testName = "rest.JavaSerializationTranscoderTest")
 public class JavaSerializationTranscoderTest extends AbstractTranscoderTest {
    protected Person dataSrc;
diff --git a/server/rest/src/test/java/org/infinispan/rest/dataconversion/JsonObjectTranscoderTest.java b/server/core/src/test/java/org/infinispan/server/core/dataconversion/JsonTranscoderTest.java
similarity index 76%
rename from server/rest/src/test/java/org/infinispan/rest/dataconversion/JsonObjectTranscoderTest.java
rename to server/core/src/test/java/org/infinispan/server/core/dataconversion/JsonTranscoderTest.java
index 9bb7d45cb112..6843b740dbb4 100644
--- a/server/rest/src/test/java/org/infinispan/rest/dataconversion/JsonObjectTranscoderTest.java
+++ b/server/core/src/test/java/org/infinispan/server/core/dataconversion/JsonTranscoderTest.java
@@ -1,6 +1,6 @@
-package org.infinispan.rest.dataconversion;
+package org.infinispan.server.core.dataconversion;
 
-import static org.infinispan.rest.JSONConstants.TYPE;
+import static org.infinispan.server.core.dataconversion.JsonTranscoder.TYPE_PROPERTY;
 import static org.testng.Assert.assertEquals;
 
 import org.infinispan.commons.dataconversion.MediaType;
@@ -14,7 +14,7 @@
  * @since 9.2
  */
 @Test(groups = "functional", testName = "rest.JsonObjectTranscoderTest")
-public class JsonObjectTranscoderTest extends AbstractTranscoderTest {
+public class JsonTranscoderTest extends AbstractTranscoderTest {
    protected Person dataSrc;
 
    @BeforeClass(alwaysRun = true)
@@ -34,8 +34,8 @@ public void testTranscoderTranscode() throws Exception {
 
       Object result = transcoder.transcode(dataSrc, personMediaType, jsonMediaType);
 
-      assertEquals(result,
-            String.format("{\"" + TYPE + "\":\"%s\",\"name\":\"%s\",\"address\":{\"" + TYPE + "\":\"%s\",\"street\":null,\"city\":\"%s\",\"zip\":0}}",
+      assertEquals(new String((byte[]) result),
+            String.format("{\"" + TYPE_PROPERTY + "\":\"%s\",\"name\":\"%s\",\"address\":{\"" + TYPE_PROPERTY + "\":\"%s\",\"street\":null,\"city\":\"%s\",\"zip\":0}}",
                   Person.class.getName(),
                   "joe",
                   Address.class.getName(),
diff --git a/server/core/src/test/java/org/infinispan/server/core/dataconversion/XMLTranscoderTest.java b/server/core/src/test/java/org/infinispan/server/core/dataconversion/XMLTranscoderTest.java
new file mode 100644
index 000000000000..a5790c8fb7c2
--- /dev/null
+++ b/server/core/src/test/java/org/infinispan/server/core/dataconversion/XMLTranscoderTest.java
@@ -0,0 +1,44 @@
+package org.infinispan.server.core.dataconversion;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OBJECT;
+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_XML;
+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN;
+import static org.junit.Assert.assertArrayEquals;
+import static org.testng.Assert.assertEquals;
+
+import org.infinispan.test.data.Address;
+import org.infinispan.test.data.Person;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+@Test(groups = "functional", testName = "server.XMLTranscoderTest")
+public class XMLTranscoderTest {
+
+   private Person person;
+   private XMLTranscoder xmlTranscoder = new XMLTranscoder();
+
+   @BeforeClass(alwaysRun = true)
+   public void setUp() {
+      person = new Person("Joe");
+      Address address = new Address();
+      address.setCity("London");
+      person.setAddress(address);
+   }
+
+   public void testObjectToXML() {
+      String xmlString = (String) xmlTranscoder.transcode(person, APPLICATION_OBJECT, APPLICATION_XML);
+      Object transcodedBack = xmlTranscoder.transcode(xmlString, APPLICATION_XML, APPLICATION_OBJECT);
+      assertEquals(person, transcodedBack, "Must be an equal objects");
+   }
+
+   public void testTextToXML() {
+      byte[] value = "Hello World!".getBytes(UTF_8);
+
+      Object asXML = xmlTranscoder.transcode(value, TEXT_PLAIN, APPLICATION_XML);
+      assertEquals("<string>Hello World!</string>", new String((byte[]) asXML));
+
+      Object xmlAsText = xmlTranscoder.transcode(asXML, APPLICATION_XML, TEXT_PLAIN);
+      assertArrayEquals("<string>Hello World!</string>".getBytes(), (byte[]) xmlAsText);
+   }
+}
diff --git a/server/hotrod/src/main/java/org/infinispan/server/hotrod/AbstractEncoder1x.java b/server/hotrod/src/main/java/org/infinispan/server/hotrod/AbstractEncoder1x.java
index ff75e5f0c9e4..af091d3803a9 100644
--- a/server/hotrod/src/main/java/org/infinispan/server/hotrod/AbstractEncoder1x.java
+++ b/server/hotrod/src/main/java/org/infinispan/server/hotrod/AbstractEncoder1x.java
@@ -16,8 +16,8 @@
 import org.infinispan.distribution.ch.ConsistentHash;
 import org.infinispan.distribution.ch.KeyPartitioner;
 import org.infinispan.distribution.ch.impl.HashFunctionPartitioner;
-import org.infinispan.distribution.group.impl.PartitionerConsistentHash;
 import org.infinispan.distribution.group.impl.GroupingPartitioner;
+import org.infinispan.distribution.group.impl.PartitionerConsistentHash;
 import org.infinispan.manager.EmbeddedCacheManager;
 import org.infinispan.remoting.rpc.RpcManager;
 import org.infinispan.remoting.transport.Address;
@@ -162,7 +162,7 @@ AbstractTopologyResponse getTopologyResponse(Response r, Cache<Address, ServerAd
             case Constants.INTELLIGENCE_TOPOLOGY_AWARE:
             case Constants.INTELLIGENCE_HASH_DISTRIBUTION_AWARE:
                // Use the request cache's topology id as the HotRod topologyId.
-               AdvancedCache cache = server.getCacheInstance(r.cacheName, addressCache.getCacheManager(), false, true);
+               AdvancedCache cache = server.getCacheInstance(null, r.cacheName, addressCache.getCacheManager(), false, true);
                RpcManager rpcManager = cache.getRpcManager();
                // Only send a topology update if the cache is clustered
                int currentTopologyId = rpcManager == null ? Constants.DEFAULT_TOPOLOGY_ID : rpcManager.getTopologyId();
@@ -186,7 +186,7 @@ private AbstractTopologyResponse generateTopologyResponse(Response r, Cache<Addr
       // difference between the client topology id and the server topology id is 2 or more. The partial update
       // will have the topology id of the server - 1, so it won't prevent a regular topology update if/when
       // the topology cache is updated.
-      AdvancedCache<byte[], byte[]> cache = server.getCacheInstance(r.cacheName, addressCache.getCacheManager(), false, true);
+      AdvancedCache<byte[], byte[]> cache = server.getCacheInstance(null, r.cacheName, addressCache.getCacheManager(), false, true);
       List<Address> cacheMembers = cache.getRpcManager().getMembers();
 
       int responseTopologyId = currentTopologyId;
@@ -218,7 +218,7 @@ protected AbstractHashDistAwareResponse createHashDistAwareResp(int topologyId,
    }
 
    void writeHashTopologyUpdate(AbstractHashDistAwareResponse h, HotRodServer server, Response r, ByteBuf buffer) {
-      AdvancedCache<byte[], byte[]> cache = server.getCacheInstance(r.cacheName, server.getCacheManager(), false, true);
+      AdvancedCache<byte[], byte[]> cache = server.getCacheInstance(null, r.cacheName, server.getCacheManager(), false, true);
       DistributionManager distManager = cache.getDistributionManager();
       ConsistentHash ch = distManager.getWriteConsistentHash();
 
diff --git a/server/hotrod/src/main/java/org/infinispan/server/hotrod/AbstractTopologyAwareEncoder1x.java b/server/hotrod/src/main/java/org/infinispan/server/hotrod/AbstractTopologyAwareEncoder1x.java
index 08e9c9ee16bf..b0a1645e34e7 100644
--- a/server/hotrod/src/main/java/org/infinispan/server/hotrod/AbstractTopologyAwareEncoder1x.java
+++ b/server/hotrod/src/main/java/org/infinispan/server/hotrod/AbstractTopologyAwareEncoder1x.java
@@ -15,8 +15,8 @@
 import org.infinispan.distribution.ch.ConsistentHash;
 import org.infinispan.distribution.ch.KeyPartitioner;
 import org.infinispan.distribution.ch.impl.HashFunctionPartitioner;
-import org.infinispan.distribution.group.impl.PartitionerConsistentHash;
 import org.infinispan.distribution.group.impl.GroupingPartitioner;
+import org.infinispan.distribution.group.impl.PartitionerConsistentHash;
 import org.infinispan.remoting.transport.Address;
 import org.infinispan.server.hotrod.transport.ExtendedByteBuf;
 import org.infinispan.util.KeyValuePair;
@@ -55,7 +55,7 @@ void writeHashTopologyUpdate11(HashDistAware11Response h, HotRodServer server, R
          return;
       }
 
-      AdvancedCache<byte[], byte[]> cache = server.getCacheInstance(r.cacheName, server.getCacheManager(), false, true);
+      AdvancedCache<byte[], byte[]> cache = server.getCacheInstance(null, r.cacheName, server.getCacheManager(), false, true);
 
       // This is not quite correct, as the ownership of segments on the 1.0/1.1 clients is not exactly
       // the same as on the server. But the difference appears only for (numSegment*numOwners/MAX_INT)
diff --git a/server/hotrod/src/main/java/org/infinispan/server/hotrod/CacheRequestProcessor.java b/server/hotrod/src/main/java/org/infinispan/server/hotrod/CacheRequestProcessor.java
index fb8f6400fe77..a59e16f73349 100644
--- a/server/hotrod/src/main/java/org/infinispan/server/hotrod/CacheRequestProcessor.java
+++ b/server/hotrod/src/main/java/org/infinispan/server/hotrod/CacheRequestProcessor.java
@@ -3,22 +3,17 @@
 import java.util.BitSet;
 import java.util.Map;
 import java.util.Optional;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 
-import javax.security.auth.Subject;
-
 import org.infinispan.AdvancedCache;
 import org.infinispan.commons.logging.LogFactory;
 import org.infinispan.container.entries.CacheEntry;
 import org.infinispan.container.versioning.NumericVersion;
 import org.infinispan.context.Flag;
-import org.infinispan.factories.ComponentRegistry;
-import org.infinispan.lifecycle.ComponentStatus;
 import org.infinispan.notifications.Listener;
 import org.infinispan.notifications.cachemanagerlistener.annotation.CacheStopped;
 import org.infinispan.notifications.cachemanagerlistener.event.CacheStoppedEvent;
-import org.infinispan.persistence.manager.PersistenceManager;
+import org.infinispan.server.hotrod.HotRodServer.CacheInfo;
 import org.infinispan.server.hotrod.iteration.IterableIterationResult;
 import org.infinispan.server.hotrod.logging.Log;
 
@@ -29,13 +24,10 @@
 class CacheRequestProcessor extends BaseRequestProcessor {
    private static final Log log = LogFactory.getLog(CacheRequestProcessor.class, Log.class);
    private static final boolean trace = log.isTraceEnabled();
-   private static final Flag[] LOCAL_NON_BLOCKING_GET = new Flag[] { Flag.CACHE_MODE_LOCAL, Flag.SKIP_CACHE_LOAD };
-   private static final Flag[] SKIP_STATISTICS = new Flag[] { Flag.SKIP_STATISTICS };
+   private static final Flag[] SKIP_STATISTICS = new Flag[]{Flag.SKIP_STATISTICS};
 
    private final HotRodServer server;
    private final ClientListenerRegistry listenerRegistry;
-   // cacheStopped could be invoked concurrently
-   private final Map<String, CacheInfo> cacheInfo = new ConcurrentHashMap<>();
 
    CacheRequestProcessor(Channel channel, Executor executor, HotRodServer server) {
       super(channel, executor);
@@ -46,27 +38,7 @@ class CacheRequestProcessor extends BaseRequestProcessor {
 
    @CacheStopped
    public void cacheStopped(CacheStoppedEvent event) {
-      cacheInfo.remove(event.getCacheName());
-   }
-
-   private CacheInfo getCacheInfo(CacheDecodeContext cdc) {
-      // Fetching persistence manager would require security action, and would be too expensive
-      AdvancedCache<byte[], byte[]> cache = cdc.cache();
-      CacheInfo info = cacheInfo.get(cache.getName());
-      if (info == null) {
-         AdvancedCache<byte[], byte[]> localNonBlocking =
-               SecurityActions.anonymizeSecureCache(cache).noFlags().withFlags(LOCAL_NON_BLOCKING_GET);
-         if (cache.getStatus() != ComponentStatus.RUNNING) {
-            // stay on the safe side
-            return new CacheInfo(localNonBlocking, true, true);
-         }
-         ComponentRegistry cr = SecurityActions.getCacheComponentRegistry(cache);
-         PersistenceManager pm = cr.getComponent(PersistenceManager.class);
-         boolean hasIndexing = SecurityActions.getCacheConfiguration(cache).indexing().index().isEnabled();
-         info = new CacheInfo(localNonBlocking, pm.isEnabled(), hasIndexing);
-         cacheInfo.put(cache.getName(), info);
-      }
-      return info;
+      server.cacheStopped(event.getCacheName());
    }
 
    private boolean isBlockingRead(CacheDecodeContext cdc, CacheInfo info) {
@@ -74,14 +46,14 @@ private boolean isBlockingRead(CacheDecodeContext cdc, CacheInfo info) {
    }
 
    private boolean isBlockingWrite(CacheDecodeContext cdc) {
-      CacheInfo info = getCacheInfo(cdc);
+      CacheInfo info = server.getCacheInfo(cdc);
       // Note: cache store cannot be skipped (yet)
       return info.persistence || info.indexing && !cdc.decoder.isSkipIndexing(cdc.header);
    }
 
    void get(CacheDecodeContext cdc) {
       // This request is very fast, try to satisfy immediately
-      CacheInfo info = getCacheInfo(cdc);
+      CacheInfo info = server.getCacheInfo(cdc);
       CacheEntry<byte[], byte[]> entry = info.localNonBlocking(cdc.subject).getCacheEntry(cdc.key);
       if (entry != null) {
          handleGet(cdc, entry, null);
@@ -111,7 +83,7 @@ private void handleGet(CacheDecodeContext cdc, CacheEntry<byte[], byte[]> result
 
    void getKeyMetadata(CacheDecodeContext cdc) {
       // This request is very fast, try to satisfy immediately
-      CacheInfo info = getCacheInfo(cdc);
+      CacheInfo info = server.getCacheInfo(cdc);
       CacheEntry<byte[], byte[]> entry = info.localNonBlocking(cdc.subject).getCacheEntry(cdc.key);
       if (entry != null) {
          handleGetKeyMetadata(cdc, entry, null);
@@ -145,7 +117,7 @@ private void handleGetKeyMetadata(CacheDecodeContext cdc, CacheEntry<byte[], byt
 
    void containsKey(CacheDecodeContext cdc) {
       // This request is very fast, try to satisfy immediately
-      CacheInfo info = getCacheInfo(cdc);
+      CacheInfo info = server.getCacheInfo(cdc);
       boolean contains = info.localNonBlocking(cdc.subject).containsKey(cdc.key);
       if (contains) {
          writeSuccess(cdc, null);
@@ -400,7 +372,7 @@ private void handlePutAll(CacheDecodeContext cdc, Throwable throwable) {
    }
 
    void getAll(CacheDecodeContext cdc) {
-      if (isBlockingRead(cdc, getCacheInfo(cdc))) {
+      if (isBlockingRead(cdc, server.getCacheInfo(cdc))) {
          executor.execute(() -> getAllInternal(cdc));
       } else {
          getAllInternal(cdc);
@@ -596,24 +568,4 @@ public void putStream(CacheDecodeContext cdc) {
          buf.release();
       }
    }
-
-   private static class CacheInfo {
-      final AdvancedCache<byte[], byte[]> localNonBlocking;
-      final boolean persistence;
-      final boolean indexing;
-
-      private CacheInfo(AdvancedCache<byte[], byte[]> localNonBlocking, boolean persistence, boolean indexing) {
-         this.localNonBlocking = localNonBlocking;
-         this.persistence = persistence;
-         this.indexing = indexing;
-      }
-
-      AdvancedCache<byte[], byte[]> localNonBlocking(Subject subject) {
-         if (subject == null) {
-            return localNonBlocking;
-         } else {
-            return localNonBlocking.withSubject(subject);
-         }
-      }
-   }
 }
diff --git a/server/hotrod/src/main/java/org/infinispan/server/hotrod/ContextHandler.java b/server/hotrod/src/main/java/org/infinispan/server/hotrod/ContextHandler.java
index 48481bf12174..c42c338cd736 100644
--- a/server/hotrod/src/main/java/org/infinispan/server/hotrod/ContextHandler.java
+++ b/server/hotrod/src/main/java/org/infinispan/server/hotrod/ContextHandler.java
@@ -1,17 +1,14 @@
 package org.infinispan.server.hotrod;
 
-import static java.lang.String.format;
 import static org.infinispan.server.hotrod.ResponseWriting.writeResponse;
 
 import java.util.concurrent.Executor;
 
-import org.infinispan.AdvancedCache;
 import org.infinispan.commons.logging.LogFactory;
 import org.infinispan.counter.EmbeddedCounterManagerFactory;
 import org.infinispan.counter.impl.manager.EmbeddedCounterManager;
 import org.infinispan.manager.EmbeddedCacheManager;
 import org.infinispan.multimap.impl.EmbeddedMultimapCache;
-import org.infinispan.registry.InternalCacheRegistry;
 import org.infinispan.server.core.transport.NettyTransport;
 import org.infinispan.server.hotrod.logging.Log;
 
@@ -52,48 +49,13 @@ public void handlerAdded(ChannelHandlerContext ctx) {
       taskRequestProcessor = new TaskRequestProcessor(ctx.channel(), executor, server);
    }
 
+
    private void initCache(CacheDecodeContext cdc) throws RequestParsingException {
-      cdc.resource = cache(cdc);
+      cdc.resource = server.cache(cdc);
    }
 
    private void initMultimap(CacheDecodeContext cdc) throws RequestParsingException {
-      cdc.resource = new EmbeddedMultimapCache(cache(cdc));
-   }
-
-   public AdvancedCache<byte[], byte[]> cache(CacheDecodeContext cdc) throws RequestParsingException {
-      String cacheName = cdc.header.cacheName;
-      // Try to avoid calling cacheManager.getCacheNames() if possible, since this creates a lot of unnecessary garbage
-      AdvancedCache<byte[], byte[]> cache = server.getKnownCache(cacheName);
-      if (cache == null) {
-         cache = obtainCache(cdc.header, cacheName);
-      }
-      cache = cdc.decoder.getOptimizedCache(cdc.header, cache, server.getCacheConfiguration(cacheName));
-      if (cdc.subject != null) {
-         cache = cache.withSubject(cdc.subject);
-      }
-      return cache;
-   }
-
-   private AdvancedCache<byte[], byte[]> obtainCache(HotRodHeader header, String cacheName) throws RequestParsingException {
-      AdvancedCache<byte[], byte[]> cache;// Talking to the wrong cache are really request parsing errors
-      // and hence should be treated as client errors
-      InternalCacheRegistry icr = cacheManager.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);
-      if (icr.isPrivateCache(cacheName)) {
-         throw new RequestParsingException(
-               format("Remote requests are not allowed to private caches. Do no send remote requests to cache '%s'", cacheName),
-               header.version, header.messageId);
-      } else if (icr.internalCacheHasFlag(cacheName, InternalCacheRegistry.Flag.PROTECTED)) {
-         // We want to make sure the cache access is checked everytime, so don't store it as a "known" cache. More
-         // expensive, but these caches should not be accessed frequently
-         cache = server.getCacheInstance(cacheName, cacheManager, true, false);
-      } else if (!cacheName.isEmpty() && !cacheManager.getCacheNames().contains(cacheName)) {
-         throw new CacheNotFoundException(
-               format("Cache with name '%s' not found amongst the configured caches", cacheName),
-               header.version, header.messageId);
-      } else {
-         cache = server.getCacheInstance(cacheName, cacheManager, true, true);
-      }
-      return cache;
+      cdc.resource = new EmbeddedMultimapCache(server.cache(cdc));
    }
 
    @Override
@@ -146,12 +108,12 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Except
             cacheProcessor.removeIfUnmodified(cdc);
             break;
          case PING:
-            cache(cdc); // we need to throw an exception when this cache is inaccessible
+            server.cache(cdc); // we need to throw an exception when this cache is inaccessible
             writeResponse(ctx.channel(), new EmptyResponse(h.version, h.messageId, h.cacheName,
                   h.clientIntel, HotRodOperation.PING, OperationStatus.Success, h.topologyId));
             break;
          case STATS:
-            writeResponse(ctx.channel(), cdc.decoder.createStatsResponse(cdc, cache(cdc).getStats(), transport));
+            writeResponse(ctx.channel(), cdc.decoder.createStatsResponse(cdc, server.cache(cdc).getStats(), transport));
             break;
          case CLEAR:
             initCache(cdc);
diff --git a/server/hotrod/src/main/java/org/infinispan/server/hotrod/Decoder2x.java b/server/hotrod/src/main/java/org/infinispan/server/hotrod/Decoder2x.java
index e194814ab2fc..260bddba2092 100644
--- a/server/hotrod/src/main/java/org/infinispan/server/hotrod/Decoder2x.java
+++ b/server/hotrod/src/main/java/org/infinispan/server/hotrod/Decoder2x.java
@@ -20,12 +20,15 @@
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
+import java.util.function.Consumer;
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
 
 import org.infinispan.AdvancedCache;
 import org.infinispan.IllegalLifecycleStateException;
 import org.infinispan.commons.CacheException;
+import org.infinispan.commons.dataconversion.MediaType;
+import org.infinispan.commons.dataconversion.MediaTypeIds;
 import org.infinispan.commons.logging.LogFactory;
 import org.infinispan.commons.tx.XidImpl;
 import org.infinispan.commons.util.Util;
@@ -99,27 +102,122 @@ public boolean readHeader(ByteBuf buffer, byte version, long messageId, HotRodHe
          }
          buffer.markReaderIndex();
       }
-      int flag = ExtendedByteBufJava.readMaybeVInt(buffer);
-      if (flag == Integer.MIN_VALUE) {
+      if (header.clientIntel == 0) {
+         int flag = ExtendedByteBufJava.readMaybeVInt(buffer);
+         if (flag == Integer.MIN_VALUE) {
+            return false;
+         }
+         if (buffer.readableBytes() < 2) {
+            buffer.resetReaderIndex();
+            return false;
+         }
+         byte clientIntelligence = buffer.readByte();
+         int topologyId = ExtendedByteBufJava.readMaybeVInt(buffer);
+         if (topologyId == Integer.MIN_VALUE) {
+            return false;
+         }
+         header.flag = flag;
+         header.clientIntel = clientIntelligence;
+         header.topologyId = topologyId;
+         buffer.markReaderIndex();
+      }
+
+      if (HotRodVersion.HOTROD_28.isAtLeast(header.version)) {
+         if (header.keyType == null) {
+            if (!readMediaType(buffer, header, m -> header.keyType = m)) {
+               return false;
+            }
+            buffer.markReaderIndex();
+         }
+         if (header.valueType == null) {
+            if (!readMediaType(buffer, header, m -> header.valueType = m)) {
+               return false;
+            }
+            buffer.markReaderIndex();
+         }
+      }
+      return true;
+   }
+
+   private boolean readMediaType(ByteBuf buffer, HotRodHeader header, Consumer<MediaType> consumer) throws RequestParsingException {
+      if (buffer.readableBytes() < 1) {
          return false;
       }
-      if (buffer.readableBytes() < 2) {
-         buffer.resetReaderIndex();
+      byte keyMediaTypeDefinition = buffer.readByte();
+      if (keyMediaTypeDefinition == 0) {
+         consumer.accept(MediaType.MATCH_ALL);
+         return true;
+      }
+      if (keyMediaTypeDefinition == 1) {
+         return readPredefinedMediaType(buffer, consumer);
+      } else if (keyMediaTypeDefinition == 2) {
+         return readCustomMediaType(buffer, consumer);
+      } else {
+         throw new RequestParsingException("Unknown MediaType definition: " + keyMediaTypeDefinition, header.version, header.messageId);
+      }
+
+   }
+
+   private boolean readCustomMediaType(ByteBuf buffer, Consumer<MediaType> consumer) {
+      byte[] customMediaTypeBytes = ExtendedByteBufJava.readMaybeRangedBytes(buffer);
+      if (customMediaTypeBytes == null) {
          return false;
       }
-      byte clientIntelligence = buffer.readByte();
-      int topologyId = ExtendedByteBufJava.readMaybeVInt(buffer);
-      if (topologyId == Integer.MIN_VALUE) {
+      String strCustomMediaType = new String(customMediaTypeBytes, CharsetUtil.UTF_8);
+      Map<String, String> params = new HashMap<>();
+
+      if (!readMediaTypeParams(buffer, params)) {
          return false;
       }
-      header.flag = flag;
-      header.clientIntel = clientIntelligence;
-      header.topologyId = topologyId;
+      MediaType customMediaType = MediaType.parse(strCustomMediaType);
+      if(!params.isEmpty()) {
+         customMediaType = customMediaType.withParameters(params);
+      }
+      consumer.accept(customMediaType);
+      return true;
+   }
 
+   private boolean readPredefinedMediaType(ByteBuf buffer, Consumer<MediaType> consumer) {
+      int MediaTypeId = ExtendedByteBufJava.readMaybeVInt(buffer);
+      if (MediaTypeId == Integer.MIN_VALUE) {
+         return false;
+      }
+      String strMediaType = MediaTypeIds.getMediaType((short) MediaTypeId);
+      MediaType mediaType = MediaType.parse(strMediaType);
+      Map<String, String> params = new HashMap<>();
+      if (!readMediaTypeParams(buffer, params)) {
+         return false;
+      }
+      mediaType.withParameters(params);
+      consumer.accept(mediaType);
       buffer.markReaderIndex();
       return true;
    }
 
+
+   private boolean readMediaTypeParams(ByteBuf buffer, Map<String, String> params) {
+      int paramsSize = ExtendedByteBufJava.readMaybeVInt(buffer);
+      if (paramsSize == Integer.MIN_VALUE) {
+         return false;
+      }
+      for (int i = 0; i < paramsSize; i++) {
+         byte[] bytesParamName = ExtendedByteBufJava.readMaybeRangedBytes(buffer);
+         if (bytesParamName == null) {
+            return false;
+         }
+         String paramName = new String(bytesParamName, CharsetUtil.UTF_8);
+
+         byte[] bytesParamValue = ExtendedByteBufJava.readMaybeRangedBytes(buffer);
+         if (bytesParamValue == null) {
+            return false;
+         }
+         String paramValue = new String(bytesParamValue, CharsetUtil.UTF_8);
+
+         params.put(paramName, paramValue);
+      }
+      return true;
+   }
+
    @Override
    public CacheDecodeContext.RequestParameters readParameters(HotRodHeader header, ByteBuf buffer) {
       switch (header.op) {
@@ -418,7 +516,7 @@ public void customReadHeader(HotRodHeader header, ByteBuf buffer, CacheDecodeCon
       }
    }
 
-   private <T extends CounterDecodeContext>  void decodeCounterOperation(ByteBuf buffer, CacheDecodeContext context, List<Object> out, Supplier<T> decodeContextFactory) {
+   private <T extends CounterDecodeContext> void decodeCounterOperation(ByteBuf buffer, CacheDecodeContext context, List<Object> out, Supplier<T> decodeContextFactory) {
       T decodeContext = context.operationContext(decodeContextFactory);
       if (decodeContext.decode(buffer)) {
          out.add(context);
@@ -461,7 +559,7 @@ private Optional<TransactionWrite> readTransactionWrite(ByteBuf byteBuf) {
    }
 
    private Optional<TransactionWrite> readWriteExpirationAndValue(ByteBuf byteBuf, byte[] key,
-         long version, byte control) {
+                                                                  long version, byte control) {
       return readLifespanAndMaxidle(byteBuf).flatMap(parameters ->
             readMaybeRangedBytes(byteBuf).map(value ->
                   new TransactionWrite(key, version, control, parameters.lifespan, parameters.maxIdle, value)));
@@ -1061,7 +1159,7 @@ class TransactionWrite {
    private final byte control;
 
    TransactionWrite(byte[] key, long versionRead, byte control, CacheDecodeContext.ExpirationParam lifespan,
-         CacheDecodeContext.ExpirationParam maxIdle, byte[] value) {
+                    CacheDecodeContext.ExpirationParam maxIdle, byte[] value) {
       this.key = key;
       this.versionRead = versionRead;
       this.control = control;
diff --git a/server/hotrod/src/main/java/org/infinispan/server/hotrod/HotRodHeader.java b/server/hotrod/src/main/java/org/infinispan/server/hotrod/HotRodHeader.java
index 09dcf3842fdd..67b0d75405b9 100644
--- a/server/hotrod/src/main/java/org/infinispan/server/hotrod/HotRodHeader.java
+++ b/server/hotrod/src/main/java/org/infinispan/server/hotrod/HotRodHeader.java
@@ -1,5 +1,7 @@
 package org.infinispan.server.hotrod;
 
+import org.infinispan.commons.dataconversion.MediaType;
+
 /**
  * @author wburns
  * @since 9.0
@@ -12,11 +14,21 @@ public class HotRodHeader {
    int flag;
    short clientIntel;
    int topologyId;
+   MediaType keyType;
+   MediaType valueType;
 
    public HotRodOperation getOp() {
       return op;
    }
 
+   public String getKeyMediaType() {
+      return keyType == null ? MediaType.MATCH_ALL_TYPE : keyType.getTypeSubtype();
+   }
+
+   public String getValueMediaType() {
+      return valueType == null ? MediaType.MATCH_ALL_TYPE : valueType.getTypeSubtype();
+   }
+
    public byte getVersion() {
       return version;
    }
@@ -51,6 +63,8 @@ public String toString() {
             ", flag=" + flag +
             ", clientIntel=" + clientIntel +
             ", topologyId=" + topologyId +
+            ", keyType=" + keyType +
+            ", valueType=" + valueType +
             '}';
    }
 }
diff --git a/server/hotrod/src/main/java/org/infinispan/server/hotrod/HotRodServer.java b/server/hotrod/src/main/java/org/infinispan/server/hotrod/HotRodServer.java
index 9bfd70820c9e..878254dd8df7 100644
--- a/server/hotrod/src/main/java/org/infinispan/server/hotrod/HotRodServer.java
+++ b/server/hotrod/src/main/java/org/infinispan/server/hotrod/HotRodServer.java
@@ -1,8 +1,9 @@
 package org.infinispan.server.hotrod;
 
+import static java.lang.String.format;
+import static org.infinispan.commons.dataconversion.MediaType.MATCH_ALL;
 import static org.infinispan.counter.EmbeddedCounterManagerFactory.asCounterManager;
 
-import java.io.IOException;
 import java.io.ObjectInput;
 import java.io.ObjectOutput;
 import java.io.Serializable;
@@ -16,6 +17,7 @@
 import java.util.ServiceLoader;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingQueue;
@@ -25,6 +27,7 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.BiConsumer;
 
+import javax.security.auth.Subject;
 import javax.security.sasl.SaslServerFactory;
 
 import org.infinispan.AdvancedCache;
@@ -51,6 +54,7 @@
 import org.infinispan.filter.KeyValueFilterConverterFactory;
 import org.infinispan.filter.NamedFactory;
 import org.infinispan.filter.ParamKeyValueFilterConverterFactory;
+import org.infinispan.lifecycle.ComponentStatus;
 import org.infinispan.manager.EmbeddedCacheManager;
 import org.infinispan.metadata.Metadata;
 import org.infinispan.notifications.Listener;
@@ -61,6 +65,7 @@
 import org.infinispan.notifications.cachelistener.filter.CacheEventFilterFactory;
 import org.infinispan.notifications.cachemanagerlistener.annotation.CacheStopped;
 import org.infinispan.notifications.cachemanagerlistener.event.CacheStoppedEvent;
+import org.infinispan.persistence.manager.PersistenceManager;
 import org.infinispan.registry.InternalCacheRegistry;
 import org.infinispan.remoting.transport.Address;
 import org.infinispan.server.core.AbstractProtocolServer;
@@ -97,6 +102,9 @@ public class HotRodServer extends AbstractProtocolServer<HotRodServerConfigurati
 
    private static final String WORKER_THREADS_SYS_PROP = "infinispan.server.hotrod.workerThreads";
 
+   private static final Flag[] LOCAL_NON_BLOCKING_GET = new Flag[]{Flag.CACHE_MODE_LOCAL, Flag.SKIP_CACHE_LOAD};
+
+
    public HotRodServer() {
       super("HotRod");
    }
@@ -108,6 +116,7 @@ public HotRodServer() {
    private Map<String, AdvancedCache> knownCaches = CollectionFactory.makeConcurrentMap(4, 0.9f, 16);
    private Map<String, Configuration> knownCacheConfigurations = CollectionFactory.makeConcurrentMap(4, 0.9f, 16);
    private Map<String, ComponentRegistry> knownCacheRegistries = CollectionFactory.makeConcurrentMap(4, 0.9f, 16);
+   private final Map<String, CacheInfo> cacheInfo = new ConcurrentHashMap<>();
    private QueryFacade queryFacade;
    private Map<String, SaslServerFactory> saslMechFactories = CollectionFactory.makeConcurrentMap(4, 0.9f, 16);
    private ClientListenerRegistry clientListenerRegistry;
@@ -186,11 +195,11 @@ public Object filterAndConvert(Object key, Object value, Metadata metadata) {
       public static final class ToEmptyBytesKeyValueFilterConverterExternalizer implements Externalizer<ToEmptyBytesKeyValueFilterConverter> {
 
          @Override
-         public void writeObject(ObjectOutput output, ToEmptyBytesKeyValueFilterConverter object) throws IOException {
+         public void writeObject(ObjectOutput output, ToEmptyBytesKeyValueFilterConverter object) {
          }
 
          @Override
-         public ToEmptyBytesKeyValueFilterConverter readObject(ObjectInput input) throws IOException, ClassNotFoundException {
+         public ToEmptyBytesKeyValueFilterConverter readObject(ObjectInput input) {
             return INSTANCE;
          }
       }
@@ -238,7 +247,7 @@ protected void startInternal(HotRodServerConfiguration configuration, EmbeddedCa
       }
    }
 
-   AbortPolicy abortPolicy = new AbortPolicy() {
+   private AbortPolicy abortPolicy = new AbortPolicy() {
       @Override
       public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
          if (executor.isShutdown())
@@ -248,7 +257,7 @@ public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
       }
    };
 
-   public ExecutorService getExecutor(String threadPrefix) {
+   protected ExecutorService getExecutor(String threadPrefix) {
       if (this.executor == null || this.executor.isShutdown()) {
          DefaultThreadFactory factory = new DefaultThreadFactory(threadPrefix + "-ServerHandler");
          int workerThreads = Integer.getInteger(WORKER_THREADS_SYS_PROP, configuration.workerThreads());
@@ -299,7 +308,7 @@ protected void startTransport() {
 
    @Override
    protected void startDefaultCache() {
-      getCacheInstance(configuration.defaultCacheName(), cacheManager, true, true);
+      getCacheInstance(null, configuration.defaultCacheName(), cacheManager, true, true);
    }
 
    private void preStartCaches() {
@@ -308,7 +317,7 @@ private void preStartCaches() {
       InternalCacheRegistry icr = cacheManager.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);
       boolean authz = cacheManager.getCacheManagerConfiguration().security().authorization().enabled();
       for (String cacheName : cacheManager.getCacheNames()) {
-         getCacheInstance(cacheName, cacheManager, false, (!icr.internalCacheHasFlag(cacheName, InternalCacheRegistry.Flag.PROTECTED) || authz));
+         getCacheInstance(null, cacheName, cacheManager, false, (!icr.internalCacheHasFlag(cacheName, InternalCacheRegistry.Flag.PROTECTED) || authz));
       }
    }
 
@@ -359,13 +368,65 @@ protected ConfigurationBuilder createTopologyCacheConfig(long distSyncTimeout) {
       return builder;
    }
 
-   AdvancedCache getKnownCache(String cacheName) {
-      return knownCaches.get(cacheName);
+   public AdvancedCache<byte[], byte[]> cache(CacheDecodeContext cdc) throws RequestParsingException {
+      String cacheName = cdc.header.cacheName;
+      // Try to avoid calling cacheManager.getCacheNames() if possible, since this creates a lot of unnecessary garbage
+      AdvancedCache<byte[], byte[]> cache = knownCaches.get(scopedCacheKey(cacheName, cdc));
+      if (cache == null) {
+         InternalCacheRegistry icr = cacheManager.getGlobalComponentRegistry().getComponent(InternalCacheRegistry.class);
+         if (icr.isPrivateCache(cacheName)) {
+            throw new RequestParsingException(
+                  format("Remote requests are not allowed to private caches. Do no send remote requests to cache '%s'", cacheName),
+                  cdc.header.version, cdc.header.messageId);
+         } else if (icr.internalCacheHasFlag(cacheName, InternalCacheRegistry.Flag.PROTECTED)) {
+            // We want to make sure the cache access is checked everytime, so don't store it as a "known" cache. More
+            // expensive, but these caches should not be accessed frequently
+            cache = getCacheInstance(cdc, cacheName, cacheManager, true, false);
+         } else if (!cacheName.isEmpty() && !cacheManager.getCacheNames().contains(cacheName)) {
+            throw new CacheNotFoundException(
+                  format("Cache with name '%s' not found amongst the configured caches", cacheName),
+                  cdc.header.version, cdc.header.messageId);
+         } else {
+            cache = getCacheInstance(cdc, cacheName, cacheManager, true, true);
+         }
+         return cache;
+      }
+      cache = cdc.decoder.getOptimizedCache(cdc.header, cache, getCacheConfiguration(cacheName));
+      if (cdc.subject != null) {
+         cache = cache.withSubject(cdc.subject);
+      }
+      return cache;
+   }
+
+   public void cacheStopped(String cacheName) {
+      cacheInfo.keySet().stream().filter(k -> k.startsWith(cacheName)).forEach(cacheInfo::remove);
+   }
+
+   public CacheInfo getCacheInfo(CacheDecodeContext cdc) {
+      // Fetching persistence manager would require security action, and would be too expensive
+      AdvancedCache<byte[], byte[]> cache = cdc.cache();
+      CacheInfo info = cacheInfo.get(cache.getName() + cdc.getHeader().getKeyMediaType() + cdc.getHeader().getValueMediaType());
+
+      if (info == null) {
+         AdvancedCache<byte[], byte[]> localNonBlocking = SecurityActions.anonymizeSecureCache(cache)
+               .noFlags().withFlags(LOCAL_NON_BLOCKING_GET);
+         if (cache.getStatus() != ComponentStatus.RUNNING) {
+            // stay on the safe side
+            return new CacheInfo(localNonBlocking, true, true);
+         }
+         ComponentRegistry cr = SecurityActions.getCacheComponentRegistry(cache);
+         PersistenceManager pm = cr.getComponent(PersistenceManager.class);
+         boolean hasIndexing = SecurityActions.getCacheConfiguration(cache).indexing().index().isEnabled();
+         info = new CacheInfo(localNonBlocking, pm.isEnabled(), hasIndexing);
+         cacheInfo.put(cache.getName() + cdc.getHeader().getKeyMediaType() + cdc.getHeader().getValueMediaType(), info);
+      }
+      return info;
    }
 
-   AdvancedCache getCacheInstance(String cacheName, EmbeddedCacheManager cacheManager, Boolean skipCacheCheck, Boolean addToKnownCaches) {
+   AdvancedCache getCacheInstance(CacheDecodeContext cdc, String cacheName, EmbeddedCacheManager cacheManager, Boolean skipCacheCheck, Boolean addToKnownCaches) {
       AdvancedCache cache = null;
-      if (!skipCacheCheck) cache = knownCaches.get(cacheName);
+      String scopedCacheKey = scopedCacheKey(cacheName, cdc);
+      if (!skipCacheCheck) cache = knownCaches.get(scopedCacheKey);
 
       if (cache == null) {
          String validCacheName = cacheName.isEmpty() ? configuration.defaultCacheName() : cacheName;
@@ -379,11 +440,14 @@ AdvancedCache getCacheInstance(String cacheName, EmbeddedCacheManager cacheManag
          // We don't need synchronization as long as we store the cache last
          knownCacheConfigurations.put(cacheName, cacheConfiguration);
          knownCacheRegistries.put(cacheName, SecurityActions.getCacheComponentRegistry(cache.getAdvancedCache()));
+         if (cdc != null) {
+            cache = cache.withMediaType(cdc.header.getKeyMediaType(), cdc.header.getValueMediaType());
+         }
          if (addToKnownCaches) {
-            knownCaches.put(cacheName, cache);
+            knownCaches.put(scopedCacheKey, cache);
          }
          // make sure we register a Migrator for this cache!
-         tryRegisterMigrationManager(cacheName, cache);
+         tryRegisterMigrationManager(cache);
       }
 
       return cache;
@@ -397,7 +461,7 @@ ComponentRegistry getCacheRegistry(String cacheName) {
       return knownCacheRegistries.get(cacheName);
    }
 
-   void tryRegisterMigrationManager(String cacheName, AdvancedCache<byte[], byte[]> cache) {
+   private void tryRegisterMigrationManager(AdvancedCache<byte[], byte[]> cache) {
       ComponentRegistry cr = SecurityActions.getCacheComponentRegistry(cache.getAdvancedCache());
       RollingUpgradeManager migrationManager = cr.getComponent(RollingUpgradeManager.class);
       if (migrationManager != null) migrationManager.addSourceMigrator(new HotRodSourceMigrator(cache));
@@ -422,10 +486,6 @@ SaslServerFactory getSaslServerFactory(String mech) {
       return saslMechFactories.get(mech);
    }
 
-   private Cache<Address, ServerAddress> getAddressCache() {
-      return addressCache;
-   }
-
    public void addCacheEventFilterFactory(String name, CacheEventFilterFactory factory) {
       clientListenerRegistry.addCacheEventFilterFactory(name, factory);
    }
@@ -469,6 +529,16 @@ public IterationManager getIterationManager() {
       return iterationManager;
    }
 
+   private String scopedCacheKey(String cacheName, CacheDecodeContext cdc) {
+      String keyType = MATCH_ALL.getTypeSubtype();
+      String valueType = MATCH_ALL.getTypeSubtype();
+      if (cdc != null) {
+         keyType = cdc.getHeader().getKeyMediaType();
+         valueType = cdc.getHeader().getValueMediaType();
+      }
+      return cacheName + "|" + keyType + "|" + valueType;
+   }
+
    @Override
    public void stop() {
       if (removeCacheListener != null) {
@@ -495,6 +565,26 @@ public void stop() {
       super.stop();
    }
 
+   public static class CacheInfo {
+      final AdvancedCache<byte[], byte[]> localNonBlocking;
+      final boolean persistence;
+      final boolean indexing;
+
+      CacheInfo(AdvancedCache<byte[], byte[]> localNonBlocking, boolean persistence, boolean indexing) {
+         this.localNonBlocking = localNonBlocking;
+         this.persistence = persistence;
+         this.indexing = indexing;
+      }
+
+      AdvancedCache<byte[], byte[]> localNonBlocking(Subject subject) {
+         if (subject == null) {
+            return localNonBlocking;
+         } else {
+            return localNonBlocking.withSubject(subject);
+         }
+      }
+   }
+
    @Listener(sync = false, observation = Listener.Observation.POST)
    class ReAddMyAddressListener {
       private final Cache<Address, ServerAddress> addressCache;
@@ -541,7 +631,7 @@ public void topologyChanged(TopologyChangedEvent<Address, ServerAddress> event)
    class RemoveCacheListener {
       @CacheStopped
       public void cacheStopped(CacheStoppedEvent event) {
-         knownCaches.remove(event.getCacheName());
+         knownCaches.keySet().stream().filter(k -> k.startsWith(event.getCacheName() + "|")).forEach(knownCaches::remove);
          knownCacheConfigurations.remove(event.getCacheName());
          knownCacheRegistries.remove(event.getCacheName());
       }
diff --git a/server/integration/feature-pack/src/main/resources/modules/system/layers/base/org/infinispan/server/main/module.xml b/server/integration/feature-pack/src/main/resources/modules/system/layers/base/org/infinispan/server/main/module.xml
index da59ea727891..139359b7378d 100644
--- a/server/integration/feature-pack/src/main/resources/modules/system/layers/base/org/infinispan/server/main/module.xml
+++ b/server/integration/feature-pack/src/main/resources/modules/system/layers/base/org/infinispan/server/main/module.xml
@@ -11,12 +11,17 @@
 
    <dependencies>
       <module name="javax.api" />
+      <module name="com.thoughtworks.xstream"/>
       <module name="javax.transaction.api" />
       <module name="org.apache.xerces" services="import" />
       <module name="org.infinispan" />
       <module name="org.infinispan.tasks" services="import"/>
       <module name="org.infinispan.query" services="import"/>
       <module name="org.jboss.logging" />
+      <module name="org.codehaus.jackson.jackson-core-asl"/>
+      <module name="org.codehaus.jackson.jackson-mapper-asl"/>
+      <module name="org.codehaus.jackson.jackson-jaxrs"/>
+      <module name="org.codehaus.jackson.jackson-xc"/>
       <module name="org.jboss.marshalling" services="import"/>
       <module name="io.netty" export="true"/>
       <module name="org.jgroups" />
diff --git a/server/integration/feature-pack/src/main/resources/modules/system/layers/base/org/infinispan/server/rest/main/module.xml b/server/integration/feature-pack/src/main/resources/modules/system/layers/base/org/infinispan/server/rest/main/module.xml
index 80e359c8e139..ab521989badd 100644
--- a/server/integration/feature-pack/src/main/resources/modules/system/layers/base/org/infinispan/server/rest/main/module.xml
+++ b/server/integration/feature-pack/src/main/resources/modules/system/layers/base/org/infinispan/server/rest/main/module.xml
@@ -2,7 +2,7 @@
 
 <module xmlns="urn:jboss:module:1.5" name="org.infinispan.server.rest">
    <properties>
-      <property name="jboss.api" value="private" />
+      <property name="jboss.api" value="private"/>
    </properties>
 
    <resources>
@@ -10,15 +10,10 @@
    </resources>
 
    <dependencies>
-      <module name="com.thoughtworks.xstream" />
       <module name="javax.api" />
       <module name="javax.transaction.api" />
       <module name="javax.ws.rs.api" />
       <module name="org.apache.xerces" services="import" />
-      <module name="org.codehaus.jackson.jackson-core-asl" />
-      <module name="org.codehaus.jackson.jackson-mapper-asl" />
-      <module name="org.codehaus.jackson.jackson-jaxrs" />
-      <module name="org.codehaus.jackson.jackson-xc" />
       <module name="org.infinispan" />
       <module name="org.infinispan.remote-query.server" />
       <module name="org.infinispan.query.dsl" />
diff --git a/server/integration/testsuite/src/test/java/org/infinispan/server/test/client/hotrod/AbstractRemoteCacheIT.java b/server/integration/testsuite/src/test/java/org/infinispan/server/test/client/hotrod/AbstractRemoteCacheIT.java
index 4fe9edb98cba..24c791bfc950 100644
--- a/server/integration/testsuite/src/test/java/org/infinispan/server/test/client/hotrod/AbstractRemoteCacheIT.java
+++ b/server/integration/testsuite/src/test/java/org/infinispan/server/test/client/hotrod/AbstractRemoteCacheIT.java
@@ -1,7 +1,12 @@
 package org.infinispan.server.test.client.hotrod;
 
+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_JSON;
+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OCTET_STREAM;
+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_XML;
+import static org.infinispan.commons.dataconversion.MediaType.TEXT_PLAIN;
 import static org.infinispan.server.test.util.ITestUtils.isLocalMode;
 import static org.infinispan.server.test.util.ITestUtils.sleepForSecs;
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
@@ -27,8 +32,10 @@
 import java.util.stream.Collectors;
 
 import org.infinispan.arquillian.core.RemoteInfinispanServer;
+import org.infinispan.client.hotrod.DataFormat;
 import org.infinispan.client.hotrod.Flag;
 import org.infinispan.client.hotrod.MetadataValue;
+import org.infinispan.client.hotrod.ProtocolVersion;
 import org.infinispan.client.hotrod.RemoteCache;
 import org.infinispan.client.hotrod.RemoteCacheManager;
 import org.infinispan.client.hotrod.ServerStatistics;
@@ -42,6 +49,7 @@
 import org.infinispan.client.hotrod.event.ClientEvent;
 import org.infinispan.client.hotrod.logging.Log;
 import org.infinispan.client.hotrod.logging.LogFactory;
+import org.infinispan.commons.marshall.UTF8StringMarshaller;
 import org.infinispan.commons.marshall.jboss.GenericJBossMarshaller;
 import org.infinispan.commons.util.CloseableIterator;
 import org.infinispan.filter.KeyValueFilterConverterFactory;
@@ -818,7 +826,7 @@ public void testRemoveWithVersionAsync() throws Exception {
 
     @Test
     public void testGetProtocolVersion() throws Exception {
-       assertEquals("HotRod client, protocol version: 2.8", remoteCache.getProtocolVersion());
+       assertEquals("HotRod client, protocol version: " + ProtocolVersion.DEFAULT_PROTOCOL_VERSION, remoteCache.getProtocolVersion());
     }
 
     @Test
@@ -1076,6 +1084,43 @@ public void testCustomFilterEventsCustomPojo() {
         }
     }
 
+    @Test
+    @SuppressWarnings("unchecked")
+    public void testDataConversionsWithDefaultRemoteCache() throws Exception {
+        String key = "key-byte-array-1";
+        byte[] value = {0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x21};  // Hello!
+        String stringValue = new String(value);
+
+        DataFormat writeValueUnmarshalled = DataFormat.builder().valueType(APPLICATION_OCTET_STREAM).build();
+
+        // Avoid marshalling values when writing
+        RemoteCache<String, byte[]> octetStreamCacheValue = this.remoteCache.withDataFormat(writeValueUnmarshalled);
+        octetStreamCacheValue.put(key, value);
+
+        assertArrayEquals(value, octetStreamCacheValue.get(key));
+
+        // Read as UTF
+        Object utfValue = this.remoteCache
+              .withDataFormat(DataFormat.builder().valueType(TEXT_PLAIN).valueMarshaller(new UTF8StringMarshaller()).build())
+              .get(key);
+
+        assertEquals(stringValue, utfValue);
+
+        // Read as XML
+        Object xmlValue = this.remoteCache
+              .withDataFormat(DataFormat.builder().valueType(APPLICATION_XML).valueMarshaller(new UTF8StringMarshaller()).build())
+              .get(key);
+
+        assertEquals("<string>" + stringValue + "</string>", xmlValue);
+
+        // Read as JSON
+        Object jsonValue = this.remoteCache
+              .withDataFormat(DataFormat.builder().valueType(APPLICATION_JSON).valueMarshaller(new UTF8StringMarshaller()).build())
+              .get(key);
+
+        assertEquals("\"Hello!\"", jsonValue);
+    }
+
     public static <K> void expectOnlyCreatedEvent(K key, EventLogListener eventListener) {
         expectSingleEvent(key, eventListener, ClientEvent.Type.CLIENT_CACHE_ENTRY_CREATED);
         expectNoEvents(eventListener, ClientEvent.Type.CLIENT_CACHE_ENTRY_MODIFIED);
diff --git a/server/integration/testsuite/src/test/java/org/infinispan/server/test/client/hotrod/AbstractRemoteCacheManagerIT.java b/server/integration/testsuite/src/test/java/org/infinispan/server/test/client/hotrod/AbstractRemoteCacheManagerIT.java
index 2bac0d47f39e..d14ee35c35d3 100644
--- a/server/integration/testsuite/src/test/java/org/infinispan/server/test/client/hotrod/AbstractRemoteCacheManagerIT.java
+++ b/server/integration/testsuite/src/test/java/org/infinispan/server/test/client/hotrod/AbstractRemoteCacheManagerIT.java
@@ -501,7 +501,7 @@ private Marshaller getMarshallerField(RemoteCacheImpl rci) throws Exception {
 
         Field field = null;
         try {
-            field = RemoteCacheImpl.class.getDeclaredField("marshaller");
+            field = RemoteCacheImpl.class.getDeclaredField("defaultMarshaller");
         } catch (NoSuchFieldException e) {
             throw new Exception("Could not access marshaller field", e);
         }
diff --git a/server/integration/testsuite/src/test/java/org/infinispan/server/test/client/hotrod/HotRodCustomMarshallerEventIT.java b/server/integration/testsuite/src/test/java/org/infinispan/server/test/client/hotrod/HotRodCustomMarshallerEventIT.java
index 95ae5abf7ad0..6cbf852611d1 100644
--- a/server/integration/testsuite/src/test/java/org/infinispan/server/test/client/hotrod/HotRodCustomMarshallerEventIT.java
+++ b/server/integration/testsuite/src/test/java/org/infinispan/server/test/client/hotrod/HotRodCustomMarshallerEventIT.java
@@ -24,6 +24,7 @@
 import org.infinispan.client.hotrod.event.ClientCacheEntryModifiedEvent;
 import org.infinispan.client.hotrod.event.ClientCacheEntryRemovedEvent;
 import org.infinispan.client.hotrod.event.ClientEvent;
+import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.io.ByteBuffer;
 import org.infinispan.commons.io.ByteBufferFactory;
 import org.infinispan.commons.io.ByteBufferFactoryImpl;
@@ -195,5 +196,10 @@ public Object objectFromByteBuffer(byte[] buf, int offset, int length) {
         public boolean isMarshallable(Object o) {
             return true;
         }
+
+        @Override
+        public MediaType mediaType() {
+            return MediaType.parse("application/x-java-object; type=java.lang.Integer");
+        }
     }
 }
diff --git a/server/integration/testsuite/src/test/java/org/infinispan/server/test/cs/rocksdb/RocksDBCacheStoreIT.java b/server/integration/testsuite/src/test/java/org/infinispan/server/test/cs/rocksdb/RocksDBCacheStoreIT.java
index 88dbb87d13f8..cdf07a3a9717 100644
--- a/server/integration/testsuite/src/test/java/org/infinispan/server/test/cs/rocksdb/RocksDBCacheStoreIT.java
+++ b/server/integration/testsuite/src/test/java/org/infinispan/server/test/cs/rocksdb/RocksDBCacheStoreIT.java
@@ -1,5 +1,6 @@
 package org.infinispan.server.test.cs.rocksdb;
 
+import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OCTET_STREAM;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
@@ -14,6 +15,7 @@
 import org.infinispan.client.hotrod.RemoteCache;
 import org.infinispan.client.hotrod.RemoteCacheManager;
 import org.infinispan.client.hotrod.configuration.ConfigurationBuilder;
+import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.io.ByteBuffer;
 import org.infinispan.commons.io.ByteBufferImpl;
 import org.infinispan.commons.logging.Log;
@@ -136,6 +138,11 @@ public boolean isMarshallable(Object o) {
             return o instanceof String;
         }
 
+        @Override
+        public MediaType mediaType() {
+            return APPLICATION_OCTET_STREAM;
+        }
+
         @Override
         protected ByteBuffer objectToBuffer(Object o, int estimatedSize) {
             if (o instanceof String) {
diff --git a/server/rest/pom.xml b/server/rest/pom.xml
index 6851fbe8274c..5e5b3b9dfa9c 100644
--- a/server/rest/pom.xml
+++ b/server/rest/pom.xml
@@ -1,5 +1,6 @@
 <?xml version='1.0' encoding='UTF-8'?>
-<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd" xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
+<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <modelVersion>4.0.0</modelVersion>
 
    <parent>
@@ -18,16 +19,6 @@
    </properties>
 
    <dependencies>
-      <dependency>
-         <groupId>org.codehaus.jackson</groupId>
-         <artifactId>jackson-mapper-asl</artifactId>
-      </dependency>
-
-      <dependency>
-         <groupId>com.thoughtworks.xstream</groupId>
-         <artifactId>xstream</artifactId>
-      </dependency>
-
       <dependency>
         <groupId>org.infinispan</groupId>
         <artifactId>infinispan-server-core</artifactId>
@@ -39,7 +30,7 @@
       </dependency>
 
        <!-- and now for unit and integration tests -->
-      <dependency>
+       <dependency>
          <groupId>org.testng</groupId>
          <artifactId>testng</artifactId>
          <scope>test</scope>
diff --git a/server/rest/src/main/java/org/infinispan/rest/LifecycleCallbacks.java b/server/rest/src/main/java/org/infinispan/rest/LifecycleCallbacks.java
index 0f5b4364a239..0ad0681b78a3 100644
--- a/server/rest/src/main/java/org/infinispan/rest/LifecycleCallbacks.java
+++ b/server/rest/src/main/java/org/infinispan/rest/LifecycleCallbacks.java
@@ -5,11 +5,6 @@
 import org.infinispan.configuration.global.GlobalConfiguration;
 import org.infinispan.factories.GlobalComponentRegistry;
 import org.infinispan.lifecycle.ModuleLifecycle;
-import org.infinispan.marshall.core.EncoderRegistry;
-import org.infinispan.rest.dataconversion.JBossMarshallingTranscoder;
-import org.infinispan.rest.dataconversion.JavaSerializationTranscoder;
-import org.infinispan.rest.dataconversion.JsonTranscoder;
-import org.infinispan.rest.dataconversion.XMLTranscoder;
 import org.infinispan.rest.operations.mime.MimeMetadata;
 
 /**
@@ -25,10 +20,5 @@ public class LifecycleCallbacks implements ModuleLifecycle {
    public void cacheManagerStarting(GlobalComponentRegistry gcr, GlobalConfiguration globalConfiguration) {
       globalConfiguration.serialization().advancedExternalizers().put(
             MIME_METADATA, new MimeMetadata.Externalizer());
-      EncoderRegistry encoderRegistry = gcr.getComponent(EncoderRegistry.class);
-      encoderRegistry.registerTranscoder(new XMLTranscoder());
-      encoderRegistry.registerTranscoder(new JsonTranscoder());
-      encoderRegistry.registerTranscoder(new JavaSerializationTranscoder());
-      encoderRegistry.registerTranscoder(new JBossMarshallingTranscoder(encoderRegistry));
    }
 }
diff --git a/server/rest/src/main/java/org/infinispan/rest/cachemanager/RestCacheManager.java b/server/rest/src/main/java/org/infinispan/rest/cachemanager/RestCacheManager.java
index 50f4bfb35f71..290bfe593f12 100644
--- a/server/rest/src/main/java/org/infinispan/rest/cachemanager/RestCacheManager.java
+++ b/server/rest/src/main/java/org/infinispan/rest/cachemanager/RestCacheManager.java
@@ -141,4 +141,5 @@ private void tryRegisterMigrationManager(AdvancedCache<?, ?> cache) {
       RollingUpgradeManager migrationManager = cr.getComponent(RollingUpgradeManager.class);
       if (migrationManager != null) migrationManager.addSourceMigrator(new RestSourceMigrator(cache));
    }
+
 }
diff --git a/server/rest/src/main/java/org/infinispan/rest/logging/Log.java b/server/rest/src/main/java/org/infinispan/rest/logging/Log.java
index 624b56215266..11f680e853ef 100644
--- a/server/rest/src/main/java/org/infinispan/rest/logging/Log.java
+++ b/server/rest/src/main/java/org/infinispan/rest/logging/Log.java
@@ -56,9 +56,6 @@ public interface Log extends BasicLogger {
    @Message(value = "Remote requests are not allowed to internal caches when authorization is disabled. Do no send remote requests to cache '%s'", id = 12012)
    CacheUnavailableException requestNotAllowedToInternalCachesWithoutAuthz(String cacheName);
 
-   @Message(value = "Content cannot be converted to XML", id = 12013)
-   UnacceptableDataFormatException cannotConvertToXML(@Cause Throwable e);
-
    @Message(value = "Illegal compression level '%d'. The value must be >= 0 and <= 9", id = 12014)
    CacheConfigurationException illegalCompressionLevel(int compressionLevel);
 }
diff --git a/server/rest/src/main/java/org/infinispan/rest/search/HitSerializer.java b/server/rest/src/main/java/org/infinispan/rest/search/HitSerializer.java
index 2d13b772069f..00f898997c6c 100644
--- a/server/rest/src/main/java/org/infinispan/rest/search/HitSerializer.java
+++ b/server/rest/src/main/java/org/infinispan/rest/search/HitSerializer.java
@@ -1,5 +1,7 @@
 package org.infinispan.rest.search;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 import java.io.IOException;
 
 import org.codehaus.jackson.JsonGenerator;
@@ -11,7 +13,7 @@
 /**
  * @since 9.2
  */
-public class HitSerializer extends JsonSerializer<String> {
+public class HitSerializer extends JsonSerializer<Object> {
 
    private final ObjectMapper objectMapper = new ObjectMapper();
 
@@ -20,9 +22,9 @@ public HitSerializer() {
    }
 
    @Override
-   public void serialize(String string, JsonGenerator gen, SerializerProvider provider) throws IOException {
-      Object json = objectMapper.readValue(string, Object.class);
-      gen.writeObject(json);
+   public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
+      String rawJson = value instanceof String ? value.toString() : new String((byte[]) value, UTF_8);
+      gen.writeObject(objectMapper.readValue(rawJson, Object.class));
    }
 
 }
diff --git a/server/rest/src/test/java/org/infinispan/rest/BaseRestOperationsTest.java b/server/rest/src/test/java/org/infinispan/rest/BaseRestOperationsTest.java
index 5476470ecc40..e25e19a70393 100644
--- a/server/rest/src/test/java/org/infinispan/rest/BaseRestOperationsTest.java
+++ b/server/rest/src/test/java/org/infinispan/rest/BaseRestOperationsTest.java
@@ -1196,8 +1196,7 @@ public void testInvalidXMLConversion() throws Exception {
             .header(HttpHeader.ACCEPT, APPLICATION_XML_TYPE)
             .method(HttpMethod.GET).send();
 
-      ResponseAssertion.assertThat(response).isNotAcceptable();
-      ResponseAssertion.assertThat(response).containsReturnedText("Content cannot be converted to XML");
+      ResponseAssertion.assertThat(response).containsReturnedText("<string>foo</string>");
    }
 
 }
diff --git a/server/rest/src/test/java/org/infinispan/rest/cachemanager/RestCacheManagerTest.java b/server/rest/src/test/java/org/infinispan/rest/cachemanager/RestCacheManagerTest.java
index 634163b306b3..88d4def324c0 100644
--- a/server/rest/src/test/java/org/infinispan/rest/cachemanager/RestCacheManagerTest.java
+++ b/server/rest/src/test/java/org/infinispan/rest/cachemanager/RestCacheManagerTest.java
@@ -31,7 +31,7 @@ public void prepare() {
    }
 
    @Test
-   public void testShouldKeepEncodedCachesRegistered() {
+   public void shouldReuseEncodedCaches() {
       EmbeddedCacheManager embeddedCacheManager = Mockito.spy(cacheManager);
       RestCacheManager<Object> restCacheManager = new RestCacheManager<>(embeddedCacheManager, c -> Boolean.FALSE);
       Map<String, Cache<String, ?>> knownCaches = TestingUtil.extractField(restCacheManager, "knownCaches");
diff --git a/server/rest/src/test/java/org/infinispan/rest/dataconversion/XMLTranscoderTest.java b/server/rest/src/test/java/org/infinispan/rest/dataconversion/XMLTranscoderTest.java
deleted file mode 100644
index 57542e3456fc..000000000000
--- a/server/rest/src/test/java/org/infinispan/rest/dataconversion/XMLTranscoderTest.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.infinispan.rest.dataconversion;
-
-import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_OBJECT;
-import static org.infinispan.commons.dataconversion.MediaType.APPLICATION_XML;
-import static org.testng.Assert.assertEquals;
-
-import org.infinispan.test.data.Address;
-import org.infinispan.test.data.Person;
-import org.infinispan.test.dataconversion.AbstractTranscoderTest;
-import org.testng.annotations.BeforeClass;
-import org.testng.annotations.Test;
-
-@Test(groups = "functional", testName = "rest.XMLTranscoderTest")
-public class XMLTranscoderTest extends AbstractTranscoderTest {
-   protected Person dataSrc;
-
-   @BeforeClass(alwaysRun = true)
-   public void setUp() {
-      dataSrc = new Person("Joe");
-      Address address = new Address();
-      address.setCity("London");
-      dataSrc.setAddress(address);
-      transcoder = new XMLTranscoder();
-      supportedMediaTypes = transcoder.getSupportedMediaTypes();
-   }
-
-   @Override
-   public void testTranscoderTranscode() {
-      String xmlString = (String) transcoder.transcode(dataSrc, APPLICATION_OBJECT, APPLICATION_XML);
-
-      Object transcodedBack = transcoder.transcode(xmlString, APPLICATION_XML, APPLICATION_OBJECT);
-
-      assertEquals(dataSrc, transcodedBack, "Must be an equal objects");
-
-   }
-}
diff --git a/tools/src/main/java/org/infinispan/tools/store/migrator/marshaller/LegacyVersionAwareMarshaller.java b/tools/src/main/java/org/infinispan/tools/store/migrator/marshaller/LegacyVersionAwareMarshaller.java
index 12b5a66d778c..8e280dbf0037 100644
--- a/tools/src/main/java/org/infinispan/tools/store/migrator/marshaller/LegacyVersionAwareMarshaller.java
+++ b/tools/src/main/java/org/infinispan/tools/store/migrator/marshaller/LegacyVersionAwareMarshaller.java
@@ -8,6 +8,7 @@
 import java.io.OutputStream;
 import java.util.Map;
 
+import org.infinispan.commons.dataconversion.MediaType;
 import org.infinispan.commons.io.ByteBuffer;
 import org.infinispan.commons.marshall.AbstractMarshaller;
 import org.infinispan.commons.marshall.AdvancedExternalizer;
@@ -58,8 +59,7 @@ public ObjectInput startObjectInput(InputStream is, boolean isReentrant) throws
       ObjectInput in = defaultMarshaller.startObjectInput(is, isReentrant);
       try {
          in.readShort();
-      }
-      catch (Exception e) {
+      } catch (Exception e) {
          finishObjectInput(in);
          log.unableToReadVersionId();
          throw new IOException("Unable to read version id from first two bytes of stream: " + e.getMessage());
@@ -77,6 +77,11 @@ public boolean isMarshallable(Object o) throws Exception {
       return defaultMarshaller.isMarshallable(o);
    }
 
+   @Override
+   public MediaType mediaType() {
+      return defaultMarshaller.mediaType();
+   }
+
    @Override
    public Object objectFromObjectStream(ObjectInput in) throws IOException, ClassNotFoundException, InterruptedException {
       throw new UnsupportedOperationException();
diff --git a/wildfly-modules/src/main/resources/org/infinispan/server/main/module.xml b/wildfly-modules/src/main/resources/org/infinispan/server/main/module.xml
index c528daaf8ea2..265e71fd1dc3 100644
--- a/wildfly-modules/src/main/resources/org/infinispan/server/main/module.xml
+++ b/wildfly-modules/src/main/resources/org/infinispan/server/main/module.xml
@@ -2,7 +2,7 @@
 
 <module xmlns="urn:jboss:module:1.3" name="org.infinispan.server" slot="${slot}">
    <properties>
-      <property name="jboss.api" value="private" />
+      <property name="jboss.api" value="private"/>
    </properties>
 
    <resources>
@@ -11,11 +11,16 @@
 
    <dependencies>
       <module name="javax.api" />
+      <module name="com.thoughtworks.xstream" slot="${slot}"/>
       <module name="javax.transaction.api" />
       <module name="org.apache.xerces" services="import" />
       <module name="org.infinispan" slot="${slot}"/>
       <module name="org.infinispan.tasks" slot="${slot}" />
       <module name="org.infinispan.query" slot="${slot}" />
+      <module name="org.codehaus.jackson.jackson-core-asl"/>
+      <module name="org.codehaus.jackson.jackson-mapper-asl"/>
+      <module name="org.codehaus.jackson.jackson-jaxrs"/>
+      <module name="org.codehaus.jackson.jackson-xc"/>
       <module name="org.infinispan.tasks.api" slot="${slot}" />
       <module name="org.jboss.logging" />
       <module name="org.jboss.marshalling" slot="${slot}" services="import"/>
diff --git a/wildfly-modules/src/main/resources/org/infinispan/server/rest/main/module.xml b/wildfly-modules/src/main/resources/org/infinispan/server/rest/main/module.xml
index f7c747261e87..fe058a89cdd5 100644
--- a/wildfly-modules/src/main/resources/org/infinispan/server/rest/main/module.xml
+++ b/wildfly-modules/src/main/resources/org/infinispan/server/rest/main/module.xml
@@ -10,15 +10,10 @@
    </resources>
 
    <dependencies>
-      <module name="com.thoughtworks.xstream" slot="${slot}"/>
       <module name="javax.api" />
       <module name="javax.transaction.api" />
       <module name="javax.ws.rs.api" />
       <module name="org.apache.xerces" services="import" />
-      <module name="org.codehaus.jackson.jackson-core-asl" />
-      <module name="org.codehaus.jackson.jackson-mapper-asl" />
-      <module name="org.codehaus.jackson.jackson-jaxrs" />
-      <module name="org.codehaus.jackson.jackson-xc" />
       <module name="org.infinispan" slot="${slot}"/>
       <module name="org.infinispan.objectfilter" slot="${slot}"/>
       <module name="org.infinispan.server" slot="${slot}" services="import"/>
